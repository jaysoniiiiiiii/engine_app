{"ast":null,"code":"import _slicedToArray from \"/home/jay/Downloads/major/my-app/gis/web-gis/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport { lerp } from '../../math.js';\n\n/**\n * Creates chunks of equal length from a linestring\n * @param {number} chunkLength Length of each chunk.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Start offset of the `flatCoordinates`.\n * @param {number} end End offset of the `flatCoordinates`.\n * @param {number} stride Stride.\n * @return {Array<Array<number>>} Chunks of linestrings with stride 2.\n */\nexport function lineChunk(chunkLength, flatCoordinates, offset, end, stride) {\n  var chunks = [];\n  var cursor = offset;\n  var chunkM = 0;\n  var currentChunk = flatCoordinates.slice(offset, 2);\n  while (chunkM < chunkLength && cursor + stride < end) {\n    var _currentChunk$slice = currentChunk.slice(-2),\n      _currentChunk$slice2 = _slicedToArray(_currentChunk$slice, 2),\n      x1 = _currentChunk$slice2[0],\n      y1 = _currentChunk$slice2[1];\n    var x2 = flatCoordinates[cursor + stride];\n    var y2 = flatCoordinates[cursor + stride + 1];\n    var segmentLength = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n    chunkM += segmentLength;\n    if (chunkM >= chunkLength) {\n      var m = (chunkLength - chunkM + segmentLength) / segmentLength;\n      var x = lerp(x1, x2, m);\n      var y = lerp(y1, y2, m);\n      currentChunk.push(x, y);\n      chunks.push(currentChunk);\n      currentChunk = [x, y];\n      if (chunkM == chunkLength) {\n        cursor += stride;\n      }\n      chunkM = 0;\n    } else if (chunkM < chunkLength) {\n      currentChunk.push(flatCoordinates[cursor + stride], flatCoordinates[cursor + stride + 1]);\n      cursor += stride;\n    } else {\n      var missing = segmentLength - chunkM;\n      var _x = lerp(x1, x2, missing / segmentLength);\n      var _y = lerp(y1, y2, missing / segmentLength);\n      currentChunk.push(_x, _y);\n      chunks.push(currentChunk);\n      currentChunk = [_x, _y];\n      chunkM = 0;\n      cursor += stride;\n    }\n  }\n  if (chunkM > 0) {\n    chunks.push(currentChunk);\n  }\n  return chunks;\n}","map":{"version":3,"names":["lerp","lineChunk","chunkLength","flatCoordinates","offset","end","stride","chunks","cursor","chunkM","currentChunk","slice","_currentChunk$slice","_currentChunk$slice2","_slicedToArray","x1","y1","x2","y2","segmentLength","Math","sqrt","m","x","y","push","missing"],"sources":["/home/jay/Downloads/major/my-app/gis/web-gis/node_modules/ol/geom/flat/linechunk.js"],"sourcesContent":["import {lerp} from '../../math.js';\n\n/**\n * Creates chunks of equal length from a linestring\n * @param {number} chunkLength Length of each chunk.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Start offset of the `flatCoordinates`.\n * @param {number} end End offset of the `flatCoordinates`.\n * @param {number} stride Stride.\n * @return {Array<Array<number>>} Chunks of linestrings with stride 2.\n */\nexport function lineChunk(chunkLength, flatCoordinates, offset, end, stride) {\n  const chunks = [];\n  let cursor = offset;\n  let chunkM = 0;\n  let currentChunk = flatCoordinates.slice(offset, 2);\n  while (chunkM < chunkLength && cursor + stride < end) {\n    const [x1, y1] = currentChunk.slice(-2);\n    const x2 = flatCoordinates[cursor + stride];\n    const y2 = flatCoordinates[cursor + stride + 1];\n    const segmentLength = Math.sqrt(\n      (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1)\n    );\n    chunkM += segmentLength;\n    if (chunkM >= chunkLength) {\n      const m = (chunkLength - chunkM + segmentLength) / segmentLength;\n      const x = lerp(x1, x2, m);\n      const y = lerp(y1, y2, m);\n      currentChunk.push(x, y);\n      chunks.push(currentChunk);\n      currentChunk = [x, y];\n      if (chunkM == chunkLength) {\n        cursor += stride;\n      }\n      chunkM = 0;\n    } else if (chunkM < chunkLength) {\n      currentChunk.push(\n        flatCoordinates[cursor + stride],\n        flatCoordinates[cursor + stride + 1]\n      );\n      cursor += stride;\n    } else {\n      const missing = segmentLength - chunkM;\n      const x = lerp(x1, x2, missing / segmentLength);\n      const y = lerp(y1, y2, missing / segmentLength);\n      currentChunk.push(x, y);\n      chunks.push(currentChunk);\n      currentChunk = [x, y];\n      chunkM = 0;\n      cursor += stride;\n    }\n  }\n  if (chunkM > 0) {\n    chunks.push(currentChunk);\n  }\n  return chunks;\n}\n"],"mappings":";AAAA,SAAQA,IAAI,QAAO,eAAe;;AAElC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,SAASA,CAACC,WAAW,EAAEC,eAAe,EAAEC,MAAM,EAAEC,GAAG,EAAEC,MAAM,EAAE;EAC3E,IAAMC,MAAM,GAAG,EAAE;EACjB,IAAIC,MAAM,GAAGJ,MAAM;EACnB,IAAIK,MAAM,GAAG,CAAC;EACd,IAAIC,YAAY,GAAGP,eAAe,CAACQ,KAAK,CAACP,MAAM,EAAE,CAAC,CAAC;EACnD,OAAOK,MAAM,GAAGP,WAAW,IAAIM,MAAM,GAAGF,MAAM,GAAGD,GAAG,EAAE;IACpD,IAAAO,mBAAA,GAAiBF,YAAY,CAACC,KAAK,CAAC,CAAC,CAAC,CAAC;MAAAE,oBAAA,GAAAC,cAAA,CAAAF,mBAAA;MAAhCG,EAAE,GAAAF,oBAAA;MAAEG,EAAE,GAAAH,oBAAA;IACb,IAAMI,EAAE,GAAGd,eAAe,CAACK,MAAM,GAAGF,MAAM,CAAC;IAC3C,IAAMY,EAAE,GAAGf,eAAe,CAACK,MAAM,GAAGF,MAAM,GAAG,CAAC,CAAC;IAC/C,IAAMa,aAAa,GAAGC,IAAI,CAACC,IAAI,CAC7B,CAACJ,EAAE,GAAGF,EAAE,KAAKE,EAAE,GAAGF,EAAE,CAAC,GAAG,CAACG,EAAE,GAAGF,EAAE,KAAKE,EAAE,GAAGF,EAAE,CAAC,CAC9C;IACDP,MAAM,IAAIU,aAAa;IACvB,IAAIV,MAAM,IAAIP,WAAW,EAAE;MACzB,IAAMoB,CAAC,GAAG,CAACpB,WAAW,GAAGO,MAAM,GAAGU,aAAa,IAAIA,aAAa;MAChE,IAAMI,CAAC,GAAGvB,IAAI,CAACe,EAAE,EAAEE,EAAE,EAAEK,CAAC,CAAC;MACzB,IAAME,CAAC,GAAGxB,IAAI,CAACgB,EAAE,EAAEE,EAAE,EAAEI,CAAC,CAAC;MACzBZ,YAAY,CAACe,IAAI,CAACF,CAAC,EAAEC,CAAC,CAAC;MACvBjB,MAAM,CAACkB,IAAI,CAACf,YAAY,CAAC;MACzBA,YAAY,GAAG,CAACa,CAAC,EAAEC,CAAC,CAAC;MACrB,IAAIf,MAAM,IAAIP,WAAW,EAAE;QACzBM,MAAM,IAAIF,MAAM;MAClB;MACAG,MAAM,GAAG,CAAC;IACZ,CAAC,MAAM,IAAIA,MAAM,GAAGP,WAAW,EAAE;MAC/BQ,YAAY,CAACe,IAAI,CACftB,eAAe,CAACK,MAAM,GAAGF,MAAM,CAAC,EAChCH,eAAe,CAACK,MAAM,GAAGF,MAAM,GAAG,CAAC,CAAC,CACrC;MACDE,MAAM,IAAIF,MAAM;IAClB,CAAC,MAAM;MACL,IAAMoB,OAAO,GAAGP,aAAa,GAAGV,MAAM;MACtC,IAAMc,EAAC,GAAGvB,IAAI,CAACe,EAAE,EAAEE,EAAE,EAAES,OAAO,GAAGP,aAAa,CAAC;MAC/C,IAAMK,EAAC,GAAGxB,IAAI,CAACgB,EAAE,EAAEE,EAAE,EAAEQ,OAAO,GAAGP,aAAa,CAAC;MAC/CT,YAAY,CAACe,IAAI,CAACF,EAAC,EAAEC,EAAC,CAAC;MACvBjB,MAAM,CAACkB,IAAI,CAACf,YAAY,CAAC;MACzBA,YAAY,GAAG,CAACa,EAAC,EAAEC,EAAC,CAAC;MACrBf,MAAM,GAAG,CAAC;MACVD,MAAM,IAAIF,MAAM;IAClB;EACF;EACA,IAAIG,MAAM,GAAG,CAAC,EAAE;IACdF,MAAM,CAACkB,IAAI,CAACf,YAAY,CAAC;EAC3B;EACA,OAAOH,MAAM;AACf"},"metadata":{},"sourceType":"module","externalDependencies":[]}