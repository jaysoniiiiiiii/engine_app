{"ast":null,"code":"import _classCallCheck from \"/home/jay/Downloads/major/my-app/gis/web-gis/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/jay/Downloads/major/my-app/gis/web-gis/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"/home/jay/Downloads/major/my-app/gis/web-gis/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _get from \"/home/jay/Downloads/major/my-app/gis/web-gis/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/home/jay/Downloads/major/my-app/gis/web-gis/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/home/jay/Downloads/major/my-app/gis/web-gis/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/home/jay/Downloads/major/my-app/gis/web-gis/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\n/**\n * @module ol/MapBrowserEventHandler\n */\n\nimport EventType from './events/EventType.js';\nimport MapBrowserEvent from './MapBrowserEvent.js';\nimport MapBrowserEventType from './MapBrowserEventType.js';\nimport PointerEventType from './pointer/EventType.js';\nimport Target from './events/Target.js';\nimport { PASSIVE_EVENT_LISTENERS } from './has.js';\nimport { listen, unlistenByKey } from './events.js';\nvar MapBrowserEventHandler = /*#__PURE__*/function (_Target) {\n  _inherits(MapBrowserEventHandler, _Target);\n  var _super = _createSuper(MapBrowserEventHandler);\n  /**\n   * @param {import(\"./Map.js\").default} map The map with the viewport to listen to events on.\n   * @param {number} [moveTolerance] The minimal distance the pointer must travel to trigger a move.\n   */\n  function MapBrowserEventHandler(map, moveTolerance) {\n    var _this;\n    _classCallCheck(this, MapBrowserEventHandler);\n    _this = _super.call(this, map);\n\n    /**\n     * This is the element that we will listen to the real events on.\n     * @type {import(\"./Map.js\").default}\n     * @private\n     */\n    _this.map_ = map;\n\n    /**\n     * @type {any}\n     * @private\n     */\n    _this.clickTimeoutId_;\n\n    /**\n     * Emulate dblclick and singleclick. Will be true when only one pointer is active.\n     * @type {boolean}\n     */\n    _this.emulateClicks_ = false;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    _this.dragging_ = false;\n\n    /**\n     * @type {!Array<import(\"./events.js\").EventsKey>}\n     * @private\n     */\n    _this.dragListenerKeys_ = [];\n\n    /**\n     * @type {number}\n     * @private\n     */\n    _this.moveTolerance_ = moveTolerance === undefined ? 1 : moveTolerance;\n\n    /**\n     * The most recent \"down\" type event (or null if none have occurred).\n     * Set on pointerdown.\n     * @type {PointerEvent|null}\n     * @private\n     */\n    _this.down_ = null;\n    var element = _this.map_.getViewport();\n\n    /**\n     * @type {Array<PointerEvent>}\n     * @private\n     */\n    _this.activePointers_ = [];\n\n    /**\n     * @type {!Object<number, Event>}\n     * @private\n     */\n    _this.trackedTouches_ = {};\n    _this.element_ = element;\n\n    /**\n     * @type {?import(\"./events.js\").EventsKey}\n     * @private\n     */\n    _this.pointerdownListenerKey_ = listen(element, PointerEventType.POINTERDOWN, _this.handlePointerDown_, _assertThisInitialized(_this));\n\n    /**\n     * @type {PointerEvent}\n     * @private\n     */\n    _this.originalPointerMoveEvent_;\n\n    /**\n     * @type {?import(\"./events.js\").EventsKey}\n     * @private\n     */\n    _this.relayedListenerKey_ = listen(element, PointerEventType.POINTERMOVE, _this.relayMoveEvent_, _assertThisInitialized(_this));\n\n    /**\n     * @private\n     */\n    _this.boundHandleTouchMove_ = _this.handleTouchMove_.bind(_assertThisInitialized(_this));\n    _this.element_.addEventListener(EventType.TOUCHMOVE, _this.boundHandleTouchMove_, PASSIVE_EVENT_LISTENERS ? {\n      passive: false\n    } : false);\n    return _this;\n  }\n\n  /**\n   * @param {PointerEvent} pointerEvent Pointer\n   * event.\n   * @private\n   */\n  _createClass(MapBrowserEventHandler, [{\n    key: \"emulateClick_\",\n    value: function emulateClick_(pointerEvent) {\n      var _this2 = this;\n      var newEvent = new MapBrowserEvent(MapBrowserEventType.CLICK, this.map_, pointerEvent);\n      this.dispatchEvent(newEvent);\n      if (this.clickTimeoutId_ !== undefined) {\n        // double-click\n        clearTimeout(this.clickTimeoutId_);\n        this.clickTimeoutId_ = undefined;\n        newEvent = new MapBrowserEvent(MapBrowserEventType.DBLCLICK, this.map_, pointerEvent);\n        this.dispatchEvent(newEvent);\n      } else {\n        // click\n        this.clickTimeoutId_ = setTimeout(function () {\n          _this2.clickTimeoutId_ = undefined;\n          var newEvent = new MapBrowserEvent(MapBrowserEventType.SINGLECLICK, _this2.map_, pointerEvent);\n          _this2.dispatchEvent(newEvent);\n        }, 250);\n      }\n    }\n\n    /**\n     * Keeps track on how many pointers are currently active.\n     *\n     * @param {PointerEvent} pointerEvent Pointer\n     * event.\n     * @private\n     */\n  }, {\n    key: \"updateActivePointers_\",\n    value: function updateActivePointers_(pointerEvent) {\n      var event = pointerEvent;\n      var id = event.pointerId;\n      if (event.type == MapBrowserEventType.POINTERUP || event.type == MapBrowserEventType.POINTERCANCEL) {\n        delete this.trackedTouches_[id];\n        for (var pointerId in this.trackedTouches_) {\n          if (this.trackedTouches_[pointerId].target !== event.target) {\n            // Some platforms assign a new pointerId when the target changes.\n            // If this happens, delete one tracked pointer. If there is more\n            // than one tracked pointer for the old target, it will be cleared\n            // by subsequent POINTERUP events from other pointers.\n            delete this.trackedTouches_[pointerId];\n            break;\n          }\n        }\n      } else if (event.type == MapBrowserEventType.POINTERDOWN || event.type == MapBrowserEventType.POINTERMOVE) {\n        this.trackedTouches_[id] = event;\n      }\n      this.activePointers_ = Object.values(this.trackedTouches_);\n    }\n\n    /**\n     * @param {PointerEvent} pointerEvent Pointer\n     * event.\n     * @private\n     */\n  }, {\n    key: \"handlePointerUp_\",\n    value: function handlePointerUp_(pointerEvent) {\n      this.updateActivePointers_(pointerEvent);\n      var newEvent = new MapBrowserEvent(MapBrowserEventType.POINTERUP, this.map_, pointerEvent, undefined, undefined, this.activePointers_);\n      this.dispatchEvent(newEvent);\n\n      // We emulate click events on left mouse button click, touch contact, and pen\n      // contact. isMouseActionButton returns true in these cases (evt.button is set\n      // to 0).\n      // See http://www.w3.org/TR/pointerevents/#button-states\n      // We only fire click, singleclick, and doubleclick if nobody has called\n      // event.preventDefault().\n      if (this.emulateClicks_ && !newEvent.defaultPrevented && !this.dragging_ && this.isMouseActionButton_(pointerEvent)) {\n        this.emulateClick_(this.down_);\n      }\n      if (this.activePointers_.length === 0) {\n        this.dragListenerKeys_.forEach(unlistenByKey);\n        this.dragListenerKeys_.length = 0;\n        this.dragging_ = false;\n        this.down_ = null;\n      }\n    }\n\n    /**\n     * @param {PointerEvent} pointerEvent Pointer\n     * event.\n     * @return {boolean} If the left mouse button was pressed.\n     * @private\n     */\n  }, {\n    key: \"isMouseActionButton_\",\n    value: function isMouseActionButton_(pointerEvent) {\n      return pointerEvent.button === 0;\n    }\n\n    /**\n     * @param {PointerEvent} pointerEvent Pointer\n     * event.\n     * @private\n     */\n  }, {\n    key: \"handlePointerDown_\",\n    value: function handlePointerDown_(pointerEvent) {\n      this.emulateClicks_ = this.activePointers_.length === 0;\n      this.updateActivePointers_(pointerEvent);\n      var newEvent = new MapBrowserEvent(MapBrowserEventType.POINTERDOWN, this.map_, pointerEvent, undefined, undefined, this.activePointers_);\n      this.dispatchEvent(newEvent);\n      this.down_ = new PointerEvent(pointerEvent.type, pointerEvent);\n      Object.defineProperty(this.down_, 'target', {\n        writable: false,\n        value: pointerEvent.target\n      });\n      if (this.dragListenerKeys_.length === 0) {\n        var doc = this.map_.getOwnerDocument();\n        this.dragListenerKeys_.push(listen(doc, MapBrowserEventType.POINTERMOVE, this.handlePointerMove_, this), listen(doc, MapBrowserEventType.POINTERUP, this.handlePointerUp_, this),\n        /* Note that the listener for `pointercancel is set up on\n         * `pointerEventHandler_` and not `documentPointerEventHandler_` like\n         * the `pointerup` and `pointermove` listeners.\n         *\n         * The reason for this is the following: `TouchSource.vacuumTouches_()`\n         * issues `pointercancel` events, when there was no `touchend` for a\n         * `touchstart`. Now, let's say a first `touchstart` is registered on\n         * `pointerEventHandler_`. The `documentPointerEventHandler_` is set up.\n         * But `documentPointerEventHandler_` doesn't know about the first\n         * `touchstart`. If there is no `touchend` for the `touchstart`, we can\n         * only receive a `touchcancel` from `pointerEventHandler_`, because it is\n         * only registered there.\n         */\n        listen(this.element_, MapBrowserEventType.POINTERCANCEL, this.handlePointerUp_, this));\n        if (this.element_.getRootNode && this.element_.getRootNode() !== doc) {\n          this.dragListenerKeys_.push(listen(this.element_.getRootNode(), MapBrowserEventType.POINTERUP, this.handlePointerUp_, this));\n        }\n      }\n    }\n\n    /**\n     * @param {PointerEvent} pointerEvent Pointer\n     * event.\n     * @private\n     */\n  }, {\n    key: \"handlePointerMove_\",\n    value: function handlePointerMove_(pointerEvent) {\n      // Between pointerdown and pointerup, pointermove events are triggered.\n      // To avoid a 'false' touchmove event to be dispatched, we test if the pointer\n      // moved a significant distance.\n      if (this.isMoving_(pointerEvent)) {\n        this.updateActivePointers_(pointerEvent);\n        this.dragging_ = true;\n        var newEvent = new MapBrowserEvent(MapBrowserEventType.POINTERDRAG, this.map_, pointerEvent, this.dragging_, undefined, this.activePointers_);\n        this.dispatchEvent(newEvent);\n      }\n    }\n\n    /**\n     * Wrap and relay a pointermove event.\n     * @param {PointerEvent} pointerEvent Pointer\n     * event.\n     * @private\n     */\n  }, {\n    key: \"relayMoveEvent_\",\n    value: function relayMoveEvent_(pointerEvent) {\n      this.originalPointerMoveEvent_ = pointerEvent;\n      var dragging = !!(this.down_ && this.isMoving_(pointerEvent));\n      this.dispatchEvent(new MapBrowserEvent(MapBrowserEventType.POINTERMOVE, this.map_, pointerEvent, dragging));\n    }\n\n    /**\n     * Flexible handling of a `touch-action: none` css equivalent: because calling\n     * `preventDefault()` on a `pointermove` event does not stop native page scrolling\n     * and zooming, we also listen for `touchmove` and call `preventDefault()` on it\n     * when an interaction (currently `DragPan` handles the event.\n     * @param {TouchEvent} event Event.\n     * @private\n     */\n  }, {\n    key: \"handleTouchMove_\",\n    value: function handleTouchMove_(event) {\n      // Due to https://github.com/mpizenberg/elm-pep/issues/2, `this.originalPointerMoveEvent_`\n      // may not be initialized yet when we get here on a platform without native pointer events.\n      var originalEvent = this.originalPointerMoveEvent_;\n      if ((!originalEvent || originalEvent.defaultPrevented) && (typeof event.cancelable !== 'boolean' || event.cancelable === true)) {\n        event.preventDefault();\n      }\n    }\n\n    /**\n     * @param {PointerEvent} pointerEvent Pointer\n     * event.\n     * @return {boolean} Is moving.\n     * @private\n     */\n  }, {\n    key: \"isMoving_\",\n    value: function isMoving_(pointerEvent) {\n      return this.dragging_ || Math.abs(pointerEvent.clientX - this.down_.clientX) > this.moveTolerance_ || Math.abs(pointerEvent.clientY - this.down_.clientY) > this.moveTolerance_;\n    }\n\n    /**\n     * Clean up.\n     */\n  }, {\n    key: \"disposeInternal\",\n    value: function disposeInternal() {\n      if (this.relayedListenerKey_) {\n        unlistenByKey(this.relayedListenerKey_);\n        this.relayedListenerKey_ = null;\n      }\n      this.element_.removeEventListener(EventType.TOUCHMOVE, this.boundHandleTouchMove_);\n      if (this.pointerdownListenerKey_) {\n        unlistenByKey(this.pointerdownListenerKey_);\n        this.pointerdownListenerKey_ = null;\n      }\n      this.dragListenerKeys_.forEach(unlistenByKey);\n      this.dragListenerKeys_.length = 0;\n      this.element_ = null;\n      _get(_getPrototypeOf(MapBrowserEventHandler.prototype), \"disposeInternal\", this).call(this);\n    }\n  }]);\n  return MapBrowserEventHandler;\n}(Target);\nexport default MapBrowserEventHandler;","map":{"version":3,"names":["EventType","MapBrowserEvent","MapBrowserEventType","PointerEventType","Target","PASSIVE_EVENT_LISTENERS","listen","unlistenByKey","MapBrowserEventHandler","_Target","_inherits","_super","_createSuper","map","moveTolerance","_this","_classCallCheck","call","map_","clickTimeoutId_","emulateClicks_","dragging_","dragListenerKeys_","moveTolerance_","undefined","down_","element","getViewport","activePointers_","trackedTouches_","element_","pointerdownListenerKey_","POINTERDOWN","handlePointerDown_","_assertThisInitialized","originalPointerMoveEvent_","relayedListenerKey_","POINTERMOVE","relayMoveEvent_","boundHandleTouchMove_","handleTouchMove_","bind","addEventListener","TOUCHMOVE","passive","_createClass","key","value","emulateClick_","pointerEvent","_this2","newEvent","CLICK","dispatchEvent","clearTimeout","DBLCLICK","setTimeout","SINGLECLICK","updateActivePointers_","event","id","pointerId","type","POINTERUP","POINTERCANCEL","target","Object","values","handlePointerUp_","defaultPrevented","isMouseActionButton_","length","forEach","button","PointerEvent","defineProperty","writable","doc","getOwnerDocument","push","handlePointerMove_","getRootNode","isMoving_","POINTERDRAG","dragging","originalEvent","cancelable","preventDefault","Math","abs","clientX","clientY","disposeInternal","removeEventListener","_get","_getPrototypeOf","prototype"],"sources":["/home/jay/Downloads/major/my-app/gis/web-gis/node_modules/ol/MapBrowserEventHandler.js"],"sourcesContent":["/**\n * @module ol/MapBrowserEventHandler\n */\n\nimport EventType from './events/EventType.js';\nimport MapBrowserEvent from './MapBrowserEvent.js';\nimport MapBrowserEventType from './MapBrowserEventType.js';\nimport PointerEventType from './pointer/EventType.js';\nimport Target from './events/Target.js';\nimport {PASSIVE_EVENT_LISTENERS} from './has.js';\nimport {listen, unlistenByKey} from './events.js';\n\nclass MapBrowserEventHandler extends Target {\n  /**\n   * @param {import(\"./Map.js\").default} map The map with the viewport to listen to events on.\n   * @param {number} [moveTolerance] The minimal distance the pointer must travel to trigger a move.\n   */\n  constructor(map, moveTolerance) {\n    super(map);\n\n    /**\n     * This is the element that we will listen to the real events on.\n     * @type {import(\"./Map.js\").default}\n     * @private\n     */\n    this.map_ = map;\n\n    /**\n     * @type {any}\n     * @private\n     */\n    this.clickTimeoutId_;\n\n    /**\n     * Emulate dblclick and singleclick. Will be true when only one pointer is active.\n     * @type {boolean}\n     */\n    this.emulateClicks_ = false;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.dragging_ = false;\n\n    /**\n     * @type {!Array<import(\"./events.js\").EventsKey>}\n     * @private\n     */\n    this.dragListenerKeys_ = [];\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.moveTolerance_ = moveTolerance === undefined ? 1 : moveTolerance;\n\n    /**\n     * The most recent \"down\" type event (or null if none have occurred).\n     * Set on pointerdown.\n     * @type {PointerEvent|null}\n     * @private\n     */\n    this.down_ = null;\n\n    const element = this.map_.getViewport();\n\n    /**\n     * @type {Array<PointerEvent>}\n     * @private\n     */\n    this.activePointers_ = [];\n\n    /**\n     * @type {!Object<number, Event>}\n     * @private\n     */\n    this.trackedTouches_ = {};\n\n    this.element_ = element;\n\n    /**\n     * @type {?import(\"./events.js\").EventsKey}\n     * @private\n     */\n    this.pointerdownListenerKey_ = listen(\n      element,\n      PointerEventType.POINTERDOWN,\n      this.handlePointerDown_,\n      this\n    );\n\n    /**\n     * @type {PointerEvent}\n     * @private\n     */\n    this.originalPointerMoveEvent_;\n\n    /**\n     * @type {?import(\"./events.js\").EventsKey}\n     * @private\n     */\n    this.relayedListenerKey_ = listen(\n      element,\n      PointerEventType.POINTERMOVE,\n      this.relayMoveEvent_,\n      this\n    );\n\n    /**\n     * @private\n     */\n    this.boundHandleTouchMove_ = this.handleTouchMove_.bind(this);\n\n    this.element_.addEventListener(\n      EventType.TOUCHMOVE,\n      this.boundHandleTouchMove_,\n      PASSIVE_EVENT_LISTENERS ? {passive: false} : false\n    );\n  }\n\n  /**\n   * @param {PointerEvent} pointerEvent Pointer\n   * event.\n   * @private\n   */\n  emulateClick_(pointerEvent) {\n    let newEvent = new MapBrowserEvent(\n      MapBrowserEventType.CLICK,\n      this.map_,\n      pointerEvent\n    );\n    this.dispatchEvent(newEvent);\n    if (this.clickTimeoutId_ !== undefined) {\n      // double-click\n      clearTimeout(this.clickTimeoutId_);\n      this.clickTimeoutId_ = undefined;\n      newEvent = new MapBrowserEvent(\n        MapBrowserEventType.DBLCLICK,\n        this.map_,\n        pointerEvent\n      );\n      this.dispatchEvent(newEvent);\n    } else {\n      // click\n      this.clickTimeoutId_ = setTimeout(() => {\n        this.clickTimeoutId_ = undefined;\n        const newEvent = new MapBrowserEvent(\n          MapBrowserEventType.SINGLECLICK,\n          this.map_,\n          pointerEvent\n        );\n        this.dispatchEvent(newEvent);\n      }, 250);\n    }\n  }\n\n  /**\n   * Keeps track on how many pointers are currently active.\n   *\n   * @param {PointerEvent} pointerEvent Pointer\n   * event.\n   * @private\n   */\n  updateActivePointers_(pointerEvent) {\n    const event = pointerEvent;\n    const id = event.pointerId;\n\n    if (\n      event.type == MapBrowserEventType.POINTERUP ||\n      event.type == MapBrowserEventType.POINTERCANCEL\n    ) {\n      delete this.trackedTouches_[id];\n      for (const pointerId in this.trackedTouches_) {\n        if (this.trackedTouches_[pointerId].target !== event.target) {\n          // Some platforms assign a new pointerId when the target changes.\n          // If this happens, delete one tracked pointer. If there is more\n          // than one tracked pointer for the old target, it will be cleared\n          // by subsequent POINTERUP events from other pointers.\n          delete this.trackedTouches_[pointerId];\n          break;\n        }\n      }\n    } else if (\n      event.type == MapBrowserEventType.POINTERDOWN ||\n      event.type == MapBrowserEventType.POINTERMOVE\n    ) {\n      this.trackedTouches_[id] = event;\n    }\n    this.activePointers_ = Object.values(this.trackedTouches_);\n  }\n\n  /**\n   * @param {PointerEvent} pointerEvent Pointer\n   * event.\n   * @private\n   */\n  handlePointerUp_(pointerEvent) {\n    this.updateActivePointers_(pointerEvent);\n    const newEvent = new MapBrowserEvent(\n      MapBrowserEventType.POINTERUP,\n      this.map_,\n      pointerEvent,\n      undefined,\n      undefined,\n      this.activePointers_\n    );\n    this.dispatchEvent(newEvent);\n\n    // We emulate click events on left mouse button click, touch contact, and pen\n    // contact. isMouseActionButton returns true in these cases (evt.button is set\n    // to 0).\n    // See http://www.w3.org/TR/pointerevents/#button-states\n    // We only fire click, singleclick, and doubleclick if nobody has called\n    // event.preventDefault().\n    if (\n      this.emulateClicks_ &&\n      !newEvent.defaultPrevented &&\n      !this.dragging_ &&\n      this.isMouseActionButton_(pointerEvent)\n    ) {\n      this.emulateClick_(this.down_);\n    }\n\n    if (this.activePointers_.length === 0) {\n      this.dragListenerKeys_.forEach(unlistenByKey);\n      this.dragListenerKeys_.length = 0;\n      this.dragging_ = false;\n      this.down_ = null;\n    }\n  }\n\n  /**\n   * @param {PointerEvent} pointerEvent Pointer\n   * event.\n   * @return {boolean} If the left mouse button was pressed.\n   * @private\n   */\n  isMouseActionButton_(pointerEvent) {\n    return pointerEvent.button === 0;\n  }\n\n  /**\n   * @param {PointerEvent} pointerEvent Pointer\n   * event.\n   * @private\n   */\n  handlePointerDown_(pointerEvent) {\n    this.emulateClicks_ = this.activePointers_.length === 0;\n    this.updateActivePointers_(pointerEvent);\n    const newEvent = new MapBrowserEvent(\n      MapBrowserEventType.POINTERDOWN,\n      this.map_,\n      pointerEvent,\n      undefined,\n      undefined,\n      this.activePointers_\n    );\n    this.dispatchEvent(newEvent);\n\n    this.down_ = new PointerEvent(pointerEvent.type, pointerEvent);\n    Object.defineProperty(this.down_, 'target', {\n      writable: false,\n      value: pointerEvent.target,\n    });\n\n    if (this.dragListenerKeys_.length === 0) {\n      const doc = this.map_.getOwnerDocument();\n      this.dragListenerKeys_.push(\n        listen(\n          doc,\n          MapBrowserEventType.POINTERMOVE,\n          this.handlePointerMove_,\n          this\n        ),\n        listen(doc, MapBrowserEventType.POINTERUP, this.handlePointerUp_, this),\n        /* Note that the listener for `pointercancel is set up on\n         * `pointerEventHandler_` and not `documentPointerEventHandler_` like\n         * the `pointerup` and `pointermove` listeners.\n         *\n         * The reason for this is the following: `TouchSource.vacuumTouches_()`\n         * issues `pointercancel` events, when there was no `touchend` for a\n         * `touchstart`. Now, let's say a first `touchstart` is registered on\n         * `pointerEventHandler_`. The `documentPointerEventHandler_` is set up.\n         * But `documentPointerEventHandler_` doesn't know about the first\n         * `touchstart`. If there is no `touchend` for the `touchstart`, we can\n         * only receive a `touchcancel` from `pointerEventHandler_`, because it is\n         * only registered there.\n         */\n        listen(\n          this.element_,\n          MapBrowserEventType.POINTERCANCEL,\n          this.handlePointerUp_,\n          this\n        )\n      );\n      if (this.element_.getRootNode && this.element_.getRootNode() !== doc) {\n        this.dragListenerKeys_.push(\n          listen(\n            this.element_.getRootNode(),\n            MapBrowserEventType.POINTERUP,\n            this.handlePointerUp_,\n            this\n          )\n        );\n      }\n    }\n  }\n\n  /**\n   * @param {PointerEvent} pointerEvent Pointer\n   * event.\n   * @private\n   */\n  handlePointerMove_(pointerEvent) {\n    // Between pointerdown and pointerup, pointermove events are triggered.\n    // To avoid a 'false' touchmove event to be dispatched, we test if the pointer\n    // moved a significant distance.\n    if (this.isMoving_(pointerEvent)) {\n      this.updateActivePointers_(pointerEvent);\n      this.dragging_ = true;\n      const newEvent = new MapBrowserEvent(\n        MapBrowserEventType.POINTERDRAG,\n        this.map_,\n        pointerEvent,\n        this.dragging_,\n        undefined,\n        this.activePointers_\n      );\n      this.dispatchEvent(newEvent);\n    }\n  }\n\n  /**\n   * Wrap and relay a pointermove event.\n   * @param {PointerEvent} pointerEvent Pointer\n   * event.\n   * @private\n   */\n  relayMoveEvent_(pointerEvent) {\n    this.originalPointerMoveEvent_ = pointerEvent;\n    const dragging = !!(this.down_ && this.isMoving_(pointerEvent));\n    this.dispatchEvent(\n      new MapBrowserEvent(\n        MapBrowserEventType.POINTERMOVE,\n        this.map_,\n        pointerEvent,\n        dragging\n      )\n    );\n  }\n\n  /**\n   * Flexible handling of a `touch-action: none` css equivalent: because calling\n   * `preventDefault()` on a `pointermove` event does not stop native page scrolling\n   * and zooming, we also listen for `touchmove` and call `preventDefault()` on it\n   * when an interaction (currently `DragPan` handles the event.\n   * @param {TouchEvent} event Event.\n   * @private\n   */\n  handleTouchMove_(event) {\n    // Due to https://github.com/mpizenberg/elm-pep/issues/2, `this.originalPointerMoveEvent_`\n    // may not be initialized yet when we get here on a platform without native pointer events.\n    const originalEvent = this.originalPointerMoveEvent_;\n    if (\n      (!originalEvent || originalEvent.defaultPrevented) &&\n      (typeof event.cancelable !== 'boolean' || event.cancelable === true)\n    ) {\n      event.preventDefault();\n    }\n  }\n\n  /**\n   * @param {PointerEvent} pointerEvent Pointer\n   * event.\n   * @return {boolean} Is moving.\n   * @private\n   */\n  isMoving_(pointerEvent) {\n    return (\n      this.dragging_ ||\n      Math.abs(pointerEvent.clientX - this.down_.clientX) >\n        this.moveTolerance_ ||\n      Math.abs(pointerEvent.clientY - this.down_.clientY) > this.moveTolerance_\n    );\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    if (this.relayedListenerKey_) {\n      unlistenByKey(this.relayedListenerKey_);\n      this.relayedListenerKey_ = null;\n    }\n    this.element_.removeEventListener(\n      EventType.TOUCHMOVE,\n      this.boundHandleTouchMove_\n    );\n\n    if (this.pointerdownListenerKey_) {\n      unlistenByKey(this.pointerdownListenerKey_);\n      this.pointerdownListenerKey_ = null;\n    }\n\n    this.dragListenerKeys_.forEach(unlistenByKey);\n    this.dragListenerKeys_.length = 0;\n\n    this.element_ = null;\n    super.disposeInternal();\n  }\n}\n\nexport default MapBrowserEventHandler;\n"],"mappings":";;;;;;;AAAA;AACA;AACA;;AAEA,OAAOA,SAAS,MAAM,uBAAuB;AAC7C,OAAOC,eAAe,MAAM,sBAAsB;AAClD,OAAOC,mBAAmB,MAAM,0BAA0B;AAC1D,OAAOC,gBAAgB,MAAM,wBAAwB;AACrD,OAAOC,MAAM,MAAM,oBAAoB;AACvC,SAAQC,uBAAuB,QAAO,UAAU;AAChD,SAAQC,MAAM,EAAEC,aAAa,QAAO,aAAa;AAAC,IAE5CC,sBAAsB,0BAAAC,OAAA;EAAAC,SAAA,CAAAF,sBAAA,EAAAC,OAAA;EAAA,IAAAE,MAAA,GAAAC,YAAA,CAAAJ,sBAAA;EAC1B;AACF;AACA;AACA;EACE,SAAAA,uBAAYK,GAAG,EAAEC,aAAa,EAAE;IAAA,IAAAC,KAAA;IAAAC,eAAA,OAAAR,sBAAA;IAC9BO,KAAA,GAAAJ,MAAA,CAAAM,IAAA,OAAMJ,GAAG;;IAET;AACJ;AACA;AACA;AACA;IACIE,KAAA,CAAKG,IAAI,GAAGL,GAAG;;IAEf;AACJ;AACA;AACA;IACIE,KAAA,CAAKI,eAAe;;IAEpB;AACJ;AACA;AACA;IACIJ,KAAA,CAAKK,cAAc,GAAG,KAAK;;IAE3B;AACJ;AACA;AACA;IACIL,KAAA,CAAKM,SAAS,GAAG,KAAK;;IAEtB;AACJ;AACA;AACA;IACIN,KAAA,CAAKO,iBAAiB,GAAG,EAAE;;IAE3B;AACJ;AACA;AACA;IACIP,KAAA,CAAKQ,cAAc,GAAGT,aAAa,KAAKU,SAAS,GAAG,CAAC,GAAGV,aAAa;;IAErE;AACJ;AACA;AACA;AACA;AACA;IACIC,KAAA,CAAKU,KAAK,GAAG,IAAI;IAEjB,IAAMC,OAAO,GAAGX,KAAA,CAAKG,IAAI,CAACS,WAAW,EAAE;;IAEvC;AACJ;AACA;AACA;IACIZ,KAAA,CAAKa,eAAe,GAAG,EAAE;;IAEzB;AACJ;AACA;AACA;IACIb,KAAA,CAAKc,eAAe,GAAG,CAAC,CAAC;IAEzBd,KAAA,CAAKe,QAAQ,GAAGJ,OAAO;;IAEvB;AACJ;AACA;AACA;IACIX,KAAA,CAAKgB,uBAAuB,GAAGzB,MAAM,CACnCoB,OAAO,EACPvB,gBAAgB,CAAC6B,WAAW,EAC5BjB,KAAA,CAAKkB,kBAAkB,EAAAC,sBAAA,CAAAnB,KAAA,EAExB;;IAED;AACJ;AACA;AACA;IACIA,KAAA,CAAKoB,yBAAyB;;IAE9B;AACJ;AACA;AACA;IACIpB,KAAA,CAAKqB,mBAAmB,GAAG9B,MAAM,CAC/BoB,OAAO,EACPvB,gBAAgB,CAACkC,WAAW,EAC5BtB,KAAA,CAAKuB,eAAe,EAAAJ,sBAAA,CAAAnB,KAAA,EAErB;;IAED;AACJ;AACA;IACIA,KAAA,CAAKwB,qBAAqB,GAAGxB,KAAA,CAAKyB,gBAAgB,CAACC,IAAI,CAAAP,sBAAA,CAAAnB,KAAA,EAAM;IAE7DA,KAAA,CAAKe,QAAQ,CAACY,gBAAgB,CAC5B1C,SAAS,CAAC2C,SAAS,EACnB5B,KAAA,CAAKwB,qBAAqB,EAC1BlC,uBAAuB,GAAG;MAACuC,OAAO,EAAE;IAAK,CAAC,GAAG,KAAK,CACnD;IAAC,OAAA7B,KAAA;EACJ;;EAEA;AACF;AACA;AACA;AACA;EAJE8B,YAAA,CAAArC,sBAAA;IAAAsC,GAAA;IAAAC,KAAA,EAKA,SAAAC,cAAcC,YAAY,EAAE;MAAA,IAAAC,MAAA;MAC1B,IAAIC,QAAQ,GAAG,IAAIlD,eAAe,CAChCC,mBAAmB,CAACkD,KAAK,EACzB,IAAI,CAAClC,IAAI,EACT+B,YAAY,CACb;MACD,IAAI,CAACI,aAAa,CAACF,QAAQ,CAAC;MAC5B,IAAI,IAAI,CAAChC,eAAe,KAAKK,SAAS,EAAE;QACtC;QACA8B,YAAY,CAAC,IAAI,CAACnC,eAAe,CAAC;QAClC,IAAI,CAACA,eAAe,GAAGK,SAAS;QAChC2B,QAAQ,GAAG,IAAIlD,eAAe,CAC5BC,mBAAmB,CAACqD,QAAQ,EAC5B,IAAI,CAACrC,IAAI,EACT+B,YAAY,CACb;QACD,IAAI,CAACI,aAAa,CAACF,QAAQ,CAAC;MAC9B,CAAC,MAAM;QACL;QACA,IAAI,CAAChC,eAAe,GAAGqC,UAAU,CAAC,YAAM;UACtCN,MAAI,CAAC/B,eAAe,GAAGK,SAAS;UAChC,IAAM2B,QAAQ,GAAG,IAAIlD,eAAe,CAClCC,mBAAmB,CAACuD,WAAW,EAC/BP,MAAI,CAAChC,IAAI,EACT+B,YAAY,CACb;UACDC,MAAI,CAACG,aAAa,CAACF,QAAQ,CAAC;QAC9B,CAAC,EAAE,GAAG,CAAC;MACT;IACF;;IAEA;AACF;AACA;AACA;AACA;AACA;AACA;EANE;IAAAL,GAAA;IAAAC,KAAA,EAOA,SAAAW,sBAAsBT,YAAY,EAAE;MAClC,IAAMU,KAAK,GAAGV,YAAY;MAC1B,IAAMW,EAAE,GAAGD,KAAK,CAACE,SAAS;MAE1B,IACEF,KAAK,CAACG,IAAI,IAAI5D,mBAAmB,CAAC6D,SAAS,IAC3CJ,KAAK,CAACG,IAAI,IAAI5D,mBAAmB,CAAC8D,aAAa,EAC/C;QACA,OAAO,IAAI,CAACnC,eAAe,CAAC+B,EAAE,CAAC;QAC/B,KAAK,IAAMC,SAAS,IAAI,IAAI,CAAChC,eAAe,EAAE;UAC5C,IAAI,IAAI,CAACA,eAAe,CAACgC,SAAS,CAAC,CAACI,MAAM,KAAKN,KAAK,CAACM,MAAM,EAAE;YAC3D;YACA;YACA;YACA;YACA,OAAO,IAAI,CAACpC,eAAe,CAACgC,SAAS,CAAC;YACtC;UACF;QACF;MACF,CAAC,MAAM,IACLF,KAAK,CAACG,IAAI,IAAI5D,mBAAmB,CAAC8B,WAAW,IAC7C2B,KAAK,CAACG,IAAI,IAAI5D,mBAAmB,CAACmC,WAAW,EAC7C;QACA,IAAI,CAACR,eAAe,CAAC+B,EAAE,CAAC,GAAGD,KAAK;MAClC;MACA,IAAI,CAAC/B,eAAe,GAAGsC,MAAM,CAACC,MAAM,CAAC,IAAI,CAACtC,eAAe,CAAC;IAC5D;;IAEA;AACF;AACA;AACA;AACA;EAJE;IAAAiB,GAAA;IAAAC,KAAA,EAKA,SAAAqB,iBAAiBnB,YAAY,EAAE;MAC7B,IAAI,CAACS,qBAAqB,CAACT,YAAY,CAAC;MACxC,IAAME,QAAQ,GAAG,IAAIlD,eAAe,CAClCC,mBAAmB,CAAC6D,SAAS,EAC7B,IAAI,CAAC7C,IAAI,EACT+B,YAAY,EACZzB,SAAS,EACTA,SAAS,EACT,IAAI,CAACI,eAAe,CACrB;MACD,IAAI,CAACyB,aAAa,CAACF,QAAQ,CAAC;;MAE5B;MACA;MACA;MACA;MACA;MACA;MACA,IACE,IAAI,CAAC/B,cAAc,IACnB,CAAC+B,QAAQ,CAACkB,gBAAgB,IAC1B,CAAC,IAAI,CAAChD,SAAS,IACf,IAAI,CAACiD,oBAAoB,CAACrB,YAAY,CAAC,EACvC;QACA,IAAI,CAACD,aAAa,CAAC,IAAI,CAACvB,KAAK,CAAC;MAChC;MAEA,IAAI,IAAI,CAACG,eAAe,CAAC2C,MAAM,KAAK,CAAC,EAAE;QACrC,IAAI,CAACjD,iBAAiB,CAACkD,OAAO,CAACjE,aAAa,CAAC;QAC7C,IAAI,CAACe,iBAAiB,CAACiD,MAAM,GAAG,CAAC;QACjC,IAAI,CAAClD,SAAS,GAAG,KAAK;QACtB,IAAI,CAACI,KAAK,GAAG,IAAI;MACnB;IACF;;IAEA;AACF;AACA;AACA;AACA;AACA;EALE;IAAAqB,GAAA;IAAAC,KAAA,EAMA,SAAAuB,qBAAqBrB,YAAY,EAAE;MACjC,OAAOA,YAAY,CAACwB,MAAM,KAAK,CAAC;IAClC;;IAEA;AACF;AACA;AACA;AACA;EAJE;IAAA3B,GAAA;IAAAC,KAAA,EAKA,SAAAd,mBAAmBgB,YAAY,EAAE;MAC/B,IAAI,CAAC7B,cAAc,GAAG,IAAI,CAACQ,eAAe,CAAC2C,MAAM,KAAK,CAAC;MACvD,IAAI,CAACb,qBAAqB,CAACT,YAAY,CAAC;MACxC,IAAME,QAAQ,GAAG,IAAIlD,eAAe,CAClCC,mBAAmB,CAAC8B,WAAW,EAC/B,IAAI,CAACd,IAAI,EACT+B,YAAY,EACZzB,SAAS,EACTA,SAAS,EACT,IAAI,CAACI,eAAe,CACrB;MACD,IAAI,CAACyB,aAAa,CAACF,QAAQ,CAAC;MAE5B,IAAI,CAAC1B,KAAK,GAAG,IAAIiD,YAAY,CAACzB,YAAY,CAACa,IAAI,EAAEb,YAAY,CAAC;MAC9DiB,MAAM,CAACS,cAAc,CAAC,IAAI,CAAClD,KAAK,EAAE,QAAQ,EAAE;QAC1CmD,QAAQ,EAAE,KAAK;QACf7B,KAAK,EAAEE,YAAY,CAACgB;MACtB,CAAC,CAAC;MAEF,IAAI,IAAI,CAAC3C,iBAAiB,CAACiD,MAAM,KAAK,CAAC,EAAE;QACvC,IAAMM,GAAG,GAAG,IAAI,CAAC3D,IAAI,CAAC4D,gBAAgB,EAAE;QACxC,IAAI,CAACxD,iBAAiB,CAACyD,IAAI,CACzBzE,MAAM,CACJuE,GAAG,EACH3E,mBAAmB,CAACmC,WAAW,EAC/B,IAAI,CAAC2C,kBAAkB,EACvB,IAAI,CACL,EACD1E,MAAM,CAACuE,GAAG,EAAE3E,mBAAmB,CAAC6D,SAAS,EAAE,IAAI,CAACK,gBAAgB,EAAE,IAAI,CAAC;QACvE;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;QACQ9D,MAAM,CACJ,IAAI,CAACwB,QAAQ,EACb5B,mBAAmB,CAAC8D,aAAa,EACjC,IAAI,CAACI,gBAAgB,EACrB,IAAI,CACL,CACF;QACD,IAAI,IAAI,CAACtC,QAAQ,CAACmD,WAAW,IAAI,IAAI,CAACnD,QAAQ,CAACmD,WAAW,EAAE,KAAKJ,GAAG,EAAE;UACpE,IAAI,CAACvD,iBAAiB,CAACyD,IAAI,CACzBzE,MAAM,CACJ,IAAI,CAACwB,QAAQ,CAACmD,WAAW,EAAE,EAC3B/E,mBAAmB,CAAC6D,SAAS,EAC7B,IAAI,CAACK,gBAAgB,EACrB,IAAI,CACL,CACF;QACH;MACF;IACF;;IAEA;AACF;AACA;AACA;AACA;EAJE;IAAAtB,GAAA;IAAAC,KAAA,EAKA,SAAAiC,mBAAmB/B,YAAY,EAAE;MAC/B;MACA;MACA;MACA,IAAI,IAAI,CAACiC,SAAS,CAACjC,YAAY,CAAC,EAAE;QAChC,IAAI,CAACS,qBAAqB,CAACT,YAAY,CAAC;QACxC,IAAI,CAAC5B,SAAS,GAAG,IAAI;QACrB,IAAM8B,QAAQ,GAAG,IAAIlD,eAAe,CAClCC,mBAAmB,CAACiF,WAAW,EAC/B,IAAI,CAACjE,IAAI,EACT+B,YAAY,EACZ,IAAI,CAAC5B,SAAS,EACdG,SAAS,EACT,IAAI,CAACI,eAAe,CACrB;QACD,IAAI,CAACyB,aAAa,CAACF,QAAQ,CAAC;MAC9B;IACF;;IAEA;AACF;AACA;AACA;AACA;AACA;EALE;IAAAL,GAAA;IAAAC,KAAA,EAMA,SAAAT,gBAAgBW,YAAY,EAAE;MAC5B,IAAI,CAACd,yBAAyB,GAAGc,YAAY;MAC7C,IAAMmC,QAAQ,GAAG,CAAC,EAAE,IAAI,CAAC3D,KAAK,IAAI,IAAI,CAACyD,SAAS,CAACjC,YAAY,CAAC,CAAC;MAC/D,IAAI,CAACI,aAAa,CAChB,IAAIpD,eAAe,CACjBC,mBAAmB,CAACmC,WAAW,EAC/B,IAAI,CAACnB,IAAI,EACT+B,YAAY,EACZmC,QAAQ,CACT,CACF;IACH;;IAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EAPE;IAAAtC,GAAA;IAAAC,KAAA,EAQA,SAAAP,iBAAiBmB,KAAK,EAAE;MACtB;MACA;MACA,IAAM0B,aAAa,GAAG,IAAI,CAAClD,yBAAyB;MACpD,IACE,CAAC,CAACkD,aAAa,IAAIA,aAAa,CAAChB,gBAAgB,MAChD,OAAOV,KAAK,CAAC2B,UAAU,KAAK,SAAS,IAAI3B,KAAK,CAAC2B,UAAU,KAAK,IAAI,CAAC,EACpE;QACA3B,KAAK,CAAC4B,cAAc,EAAE;MACxB;IACF;;IAEA;AACF;AACA;AACA;AACA;AACA;EALE;IAAAzC,GAAA;IAAAC,KAAA,EAMA,SAAAmC,UAAUjC,YAAY,EAAE;MACtB,OACE,IAAI,CAAC5B,SAAS,IACdmE,IAAI,CAACC,GAAG,CAACxC,YAAY,CAACyC,OAAO,GAAG,IAAI,CAACjE,KAAK,CAACiE,OAAO,CAAC,GACjD,IAAI,CAACnE,cAAc,IACrBiE,IAAI,CAACC,GAAG,CAACxC,YAAY,CAAC0C,OAAO,GAAG,IAAI,CAAClE,KAAK,CAACkE,OAAO,CAAC,GAAG,IAAI,CAACpE,cAAc;IAE7E;;IAEA;AACF;AACA;EAFE;IAAAuB,GAAA;IAAAC,KAAA,EAGA,SAAA6C,gBAAA,EAAkB;MAChB,IAAI,IAAI,CAACxD,mBAAmB,EAAE;QAC5B7B,aAAa,CAAC,IAAI,CAAC6B,mBAAmB,CAAC;QACvC,IAAI,CAACA,mBAAmB,GAAG,IAAI;MACjC;MACA,IAAI,CAACN,QAAQ,CAAC+D,mBAAmB,CAC/B7F,SAAS,CAAC2C,SAAS,EACnB,IAAI,CAACJ,qBAAqB,CAC3B;MAED,IAAI,IAAI,CAACR,uBAAuB,EAAE;QAChCxB,aAAa,CAAC,IAAI,CAACwB,uBAAuB,CAAC;QAC3C,IAAI,CAACA,uBAAuB,GAAG,IAAI;MACrC;MAEA,IAAI,CAACT,iBAAiB,CAACkD,OAAO,CAACjE,aAAa,CAAC;MAC7C,IAAI,CAACe,iBAAiB,CAACiD,MAAM,GAAG,CAAC;MAEjC,IAAI,CAACzC,QAAQ,GAAG,IAAI;MACpBgE,IAAA,CAAAC,eAAA,CAAAvF,sBAAA,CAAAwF,SAAA,4BAAA/E,IAAA;IACF;EAAC;EAAA,OAAAT,sBAAA;AAAA,EA9YkCJ,MAAM;AAiZ3C,eAAeI,sBAAsB"},"metadata":{},"sourceType":"module","externalDependencies":[]}