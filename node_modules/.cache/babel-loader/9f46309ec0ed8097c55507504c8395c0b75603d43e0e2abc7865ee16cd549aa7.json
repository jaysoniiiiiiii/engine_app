{"ast":null,"code":"import _classCallCheck from \"/home/jay/Downloads/major/my-app/gis/web-gis/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/jay/Downloads/major/my-app/gis/web-gis/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n/**\n * @module ol/reproj/Triangulation\n */\nimport { boundingExtent, createEmpty, extendCoordinate, getArea, getBottomLeft, getBottomRight, getTopLeft, getTopRight, getWidth, intersects } from '../extent.js';\nimport { getTransform } from '../proj.js';\nimport { modulo } from '../math.js';\n\n/**\n * Single triangle; consists of 3 source points and 3 target points.\n * @typedef {Object} Triangle\n * @property {Array<import(\"../coordinate.js\").Coordinate>} source Source.\n * @property {Array<import(\"../coordinate.js\").Coordinate>} target Target.\n */\n\n/**\n * Maximum number of subdivision steps during raster reprojection triangulation.\n * Prevents high memory usage and large number of proj4 calls (for certain\n * transformations and areas). At most `2*(2^this)` triangles are created for\n * each triangulated extent (tile/image).\n * @type {number}\n */\nvar MAX_SUBDIVISION = 10;\n\n/**\n * Maximum allowed size of triangle relative to world width. When transforming\n * corners of world extent between certain projections, the resulting\n * triangulation seems to have zero error and no subdivision is performed. If\n * the triangle width is more than this (relative to world width; 0-1),\n * subdivison is forced (up to `MAX_SUBDIVISION`). Default is `0.25`.\n * @type {number}\n */\nvar MAX_TRIANGLE_WIDTH = 0.25;\n\n/**\n * @classdesc\n * Class containing triangulation of the given target extent.\n * Used for determining source data and the reprojection itself.\n */\nvar Triangulation = /*#__PURE__*/function () {\n  /**\n   * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection.\n   * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\n   * @param {import(\"../extent.js\").Extent} targetExtent Target extent to triangulate.\n   * @param {import(\"../extent.js\").Extent} maxSourceExtent Maximal source extent that can be used.\n   * @param {number} errorThreshold Acceptable error (in source units).\n   * @param {?number} destinationResolution The (optional) resolution of the destination.\n   */\n  function Triangulation(sourceProj, targetProj, targetExtent, maxSourceExtent, errorThreshold, destinationResolution) {\n    var _this = this;\n    _classCallCheck(this, Triangulation);\n    /**\n     * @type {import(\"../proj/Projection.js\").default}\n     * @private\n     */\n    this.sourceProj_ = sourceProj;\n\n    /**\n     * @type {import(\"../proj/Projection.js\").default}\n     * @private\n     */\n    this.targetProj_ = targetProj;\n\n    /** @type {!Object<string, import(\"../coordinate.js\").Coordinate>} */\n    var transformInvCache = {};\n    var transformInv = getTransform(this.targetProj_, this.sourceProj_);\n\n    /**\n     * @param {import(\"../coordinate.js\").Coordinate} c A coordinate.\n     * @return {import(\"../coordinate.js\").Coordinate} Transformed coordinate.\n     * @private\n     */\n    this.transformInv_ = function (c) {\n      var key = c[0] + '/' + c[1];\n      if (!transformInvCache[key]) {\n        transformInvCache[key] = transformInv(c);\n      }\n      return transformInvCache[key];\n    };\n\n    /**\n     * @type {import(\"../extent.js\").Extent}\n     * @private\n     */\n    this.maxSourceExtent_ = maxSourceExtent;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.errorThresholdSquared_ = errorThreshold * errorThreshold;\n\n    /**\n     * @type {Array<Triangle>}\n     * @private\n     */\n    this.triangles_ = [];\n\n    /**\n     * Indicates that the triangulation crosses edge of the source projection.\n     * @type {boolean}\n     * @private\n     */\n    this.wrapsXInSource_ = false;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.canWrapXInSource_ = this.sourceProj_.canWrapX() && !!maxSourceExtent && !!this.sourceProj_.getExtent() && getWidth(maxSourceExtent) == getWidth(this.sourceProj_.getExtent());\n\n    /**\n     * @type {?number}\n     * @private\n     */\n    this.sourceWorldWidth_ = this.sourceProj_.getExtent() ? getWidth(this.sourceProj_.getExtent()) : null;\n\n    /**\n     * @type {?number}\n     * @private\n     */\n    this.targetWorldWidth_ = this.targetProj_.getExtent() ? getWidth(this.targetProj_.getExtent()) : null;\n    var destinationTopLeft = getTopLeft(targetExtent);\n    var destinationTopRight = getTopRight(targetExtent);\n    var destinationBottomRight = getBottomRight(targetExtent);\n    var destinationBottomLeft = getBottomLeft(targetExtent);\n    var sourceTopLeft = this.transformInv_(destinationTopLeft);\n    var sourceTopRight = this.transformInv_(destinationTopRight);\n    var sourceBottomRight = this.transformInv_(destinationBottomRight);\n    var sourceBottomLeft = this.transformInv_(destinationBottomLeft);\n\n    /*\n     * The maxSubdivision controls how many splittings of the target area can\n     * be done. The idea here is to do a linear mapping of the target areas\n     * but the actual overal reprojection (can be) extremely non-linear. The\n     * default value of MAX_SUBDIVISION was chosen based on mapping a 256x256\n     * tile size. However this function is also called to remap canvas rendered\n     * layers which can be much larger. This calculation increases the maxSubdivision\n     * value by the right factor so that each 256x256 pixel area has\n     * MAX_SUBDIVISION divisions.\n     */\n    var maxSubdivision = MAX_SUBDIVISION + (destinationResolution ? Math.max(0, Math.ceil(Math.log2(getArea(targetExtent) / (destinationResolution * destinationResolution * 256 * 256)))) : 0);\n    this.addQuad_(destinationTopLeft, destinationTopRight, destinationBottomRight, destinationBottomLeft, sourceTopLeft, sourceTopRight, sourceBottomRight, sourceBottomLeft, maxSubdivision);\n    if (this.wrapsXInSource_) {\n      var leftBound = Infinity;\n      this.triangles_.forEach(function (triangle, i, arr) {\n        leftBound = Math.min(leftBound, triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]);\n      });\n\n      // Shift triangles to be as close to `leftBound` as possible\n      // (if the distance is more than `worldWidth / 2` it can be closer.\n      this.triangles_.forEach(function (triangle) {\n        if (Math.max(triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]) - leftBound > _this.sourceWorldWidth_ / 2) {\n          var newTriangle = [[triangle.source[0][0], triangle.source[0][1]], [triangle.source[1][0], triangle.source[1][1]], [triangle.source[2][0], triangle.source[2][1]]];\n          if (newTriangle[0][0] - leftBound > _this.sourceWorldWidth_ / 2) {\n            newTriangle[0][0] -= _this.sourceWorldWidth_;\n          }\n          if (newTriangle[1][0] - leftBound > _this.sourceWorldWidth_ / 2) {\n            newTriangle[1][0] -= _this.sourceWorldWidth_;\n          }\n          if (newTriangle[2][0] - leftBound > _this.sourceWorldWidth_ / 2) {\n            newTriangle[2][0] -= _this.sourceWorldWidth_;\n          }\n\n          // Rarely (if the extent contains both the dateline and prime meridian)\n          // the shift can in turn break some triangles.\n          // Detect this here and don't shift in such cases.\n          var minX = Math.min(newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);\n          var maxX = Math.max(newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);\n          if (maxX - minX < _this.sourceWorldWidth_ / 2) {\n            triangle.source = newTriangle;\n          }\n        }\n      });\n    }\n    transformInvCache = {};\n  }\n\n  /**\n   * Adds triangle to the triangulation.\n   * @param {import(\"../coordinate.js\").Coordinate} a The target a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} b The target b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} c The target c coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} aSrc The source a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} bSrc The source b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} cSrc The source c coordinate.\n   * @private\n   */\n  _createClass(Triangulation, [{\n    key: \"addTriangle_\",\n    value: function addTriangle_(a, b, c, aSrc, bSrc, cSrc) {\n      this.triangles_.push({\n        source: [aSrc, bSrc, cSrc],\n        target: [a, b, c]\n      });\n    }\n\n    /**\n     * Adds quad (points in clock-wise order) to the triangulation\n     * (and reprojects the vertices) if valid.\n     * Performs quad subdivision if needed to increase precision.\n     *\n     * @param {import(\"../coordinate.js\").Coordinate} a The target a coordinate.\n     * @param {import(\"../coordinate.js\").Coordinate} b The target b coordinate.\n     * @param {import(\"../coordinate.js\").Coordinate} c The target c coordinate.\n     * @param {import(\"../coordinate.js\").Coordinate} d The target d coordinate.\n     * @param {import(\"../coordinate.js\").Coordinate} aSrc The source a coordinate.\n     * @param {import(\"../coordinate.js\").Coordinate} bSrc The source b coordinate.\n     * @param {import(\"../coordinate.js\").Coordinate} cSrc The source c coordinate.\n     * @param {import(\"../coordinate.js\").Coordinate} dSrc The source d coordinate.\n     * @param {number} maxSubdivision Maximal allowed subdivision of the quad.\n     * @private\n     */\n  }, {\n    key: \"addQuad_\",\n    value: function addQuad_(a, b, c, d, aSrc, bSrc, cSrc, dSrc, maxSubdivision) {\n      var sourceQuadExtent = boundingExtent([aSrc, bSrc, cSrc, dSrc]);\n      var sourceCoverageX = this.sourceWorldWidth_ ? getWidth(sourceQuadExtent) / this.sourceWorldWidth_ : null;\n      var sourceWorldWidth = /** @type {number} */this.sourceWorldWidth_;\n\n      // when the quad is wrapped in the source projection\n      // it covers most of the projection extent, but not fully\n      var wrapsX = this.sourceProj_.canWrapX() && sourceCoverageX > 0.5 && sourceCoverageX < 1;\n      var needsSubdivision = false;\n      if (maxSubdivision > 0) {\n        if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {\n          var targetQuadExtent = boundingExtent([a, b, c, d]);\n          var targetCoverageX = getWidth(targetQuadExtent) / this.targetWorldWidth_;\n          needsSubdivision = targetCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;\n        }\n        if (!wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX) {\n          needsSubdivision = sourceCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;\n        }\n      }\n      if (!needsSubdivision && this.maxSourceExtent_) {\n        if (isFinite(sourceQuadExtent[0]) && isFinite(sourceQuadExtent[1]) && isFinite(sourceQuadExtent[2]) && isFinite(sourceQuadExtent[3])) {\n          if (!intersects(sourceQuadExtent, this.maxSourceExtent_)) {\n            // whole quad outside source projection extent -> ignore\n            return;\n          }\n        }\n      }\n      var isNotFinite = 0;\n      if (!needsSubdivision) {\n        if (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) || !isFinite(bSrc[0]) || !isFinite(bSrc[1]) || !isFinite(cSrc[0]) || !isFinite(cSrc[1]) || !isFinite(dSrc[0]) || !isFinite(dSrc[1])) {\n          if (maxSubdivision > 0) {\n            needsSubdivision = true;\n          } else {\n            // It might be the case that only 1 of the points is infinite. In this case\n            // we can draw a single triangle with the other three points\n            isNotFinite = (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) ? 8 : 0) + (!isFinite(bSrc[0]) || !isFinite(bSrc[1]) ? 4 : 0) + (!isFinite(cSrc[0]) || !isFinite(cSrc[1]) ? 2 : 0) + (!isFinite(dSrc[0]) || !isFinite(dSrc[1]) ? 1 : 0);\n            if (isNotFinite != 1 && isNotFinite != 2 && isNotFinite != 4 && isNotFinite != 8) {\n              return;\n            }\n          }\n        }\n      }\n      if (maxSubdivision > 0) {\n        if (!needsSubdivision) {\n          var center = [(a[0] + c[0]) / 2, (a[1] + c[1]) / 2];\n          var centerSrc = this.transformInv_(center);\n          var dx;\n          if (wrapsX) {\n            var centerSrcEstimX = (modulo(aSrc[0], sourceWorldWidth) + modulo(cSrc[0], sourceWorldWidth)) / 2;\n            dx = centerSrcEstimX - modulo(centerSrc[0], sourceWorldWidth);\n          } else {\n            dx = (aSrc[0] + cSrc[0]) / 2 - centerSrc[0];\n          }\n          var dy = (aSrc[1] + cSrc[1]) / 2 - centerSrc[1];\n          var centerSrcErrorSquared = dx * dx + dy * dy;\n          needsSubdivision = centerSrcErrorSquared > this.errorThresholdSquared_;\n        }\n        if (needsSubdivision) {\n          if (Math.abs(a[0] - c[0]) <= Math.abs(a[1] - c[1])) {\n            // split horizontally (top & bottom)\n            var bc = [(b[0] + c[0]) / 2, (b[1] + c[1]) / 2];\n            var bcSrc = this.transformInv_(bc);\n            var da = [(d[0] + a[0]) / 2, (d[1] + a[1]) / 2];\n            var daSrc = this.transformInv_(da);\n            this.addQuad_(a, b, bc, da, aSrc, bSrc, bcSrc, daSrc, maxSubdivision - 1);\n            this.addQuad_(da, bc, c, d, daSrc, bcSrc, cSrc, dSrc, maxSubdivision - 1);\n          } else {\n            // split vertically (left & right)\n            var ab = [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];\n            var abSrc = this.transformInv_(ab);\n            var cd = [(c[0] + d[0]) / 2, (c[1] + d[1]) / 2];\n            var cdSrc = this.transformInv_(cd);\n            this.addQuad_(a, ab, cd, d, aSrc, abSrc, cdSrc, dSrc, maxSubdivision - 1);\n            this.addQuad_(ab, b, c, cd, abSrc, bSrc, cSrc, cdSrc, maxSubdivision - 1);\n          }\n          return;\n        }\n      }\n      if (wrapsX) {\n        if (!this.canWrapXInSource_) {\n          return;\n        }\n        this.wrapsXInSource_ = true;\n      }\n\n      // Exactly zero or one of *Src is not finite\n      // The triangles must have the diagonal line as the first side\n      // This is to allow easy code in reproj.s to make it straight for broken\n      // browsers that can't handle diagonal clipping\n      if ((isNotFinite & 0xb) == 0) {\n        this.addTriangle_(a, c, d, aSrc, cSrc, dSrc);\n      }\n      if ((isNotFinite & 0xe) == 0) {\n        this.addTriangle_(a, c, b, aSrc, cSrc, bSrc);\n      }\n      if (isNotFinite) {\n        // Try the other two triangles\n        if ((isNotFinite & 0xd) == 0) {\n          this.addTriangle_(b, d, a, bSrc, dSrc, aSrc);\n        }\n        if ((isNotFinite & 0x7) == 0) {\n          this.addTriangle_(b, d, c, bSrc, dSrc, cSrc);\n        }\n      }\n    }\n\n    /**\n     * Calculates extent of the `source` coordinates from all the triangles.\n     *\n     * @return {import(\"../extent.js\").Extent} Calculated extent.\n     */\n  }, {\n    key: \"calculateSourceExtent\",\n    value: function calculateSourceExtent() {\n      var extent = createEmpty();\n      this.triangles_.forEach(function (triangle, i, arr) {\n        var src = triangle.source;\n        extendCoordinate(extent, src[0]);\n        extendCoordinate(extent, src[1]);\n        extendCoordinate(extent, src[2]);\n      });\n      return extent;\n    }\n\n    /**\n     * @return {Array<Triangle>} Array of the calculated triangles.\n     */\n  }, {\n    key: \"getTriangles\",\n    value: function getTriangles() {\n      return this.triangles_;\n    }\n  }]);\n  return Triangulation;\n}();\nexport default Triangulation;","map":{"version":3,"names":["boundingExtent","createEmpty","extendCoordinate","getArea","getBottomLeft","getBottomRight","getTopLeft","getTopRight","getWidth","intersects","getTransform","modulo","MAX_SUBDIVISION","MAX_TRIANGLE_WIDTH","Triangulation","sourceProj","targetProj","targetExtent","maxSourceExtent","errorThreshold","destinationResolution","_this","_classCallCheck","sourceProj_","targetProj_","transformInvCache","transformInv","transformInv_","c","key","maxSourceExtent_","errorThresholdSquared_","triangles_","wrapsXInSource_","canWrapXInSource_","canWrapX","getExtent","sourceWorldWidth_","targetWorldWidth_","destinationTopLeft","destinationTopRight","destinationBottomRight","destinationBottomLeft","sourceTopLeft","sourceTopRight","sourceBottomRight","sourceBottomLeft","maxSubdivision","Math","max","ceil","log2","addQuad_","leftBound","Infinity","forEach","triangle","i","arr","min","source","newTriangle","minX","maxX","_createClass","value","addTriangle_","a","b","aSrc","bSrc","cSrc","push","target","d","dSrc","sourceQuadExtent","sourceCoverageX","sourceWorldWidth","wrapsX","needsSubdivision","isGlobal","targetQuadExtent","targetCoverageX","isFinite","isNotFinite","center","centerSrc","dx","centerSrcEstimX","dy","centerSrcErrorSquared","abs","bc","bcSrc","da","daSrc","ab","abSrc","cd","cdSrc","calculateSourceExtent","extent","src","getTriangles"],"sources":["/home/jay/Downloads/major/my-app/gis/web-gis/node_modules/ol/reproj/Triangulation.js"],"sourcesContent":["/**\n * @module ol/reproj/Triangulation\n */\nimport {\n  boundingExtent,\n  createEmpty,\n  extendCoordinate,\n  getArea,\n  getBottomLeft,\n  getBottomRight,\n  getTopLeft,\n  getTopRight,\n  getWidth,\n  intersects,\n} from '../extent.js';\nimport {getTransform} from '../proj.js';\nimport {modulo} from '../math.js';\n\n/**\n * Single triangle; consists of 3 source points and 3 target points.\n * @typedef {Object} Triangle\n * @property {Array<import(\"../coordinate.js\").Coordinate>} source Source.\n * @property {Array<import(\"../coordinate.js\").Coordinate>} target Target.\n */\n\n/**\n * Maximum number of subdivision steps during raster reprojection triangulation.\n * Prevents high memory usage and large number of proj4 calls (for certain\n * transformations and areas). At most `2*(2^this)` triangles are created for\n * each triangulated extent (tile/image).\n * @type {number}\n */\nconst MAX_SUBDIVISION = 10;\n\n/**\n * Maximum allowed size of triangle relative to world width. When transforming\n * corners of world extent between certain projections, the resulting\n * triangulation seems to have zero error and no subdivision is performed. If\n * the triangle width is more than this (relative to world width; 0-1),\n * subdivison is forced (up to `MAX_SUBDIVISION`). Default is `0.25`.\n * @type {number}\n */\nconst MAX_TRIANGLE_WIDTH = 0.25;\n\n/**\n * @classdesc\n * Class containing triangulation of the given target extent.\n * Used for determining source data and the reprojection itself.\n */\nclass Triangulation {\n  /**\n   * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection.\n   * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\n   * @param {import(\"../extent.js\").Extent} targetExtent Target extent to triangulate.\n   * @param {import(\"../extent.js\").Extent} maxSourceExtent Maximal source extent that can be used.\n   * @param {number} errorThreshold Acceptable error (in source units).\n   * @param {?number} destinationResolution The (optional) resolution of the destination.\n   */\n  constructor(\n    sourceProj,\n    targetProj,\n    targetExtent,\n    maxSourceExtent,\n    errorThreshold,\n    destinationResolution\n  ) {\n    /**\n     * @type {import(\"../proj/Projection.js\").default}\n     * @private\n     */\n    this.sourceProj_ = sourceProj;\n\n    /**\n     * @type {import(\"../proj/Projection.js\").default}\n     * @private\n     */\n    this.targetProj_ = targetProj;\n\n    /** @type {!Object<string, import(\"../coordinate.js\").Coordinate>} */\n    let transformInvCache = {};\n    const transformInv = getTransform(this.targetProj_, this.sourceProj_);\n\n    /**\n     * @param {import(\"../coordinate.js\").Coordinate} c A coordinate.\n     * @return {import(\"../coordinate.js\").Coordinate} Transformed coordinate.\n     * @private\n     */\n    this.transformInv_ = function (c) {\n      const key = c[0] + '/' + c[1];\n      if (!transformInvCache[key]) {\n        transformInvCache[key] = transformInv(c);\n      }\n      return transformInvCache[key];\n    };\n\n    /**\n     * @type {import(\"../extent.js\").Extent}\n     * @private\n     */\n    this.maxSourceExtent_ = maxSourceExtent;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.errorThresholdSquared_ = errorThreshold * errorThreshold;\n\n    /**\n     * @type {Array<Triangle>}\n     * @private\n     */\n    this.triangles_ = [];\n\n    /**\n     * Indicates that the triangulation crosses edge of the source projection.\n     * @type {boolean}\n     * @private\n     */\n    this.wrapsXInSource_ = false;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.canWrapXInSource_ =\n      this.sourceProj_.canWrapX() &&\n      !!maxSourceExtent &&\n      !!this.sourceProj_.getExtent() &&\n      getWidth(maxSourceExtent) == getWidth(this.sourceProj_.getExtent());\n\n    /**\n     * @type {?number}\n     * @private\n     */\n    this.sourceWorldWidth_ = this.sourceProj_.getExtent()\n      ? getWidth(this.sourceProj_.getExtent())\n      : null;\n\n    /**\n     * @type {?number}\n     * @private\n     */\n    this.targetWorldWidth_ = this.targetProj_.getExtent()\n      ? getWidth(this.targetProj_.getExtent())\n      : null;\n\n    const destinationTopLeft = getTopLeft(targetExtent);\n    const destinationTopRight = getTopRight(targetExtent);\n    const destinationBottomRight = getBottomRight(targetExtent);\n    const destinationBottomLeft = getBottomLeft(targetExtent);\n    const sourceTopLeft = this.transformInv_(destinationTopLeft);\n    const sourceTopRight = this.transformInv_(destinationTopRight);\n    const sourceBottomRight = this.transformInv_(destinationBottomRight);\n    const sourceBottomLeft = this.transformInv_(destinationBottomLeft);\n\n    /*\n     * The maxSubdivision controls how many splittings of the target area can\n     * be done. The idea here is to do a linear mapping of the target areas\n     * but the actual overal reprojection (can be) extremely non-linear. The\n     * default value of MAX_SUBDIVISION was chosen based on mapping a 256x256\n     * tile size. However this function is also called to remap canvas rendered\n     * layers which can be much larger. This calculation increases the maxSubdivision\n     * value by the right factor so that each 256x256 pixel area has\n     * MAX_SUBDIVISION divisions.\n     */\n    const maxSubdivision =\n      MAX_SUBDIVISION +\n      (destinationResolution\n        ? Math.max(\n            0,\n            Math.ceil(\n              Math.log2(\n                getArea(targetExtent) /\n                  (destinationResolution * destinationResolution * 256 * 256)\n              )\n            )\n          )\n        : 0);\n\n    this.addQuad_(\n      destinationTopLeft,\n      destinationTopRight,\n      destinationBottomRight,\n      destinationBottomLeft,\n      sourceTopLeft,\n      sourceTopRight,\n      sourceBottomRight,\n      sourceBottomLeft,\n      maxSubdivision\n    );\n\n    if (this.wrapsXInSource_) {\n      let leftBound = Infinity;\n      this.triangles_.forEach(function (triangle, i, arr) {\n        leftBound = Math.min(\n          leftBound,\n          triangle.source[0][0],\n          triangle.source[1][0],\n          triangle.source[2][0]\n        );\n      });\n\n      // Shift triangles to be as close to `leftBound` as possible\n      // (if the distance is more than `worldWidth / 2` it can be closer.\n      this.triangles_.forEach((triangle) => {\n        if (\n          Math.max(\n            triangle.source[0][0],\n            triangle.source[1][0],\n            triangle.source[2][0]\n          ) -\n            leftBound >\n          this.sourceWorldWidth_ / 2\n        ) {\n          const newTriangle = [\n            [triangle.source[0][0], triangle.source[0][1]],\n            [triangle.source[1][0], triangle.source[1][1]],\n            [triangle.source[2][0], triangle.source[2][1]],\n          ];\n          if (newTriangle[0][0] - leftBound > this.sourceWorldWidth_ / 2) {\n            newTriangle[0][0] -= this.sourceWorldWidth_;\n          }\n          if (newTriangle[1][0] - leftBound > this.sourceWorldWidth_ / 2) {\n            newTriangle[1][0] -= this.sourceWorldWidth_;\n          }\n          if (newTriangle[2][0] - leftBound > this.sourceWorldWidth_ / 2) {\n            newTriangle[2][0] -= this.sourceWorldWidth_;\n          }\n\n          // Rarely (if the extent contains both the dateline and prime meridian)\n          // the shift can in turn break some triangles.\n          // Detect this here and don't shift in such cases.\n          const minX = Math.min(\n            newTriangle[0][0],\n            newTriangle[1][0],\n            newTriangle[2][0]\n          );\n          const maxX = Math.max(\n            newTriangle[0][0],\n            newTriangle[1][0],\n            newTriangle[2][0]\n          );\n          if (maxX - minX < this.sourceWorldWidth_ / 2) {\n            triangle.source = newTriangle;\n          }\n        }\n      });\n    }\n\n    transformInvCache = {};\n  }\n\n  /**\n   * Adds triangle to the triangulation.\n   * @param {import(\"../coordinate.js\").Coordinate} a The target a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} b The target b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} c The target c coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} aSrc The source a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} bSrc The source b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} cSrc The source c coordinate.\n   * @private\n   */\n  addTriangle_(a, b, c, aSrc, bSrc, cSrc) {\n    this.triangles_.push({\n      source: [aSrc, bSrc, cSrc],\n      target: [a, b, c],\n    });\n  }\n\n  /**\n   * Adds quad (points in clock-wise order) to the triangulation\n   * (and reprojects the vertices) if valid.\n   * Performs quad subdivision if needed to increase precision.\n   *\n   * @param {import(\"../coordinate.js\").Coordinate} a The target a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} b The target b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} c The target c coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} d The target d coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} aSrc The source a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} bSrc The source b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} cSrc The source c coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} dSrc The source d coordinate.\n   * @param {number} maxSubdivision Maximal allowed subdivision of the quad.\n   * @private\n   */\n  addQuad_(a, b, c, d, aSrc, bSrc, cSrc, dSrc, maxSubdivision) {\n    const sourceQuadExtent = boundingExtent([aSrc, bSrc, cSrc, dSrc]);\n    const sourceCoverageX = this.sourceWorldWidth_\n      ? getWidth(sourceQuadExtent) / this.sourceWorldWidth_\n      : null;\n    const sourceWorldWidth = /** @type {number} */ (this.sourceWorldWidth_);\n\n    // when the quad is wrapped in the source projection\n    // it covers most of the projection extent, but not fully\n    const wrapsX =\n      this.sourceProj_.canWrapX() &&\n      sourceCoverageX > 0.5 &&\n      sourceCoverageX < 1;\n\n    let needsSubdivision = false;\n\n    if (maxSubdivision > 0) {\n      if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {\n        const targetQuadExtent = boundingExtent([a, b, c, d]);\n        const targetCoverageX =\n          getWidth(targetQuadExtent) / this.targetWorldWidth_;\n        needsSubdivision =\n          targetCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;\n      }\n      if (!wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX) {\n        needsSubdivision =\n          sourceCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;\n      }\n    }\n\n    if (!needsSubdivision && this.maxSourceExtent_) {\n      if (\n        isFinite(sourceQuadExtent[0]) &&\n        isFinite(sourceQuadExtent[1]) &&\n        isFinite(sourceQuadExtent[2]) &&\n        isFinite(sourceQuadExtent[3])\n      ) {\n        if (!intersects(sourceQuadExtent, this.maxSourceExtent_)) {\n          // whole quad outside source projection extent -> ignore\n          return;\n        }\n      }\n    }\n\n    let isNotFinite = 0;\n\n    if (!needsSubdivision) {\n      if (\n        !isFinite(aSrc[0]) ||\n        !isFinite(aSrc[1]) ||\n        !isFinite(bSrc[0]) ||\n        !isFinite(bSrc[1]) ||\n        !isFinite(cSrc[0]) ||\n        !isFinite(cSrc[1]) ||\n        !isFinite(dSrc[0]) ||\n        !isFinite(dSrc[1])\n      ) {\n        if (maxSubdivision > 0) {\n          needsSubdivision = true;\n        } else {\n          // It might be the case that only 1 of the points is infinite. In this case\n          // we can draw a single triangle with the other three points\n          isNotFinite =\n            (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) ? 8 : 0) +\n            (!isFinite(bSrc[0]) || !isFinite(bSrc[1]) ? 4 : 0) +\n            (!isFinite(cSrc[0]) || !isFinite(cSrc[1]) ? 2 : 0) +\n            (!isFinite(dSrc[0]) || !isFinite(dSrc[1]) ? 1 : 0);\n          if (\n            isNotFinite != 1 &&\n            isNotFinite != 2 &&\n            isNotFinite != 4 &&\n            isNotFinite != 8\n          ) {\n            return;\n          }\n        }\n      }\n    }\n\n    if (maxSubdivision > 0) {\n      if (!needsSubdivision) {\n        const center = [(a[0] + c[0]) / 2, (a[1] + c[1]) / 2];\n        const centerSrc = this.transformInv_(center);\n\n        let dx;\n        if (wrapsX) {\n          const centerSrcEstimX =\n            (modulo(aSrc[0], sourceWorldWidth) +\n              modulo(cSrc[0], sourceWorldWidth)) /\n            2;\n          dx = centerSrcEstimX - modulo(centerSrc[0], sourceWorldWidth);\n        } else {\n          dx = (aSrc[0] + cSrc[0]) / 2 - centerSrc[0];\n        }\n        const dy = (aSrc[1] + cSrc[1]) / 2 - centerSrc[1];\n        const centerSrcErrorSquared = dx * dx + dy * dy;\n        needsSubdivision = centerSrcErrorSquared > this.errorThresholdSquared_;\n      }\n      if (needsSubdivision) {\n        if (Math.abs(a[0] - c[0]) <= Math.abs(a[1] - c[1])) {\n          // split horizontally (top & bottom)\n          const bc = [(b[0] + c[0]) / 2, (b[1] + c[1]) / 2];\n          const bcSrc = this.transformInv_(bc);\n          const da = [(d[0] + a[0]) / 2, (d[1] + a[1]) / 2];\n          const daSrc = this.transformInv_(da);\n\n          this.addQuad_(\n            a,\n            b,\n            bc,\n            da,\n            aSrc,\n            bSrc,\n            bcSrc,\n            daSrc,\n            maxSubdivision - 1\n          );\n          this.addQuad_(\n            da,\n            bc,\n            c,\n            d,\n            daSrc,\n            bcSrc,\n            cSrc,\n            dSrc,\n            maxSubdivision - 1\n          );\n        } else {\n          // split vertically (left & right)\n          const ab = [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];\n          const abSrc = this.transformInv_(ab);\n          const cd = [(c[0] + d[0]) / 2, (c[1] + d[1]) / 2];\n          const cdSrc = this.transformInv_(cd);\n\n          this.addQuad_(\n            a,\n            ab,\n            cd,\n            d,\n            aSrc,\n            abSrc,\n            cdSrc,\n            dSrc,\n            maxSubdivision - 1\n          );\n          this.addQuad_(\n            ab,\n            b,\n            c,\n            cd,\n            abSrc,\n            bSrc,\n            cSrc,\n            cdSrc,\n            maxSubdivision - 1\n          );\n        }\n        return;\n      }\n    }\n\n    if (wrapsX) {\n      if (!this.canWrapXInSource_) {\n        return;\n      }\n      this.wrapsXInSource_ = true;\n    }\n\n    // Exactly zero or one of *Src is not finite\n    // The triangles must have the diagonal line as the first side\n    // This is to allow easy code in reproj.s to make it straight for broken\n    // browsers that can't handle diagonal clipping\n    if ((isNotFinite & 0xb) == 0) {\n      this.addTriangle_(a, c, d, aSrc, cSrc, dSrc);\n    }\n    if ((isNotFinite & 0xe) == 0) {\n      this.addTriangle_(a, c, b, aSrc, cSrc, bSrc);\n    }\n    if (isNotFinite) {\n      // Try the other two triangles\n      if ((isNotFinite & 0xd) == 0) {\n        this.addTriangle_(b, d, a, bSrc, dSrc, aSrc);\n      }\n      if ((isNotFinite & 0x7) == 0) {\n        this.addTriangle_(b, d, c, bSrc, dSrc, cSrc);\n      }\n    }\n  }\n\n  /**\n   * Calculates extent of the `source` coordinates from all the triangles.\n   *\n   * @return {import(\"../extent.js\").Extent} Calculated extent.\n   */\n  calculateSourceExtent() {\n    const extent = createEmpty();\n\n    this.triangles_.forEach(function (triangle, i, arr) {\n      const src = triangle.source;\n      extendCoordinate(extent, src[0]);\n      extendCoordinate(extent, src[1]);\n      extendCoordinate(extent, src[2]);\n    });\n\n    return extent;\n  }\n\n  /**\n   * @return {Array<Triangle>} Array of the calculated triangles.\n   */\n  getTriangles() {\n    return this.triangles_;\n  }\n}\n\nexport default Triangulation;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}