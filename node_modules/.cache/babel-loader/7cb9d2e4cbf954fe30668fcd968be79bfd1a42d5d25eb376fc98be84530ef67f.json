{"ast":null,"code":"import _toConsumableArray from \"/home/jay/Downloads/major/my-app/gis/web-gis/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _classCallCheck from \"/home/jay/Downloads/major/my-app/gis/web-gis/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/jay/Downloads/major/my-app/gis/web-gis/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n/**\n * @module ol/render/canvas/ExecutorGroup\n */\n\nimport Executor from './Executor.js';\nimport { ascending } from '../../array.js';\nimport { buffer, createEmpty, extendCoordinate } from '../../extent.js';\nimport { compose as composeTransform, create as createTransform } from '../../transform.js';\nimport { createCanvasContext2D } from '../../dom.js';\nimport { isEmpty as _isEmpty } from '../../obj.js';\nimport { transform2D } from '../../geom/flat/transform.js';\n\n/**\n * @const\n * @type {Array<import(\"../canvas.js\").BuilderType>}\n */\nvar ORDER = ['Polygon', 'Circle', 'LineString', 'Image', 'Text', 'Default'];\nvar ExecutorGroup = /*#__PURE__*/function () {\n  /**\n   * @param {import(\"../../extent.js\").Extent} maxExtent Max extent for clipping. When a\n   * `maxExtent` was set on the Builder for this executor group, the same `maxExtent`\n   * should be set here, unless the target context does not exceed that extent (which\n   * can be the case when rendering to tiles).\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {boolean} overlaps The executor group can have overlapping geometries.\n   * @param {!Object<string, !Object<import(\"../canvas.js\").BuilderType, import(\"../canvas.js\").SerializableInstructions>>} allInstructions\n   * The serializable instructions.\n   * @param {number} [renderBuffer] Optional rendering buffer.\n   */\n  function ExecutorGroup(maxExtent, resolution, pixelRatio, overlaps, allInstructions, renderBuffer) {\n    _classCallCheck(this, ExecutorGroup);\n    /**\n     * @private\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.maxExtent_ = maxExtent;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.overlaps_ = overlaps;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.pixelRatio_ = pixelRatio;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.resolution_ = resolution;\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.renderBuffer_ = renderBuffer;\n\n    /**\n     * @private\n     * @type {!Object<string, !Object<import(\"../canvas.js\").BuilderType, import(\"./Executor\").default>>}\n     */\n    this.executorsByZIndex_ = {};\n\n    /**\n     * @private\n     * @type {CanvasRenderingContext2D}\n     */\n    this.hitDetectionContext_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.hitDetectionTransform_ = createTransform();\n    this.createExecutors_(allInstructions);\n  }\n\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\n   */\n  _createClass(ExecutorGroup, [{\n    key: \"clip\",\n    value: function clip(context, transform) {\n      var flatClipCoords = this.getClipCoords(transform);\n      context.beginPath();\n      context.moveTo(flatClipCoords[0], flatClipCoords[1]);\n      context.lineTo(flatClipCoords[2], flatClipCoords[3]);\n      context.lineTo(flatClipCoords[4], flatClipCoords[5]);\n      context.lineTo(flatClipCoords[6], flatClipCoords[7]);\n      context.clip();\n    }\n\n    /**\n     * Create executors and populate them using the provided instructions.\n     * @private\n     * @param {!Object<string, !Object<import(\"../canvas.js\").BuilderType, import(\"../canvas.js\").SerializableInstructions>>} allInstructions The serializable instructions\n     */\n  }, {\n    key: \"createExecutors_\",\n    value: function createExecutors_(allInstructions) {\n      for (var zIndex in allInstructions) {\n        var executors = this.executorsByZIndex_[zIndex];\n        if (executors === undefined) {\n          executors = {};\n          this.executorsByZIndex_[zIndex] = executors;\n        }\n        var instructionByZindex = allInstructions[zIndex];\n        for (var builderType in instructionByZindex) {\n          var instructions = instructionByZindex[builderType];\n          executors[builderType] = new Executor(this.resolution_, this.pixelRatio_, this.overlaps_, instructions);\n        }\n      }\n    }\n\n    /**\n     * @param {Array<import(\"../canvas.js\").BuilderType>} executors Executors.\n     * @return {boolean} Has executors of the provided types.\n     */\n  }, {\n    key: \"hasExecutors\",\n    value: function hasExecutors(executors) {\n      for (var zIndex in this.executorsByZIndex_) {\n        var candidates = this.executorsByZIndex_[zIndex];\n        for (var i = 0, ii = executors.length; i < ii; ++i) {\n          if (executors[i] in candidates) {\n            return true;\n          }\n        }\n      }\n      return false;\n    }\n\n    /**\n     * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n     * @param {number} resolution Resolution.\n     * @param {number} rotation Rotation.\n     * @param {number} hitTolerance Hit tolerance in pixels.\n     * @param {function(import(\"../../Feature.js\").FeatureLike, import(\"../../geom/SimpleGeometry.js\").default, number): T} callback Feature callback.\n     * @param {Array<import(\"../../Feature.js\").FeatureLike>} declutteredFeatures Decluttered features.\n     * @return {T|undefined} Callback result.\n     * @template T\n     */\n  }, {\n    key: \"forEachFeatureAtCoordinate\",\n    value: function forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, callback, declutteredFeatures) {\n      hitTolerance = Math.round(hitTolerance);\n      var contextSize = hitTolerance * 2 + 1;\n      var transform = composeTransform(this.hitDetectionTransform_, hitTolerance + 0.5, hitTolerance + 0.5, 1 / resolution, -1 / resolution, -rotation, -coordinate[0], -coordinate[1]);\n      var newContext = !this.hitDetectionContext_;\n      if (newContext) {\n        this.hitDetectionContext_ = createCanvasContext2D(contextSize, contextSize, undefined, {\n          willReadFrequently: true\n        });\n      }\n      var context = this.hitDetectionContext_;\n      if (context.canvas.width !== contextSize || context.canvas.height !== contextSize) {\n        context.canvas.width = contextSize;\n        context.canvas.height = contextSize;\n      } else if (!newContext) {\n        context.clearRect(0, 0, contextSize, contextSize);\n      }\n\n      /**\n       * @type {import(\"../../extent.js\").Extent}\n       */\n      var hitExtent;\n      if (this.renderBuffer_ !== undefined) {\n        hitExtent = createEmpty();\n        extendCoordinate(hitExtent, coordinate);\n        buffer(hitExtent, resolution * (this.renderBuffer_ + hitTolerance), hitExtent);\n      }\n      var indexes = getPixelIndexArray(hitTolerance);\n      var builderType;\n\n      /**\n       * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n       * @param {import(\"../../geom/SimpleGeometry.js\").default} geometry Geometry.\n       * @return {T|undefined} Callback result.\n       */\n      function featureCallback(feature, geometry) {\n        var imageData = context.getImageData(0, 0, contextSize, contextSize).data;\n        for (var _i = 0, ii = indexes.length; _i < ii; _i++) {\n          if (imageData[indexes[_i]] > 0) {\n            if (!declutteredFeatures || builderType !== 'Image' && builderType !== 'Text' || declutteredFeatures.includes(feature)) {\n              var idx = (indexes[_i] - 3) / 4;\n              var x = hitTolerance - idx % contextSize;\n              var y = hitTolerance - (idx / contextSize | 0);\n              var _result = callback(feature, geometry, x * x + y * y);\n              if (_result) {\n                return _result;\n              }\n            }\n            context.clearRect(0, 0, contextSize, contextSize);\n            break;\n          }\n        }\n        return undefined;\n      }\n\n      /** @type {Array<number>} */\n      var zs = Object.keys(this.executorsByZIndex_).map(Number);\n      zs.sort(ascending);\n      var i, j, executors, executor, result;\n      for (i = zs.length - 1; i >= 0; --i) {\n        var zIndexKey = zs[i].toString();\n        executors = this.executorsByZIndex_[zIndexKey];\n        for (j = ORDER.length - 1; j >= 0; --j) {\n          builderType = ORDER[j];\n          executor = executors[builderType];\n          if (executor !== undefined) {\n            result = executor.executeHitDetection(context, transform, rotation, featureCallback, hitExtent);\n            if (result) {\n              return result;\n            }\n          }\n        }\n      }\n      return undefined;\n    }\n\n    /**\n     * @param {import(\"../../transform.js\").Transform} transform Transform.\n     * @return {Array<number>|null} Clip coordinates.\n     */\n  }, {\n    key: \"getClipCoords\",\n    value: function getClipCoords(transform) {\n      var maxExtent = this.maxExtent_;\n      if (!maxExtent) {\n        return null;\n      }\n      var minX = maxExtent[0];\n      var minY = maxExtent[1];\n      var maxX = maxExtent[2];\n      var maxY = maxExtent[3];\n      var flatClipCoords = [minX, minY, minX, maxY, maxX, maxY, maxX, minY];\n      transform2D(flatClipCoords, 0, 8, 2, transform, flatClipCoords);\n      return flatClipCoords;\n    }\n\n    /**\n     * @return {boolean} Is empty.\n     */\n  }, {\n    key: \"isEmpty\",\n    value: function isEmpty() {\n      return _isEmpty(this.executorsByZIndex_);\n    }\n\n    /**\n     * @param {CanvasRenderingContext2D} context Context.\n     * @param {number} contextScale Scale of the context.\n     * @param {import(\"../../transform.js\").Transform} transform Transform.\n     * @param {number} viewRotation View rotation.\n     * @param {boolean} snapToPixel Snap point symbols and test to integer pixel.\n     * @param {Array<import(\"../canvas.js\").BuilderType>} [builderTypes] Ordered replay types to replay.\n     *     Default is {@link module:ol/render/replay~ORDER}\n     * @param {import(\"rbush\").default} [declutterTree] Declutter tree.\n     */\n  }, {\n    key: \"execute\",\n    value: function execute(context, contextScale, transform, viewRotation, snapToPixel, builderTypes, declutterTree) {\n      /** @type {Array<number>} */\n      var zs = Object.keys(this.executorsByZIndex_).map(Number);\n      zs.sort(ascending);\n\n      // setup clipping so that the parts of over-simplified geometries are not\n      // visible outside the current extent when panning\n      if (this.maxExtent_) {\n        context.save();\n        this.clip(context, transform);\n      }\n      builderTypes = builderTypes ? builderTypes : ORDER;\n      var i, ii, j, jj, replays, replay;\n      if (declutterTree) {\n        zs.reverse();\n      }\n      for (i = 0, ii = zs.length; i < ii; ++i) {\n        var zIndexKey = zs[i].toString();\n        replays = this.executorsByZIndex_[zIndexKey];\n        for (j = 0, jj = builderTypes.length; j < jj; ++j) {\n          var builderType = builderTypes[j];\n          replay = replays[builderType];\n          if (replay !== undefined) {\n            replay.execute(context, contextScale, transform, viewRotation, snapToPixel, declutterTree);\n          }\n        }\n      }\n      if (this.maxExtent_) {\n        context.restore();\n      }\n    }\n  }]);\n  return ExecutorGroup;\n}();\n/**\n * This cache is used to store arrays of indexes for calculated pixel circles\n * to increase performance.\n * It is a static property to allow each Replaygroup to access it.\n * @type {Object<number, Array<number>>}\n */\nvar circlePixelIndexArrayCache = {};\n\n/**\n * This methods creates an array with indexes of all pixels within a circle,\n * ordered by how close they are to the center.\n * A cache is used to increase performance.\n * @param {number} radius Radius.\n * @return {Array<number>} An array with indexes within a circle.\n */\nexport function getPixelIndexArray(radius) {\n  if (circlePixelIndexArrayCache[radius] !== undefined) {\n    return circlePixelIndexArrayCache[radius];\n  }\n  var size = radius * 2 + 1;\n  var maxDistanceSq = radius * radius;\n  var distances = new Array(maxDistanceSq + 1);\n  for (var i = 0; i <= radius; ++i) {\n    for (var j = 0; j <= radius; ++j) {\n      var distanceSq = i * i + j * j;\n      if (distanceSq > maxDistanceSq) {\n        break;\n      }\n      var distance = distances[distanceSq];\n      if (!distance) {\n        distance = [];\n        distances[distanceSq] = distance;\n      }\n      distance.push(((radius + i) * size + (radius + j)) * 4 + 3);\n      if (i > 0) {\n        distance.push(((radius - i) * size + (radius + j)) * 4 + 3);\n      }\n      if (j > 0) {\n        distance.push(((radius + i) * size + (radius - j)) * 4 + 3);\n        if (i > 0) {\n          distance.push(((radius - i) * size + (radius - j)) * 4 + 3);\n        }\n      }\n    }\n  }\n  var pixelIndex = [];\n  for (var _i2 = 0, ii = distances.length; _i2 < ii; ++_i2) {\n    if (distances[_i2]) {\n      pixelIndex.push.apply(pixelIndex, _toConsumableArray(distances[_i2]));\n    }\n  }\n  circlePixelIndexArrayCache[radius] = pixelIndex;\n  return pixelIndex;\n}\nexport default ExecutorGroup;","map":{"version":3,"names":["Executor","ascending","buffer","createEmpty","extendCoordinate","compose","composeTransform","create","createTransform","createCanvasContext2D","isEmpty","transform2D","ORDER","ExecutorGroup","maxExtent","resolution","pixelRatio","overlaps","allInstructions","renderBuffer","_classCallCheck","maxExtent_","overlaps_","pixelRatio_","resolution_","renderBuffer_","executorsByZIndex_","hitDetectionContext_","hitDetectionTransform_","createExecutors_","_createClass","key","value","clip","context","transform","flatClipCoords","getClipCoords","beginPath","moveTo","lineTo","zIndex","executors","undefined","instructionByZindex","builderType","instructions","hasExecutors","candidates","i","ii","length","forEachFeatureAtCoordinate","coordinate","rotation","hitTolerance","callback","declutteredFeatures","Math","round","contextSize","newContext","willReadFrequently","canvas","width","height","clearRect","hitExtent","indexes","getPixelIndexArray","featureCallback","feature","geometry","imageData","getImageData","data","includes","idx","x","y","result","zs","Object","keys","map","Number","sort","j","executor","zIndexKey","toString","executeHitDetection","minX","minY","maxX","maxY","execute","contextScale","viewRotation","snapToPixel","builderTypes","declutterTree","save","jj","replays","replay","reverse","restore","circlePixelIndexArrayCache","radius","size","maxDistanceSq","distances","Array","distanceSq","distance","push","pixelIndex","apply","_toConsumableArray"],"sources":["/home/jay/Downloads/major/my-app/gis/web-gis/node_modules/ol/render/canvas/ExecutorGroup.js"],"sourcesContent":["/**\n * @module ol/render/canvas/ExecutorGroup\n */\n\nimport Executor from './Executor.js';\nimport {ascending} from '../../array.js';\nimport {buffer, createEmpty, extendCoordinate} from '../../extent.js';\nimport {\n  compose as composeTransform,\n  create as createTransform,\n} from '../../transform.js';\nimport {createCanvasContext2D} from '../../dom.js';\nimport {isEmpty} from '../../obj.js';\nimport {transform2D} from '../../geom/flat/transform.js';\n\n/**\n * @const\n * @type {Array<import(\"../canvas.js\").BuilderType>}\n */\nconst ORDER = ['Polygon', 'Circle', 'LineString', 'Image', 'Text', 'Default'];\n\nclass ExecutorGroup {\n  /**\n   * @param {import(\"../../extent.js\").Extent} maxExtent Max extent for clipping. When a\n   * `maxExtent` was set on the Builder for this executor group, the same `maxExtent`\n   * should be set here, unless the target context does not exceed that extent (which\n   * can be the case when rendering to tiles).\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {boolean} overlaps The executor group can have overlapping geometries.\n   * @param {!Object<string, !Object<import(\"../canvas.js\").BuilderType, import(\"../canvas.js\").SerializableInstructions>>} allInstructions\n   * The serializable instructions.\n   * @param {number} [renderBuffer] Optional rendering buffer.\n   */\n  constructor(\n    maxExtent,\n    resolution,\n    pixelRatio,\n    overlaps,\n    allInstructions,\n    renderBuffer\n  ) {\n    /**\n     * @private\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.maxExtent_ = maxExtent;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.overlaps_ = overlaps;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.pixelRatio_ = pixelRatio;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.resolution_ = resolution;\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.renderBuffer_ = renderBuffer;\n\n    /**\n     * @private\n     * @type {!Object<string, !Object<import(\"../canvas.js\").BuilderType, import(\"./Executor\").default>>}\n     */\n    this.executorsByZIndex_ = {};\n\n    /**\n     * @private\n     * @type {CanvasRenderingContext2D}\n     */\n    this.hitDetectionContext_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.hitDetectionTransform_ = createTransform();\n\n    this.createExecutors_(allInstructions);\n  }\n\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\n   */\n  clip(context, transform) {\n    const flatClipCoords = this.getClipCoords(transform);\n    context.beginPath();\n    context.moveTo(flatClipCoords[0], flatClipCoords[1]);\n    context.lineTo(flatClipCoords[2], flatClipCoords[3]);\n    context.lineTo(flatClipCoords[4], flatClipCoords[5]);\n    context.lineTo(flatClipCoords[6], flatClipCoords[7]);\n    context.clip();\n  }\n\n  /**\n   * Create executors and populate them using the provided instructions.\n   * @private\n   * @param {!Object<string, !Object<import(\"../canvas.js\").BuilderType, import(\"../canvas.js\").SerializableInstructions>>} allInstructions The serializable instructions\n   */\n  createExecutors_(allInstructions) {\n    for (const zIndex in allInstructions) {\n      let executors = this.executorsByZIndex_[zIndex];\n      if (executors === undefined) {\n        executors = {};\n        this.executorsByZIndex_[zIndex] = executors;\n      }\n      const instructionByZindex = allInstructions[zIndex];\n      for (const builderType in instructionByZindex) {\n        const instructions = instructionByZindex[builderType];\n        executors[builderType] = new Executor(\n          this.resolution_,\n          this.pixelRatio_,\n          this.overlaps_,\n          instructions\n        );\n      }\n    }\n  }\n\n  /**\n   * @param {Array<import(\"../canvas.js\").BuilderType>} executors Executors.\n   * @return {boolean} Has executors of the provided types.\n   */\n  hasExecutors(executors) {\n    for (const zIndex in this.executorsByZIndex_) {\n      const candidates = this.executorsByZIndex_[zIndex];\n      for (let i = 0, ii = executors.length; i < ii; ++i) {\n        if (executors[i] in candidates) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {number} resolution Resolution.\n   * @param {number} rotation Rotation.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {function(import(\"../../Feature.js\").FeatureLike, import(\"../../geom/SimpleGeometry.js\").default, number): T} callback Feature callback.\n   * @param {Array<import(\"../../Feature.js\").FeatureLike>} declutteredFeatures Decluttered features.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n  forEachFeatureAtCoordinate(\n    coordinate,\n    resolution,\n    rotation,\n    hitTolerance,\n    callback,\n    declutteredFeatures\n  ) {\n    hitTolerance = Math.round(hitTolerance);\n    const contextSize = hitTolerance * 2 + 1;\n    const transform = composeTransform(\n      this.hitDetectionTransform_,\n      hitTolerance + 0.5,\n      hitTolerance + 0.5,\n      1 / resolution,\n      -1 / resolution,\n      -rotation,\n      -coordinate[0],\n      -coordinate[1]\n    );\n\n    const newContext = !this.hitDetectionContext_;\n    if (newContext) {\n      this.hitDetectionContext_ = createCanvasContext2D(\n        contextSize,\n        contextSize,\n        undefined,\n        {willReadFrequently: true}\n      );\n    }\n    const context = this.hitDetectionContext_;\n\n    if (\n      context.canvas.width !== contextSize ||\n      context.canvas.height !== contextSize\n    ) {\n      context.canvas.width = contextSize;\n      context.canvas.height = contextSize;\n    } else if (!newContext) {\n      context.clearRect(0, 0, contextSize, contextSize);\n    }\n\n    /**\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    let hitExtent;\n    if (this.renderBuffer_ !== undefined) {\n      hitExtent = createEmpty();\n      extendCoordinate(hitExtent, coordinate);\n      buffer(\n        hitExtent,\n        resolution * (this.renderBuffer_ + hitTolerance),\n        hitExtent\n      );\n    }\n\n    const indexes = getPixelIndexArray(hitTolerance);\n\n    let builderType;\n\n    /**\n     * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n     * @param {import(\"../../geom/SimpleGeometry.js\").default} geometry Geometry.\n     * @return {T|undefined} Callback result.\n     */\n    function featureCallback(feature, geometry) {\n      const imageData = context.getImageData(\n        0,\n        0,\n        contextSize,\n        contextSize\n      ).data;\n      for (let i = 0, ii = indexes.length; i < ii; i++) {\n        if (imageData[indexes[i]] > 0) {\n          if (\n            !declutteredFeatures ||\n            (builderType !== 'Image' && builderType !== 'Text') ||\n            declutteredFeatures.includes(feature)\n          ) {\n            const idx = (indexes[i] - 3) / 4;\n            const x = hitTolerance - (idx % contextSize);\n            const y = hitTolerance - ((idx / contextSize) | 0);\n            const result = callback(feature, geometry, x * x + y * y);\n            if (result) {\n              return result;\n            }\n          }\n          context.clearRect(0, 0, contextSize, contextSize);\n          break;\n        }\n      }\n      return undefined;\n    }\n\n    /** @type {Array<number>} */\n    const zs = Object.keys(this.executorsByZIndex_).map(Number);\n    zs.sort(ascending);\n\n    let i, j, executors, executor, result;\n    for (i = zs.length - 1; i >= 0; --i) {\n      const zIndexKey = zs[i].toString();\n      executors = this.executorsByZIndex_[zIndexKey];\n      for (j = ORDER.length - 1; j >= 0; --j) {\n        builderType = ORDER[j];\n        executor = executors[builderType];\n        if (executor !== undefined) {\n          result = executor.executeHitDetection(\n            context,\n            transform,\n            rotation,\n            featureCallback,\n            hitExtent\n          );\n          if (result) {\n            return result;\n          }\n        }\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\n   * @return {Array<number>|null} Clip coordinates.\n   */\n  getClipCoords(transform) {\n    const maxExtent = this.maxExtent_;\n    if (!maxExtent) {\n      return null;\n    }\n    const minX = maxExtent[0];\n    const minY = maxExtent[1];\n    const maxX = maxExtent[2];\n    const maxY = maxExtent[3];\n    const flatClipCoords = [minX, minY, minX, maxY, maxX, maxY, maxX, minY];\n    transform2D(flatClipCoords, 0, 8, 2, transform, flatClipCoords);\n    return flatClipCoords;\n  }\n\n  /**\n   * @return {boolean} Is empty.\n   */\n  isEmpty() {\n    return isEmpty(this.executorsByZIndex_);\n  }\n\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {number} contextScale Scale of the context.\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\n   * @param {number} viewRotation View rotation.\n   * @param {boolean} snapToPixel Snap point symbols and test to integer pixel.\n   * @param {Array<import(\"../canvas.js\").BuilderType>} [builderTypes] Ordered replay types to replay.\n   *     Default is {@link module:ol/render/replay~ORDER}\n   * @param {import(\"rbush\").default} [declutterTree] Declutter tree.\n   */\n  execute(\n    context,\n    contextScale,\n    transform,\n    viewRotation,\n    snapToPixel,\n    builderTypes,\n    declutterTree\n  ) {\n    /** @type {Array<number>} */\n    const zs = Object.keys(this.executorsByZIndex_).map(Number);\n    zs.sort(ascending);\n\n    // setup clipping so that the parts of over-simplified geometries are not\n    // visible outside the current extent when panning\n    if (this.maxExtent_) {\n      context.save();\n      this.clip(context, transform);\n    }\n\n    builderTypes = builderTypes ? builderTypes : ORDER;\n    let i, ii, j, jj, replays, replay;\n    if (declutterTree) {\n      zs.reverse();\n    }\n    for (i = 0, ii = zs.length; i < ii; ++i) {\n      const zIndexKey = zs[i].toString();\n      replays = this.executorsByZIndex_[zIndexKey];\n      for (j = 0, jj = builderTypes.length; j < jj; ++j) {\n        const builderType = builderTypes[j];\n        replay = replays[builderType];\n        if (replay !== undefined) {\n          replay.execute(\n            context,\n            contextScale,\n            transform,\n            viewRotation,\n            snapToPixel,\n            declutterTree\n          );\n        }\n      }\n    }\n\n    if (this.maxExtent_) {\n      context.restore();\n    }\n  }\n}\n\n/**\n * This cache is used to store arrays of indexes for calculated pixel circles\n * to increase performance.\n * It is a static property to allow each Replaygroup to access it.\n * @type {Object<number, Array<number>>}\n */\nconst circlePixelIndexArrayCache = {};\n\n/**\n * This methods creates an array with indexes of all pixels within a circle,\n * ordered by how close they are to the center.\n * A cache is used to increase performance.\n * @param {number} radius Radius.\n * @return {Array<number>} An array with indexes within a circle.\n */\nexport function getPixelIndexArray(radius) {\n  if (circlePixelIndexArrayCache[radius] !== undefined) {\n    return circlePixelIndexArrayCache[radius];\n  }\n\n  const size = radius * 2 + 1;\n  const maxDistanceSq = radius * radius;\n  const distances = new Array(maxDistanceSq + 1);\n  for (let i = 0; i <= radius; ++i) {\n    for (let j = 0; j <= radius; ++j) {\n      const distanceSq = i * i + j * j;\n      if (distanceSq > maxDistanceSq) {\n        break;\n      }\n      let distance = distances[distanceSq];\n      if (!distance) {\n        distance = [];\n        distances[distanceSq] = distance;\n      }\n      distance.push(((radius + i) * size + (radius + j)) * 4 + 3);\n      if (i > 0) {\n        distance.push(((radius - i) * size + (radius + j)) * 4 + 3);\n      }\n      if (j > 0) {\n        distance.push(((radius + i) * size + (radius - j)) * 4 + 3);\n        if (i > 0) {\n          distance.push(((radius - i) * size + (radius - j)) * 4 + 3);\n        }\n      }\n    }\n  }\n\n  const pixelIndex = [];\n  for (let i = 0, ii = distances.length; i < ii; ++i) {\n    if (distances[i]) {\n      pixelIndex.push(...distances[i]);\n    }\n  }\n\n  circlePixelIndexArrayCache[radius] = pixelIndex;\n  return pixelIndex;\n}\n\nexport default ExecutorGroup;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}