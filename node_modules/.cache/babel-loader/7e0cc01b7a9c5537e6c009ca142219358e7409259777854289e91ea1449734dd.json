{"ast":null,"code":"import _classCallCheck from \"/home/jay/Downloads/major/my-app/gis/web-gis/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/jay/Downloads/major/my-app/gis/web-gis/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/home/jay/Downloads/major/my-app/gis/web-gis/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/home/jay/Downloads/major/my-app/gis/web-gis/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\n/**\n * @module ol/geom/SimpleGeometry\n */\nimport Geometry from './Geometry.js';\nimport { abstract } from '../util.js';\nimport { createOrUpdateFromFlatCoordinates, getCenter } from '../extent.js';\nimport { rotate as _rotate, scale as _scale, transform2D, translate as _translate } from './flat/transform.js';\n\n/**\n * @classdesc\n * Abstract base class; only used for creating subclasses; do not instantiate\n * in apps, as cannot be rendered.\n *\n * @abstract\n * @api\n */\nvar SimpleGeometry = /*#__PURE__*/function (_Geometry) {\n  _inherits(SimpleGeometry, _Geometry);\n  var _super = _createSuper(SimpleGeometry);\n  function SimpleGeometry() {\n    var _this;\n    _classCallCheck(this, SimpleGeometry);\n    _this = _super.call(this);\n\n    /**\n     * @protected\n     * @type {import(\"./Geometry.js\").GeometryLayout}\n     */\n    _this.layout = 'XY';\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    _this.stride = 2;\n\n    /**\n     * @protected\n     * @type {Array<number>}\n     */\n    _this.flatCoordinates = null;\n    return _this;\n  }\n\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @protected\n   * @return {import(\"../extent.js\").Extent} extent Extent.\n   */\n  _createClass(SimpleGeometry, [{\n    key: \"computeExtent\",\n    value: function computeExtent(extent) {\n      return createOrUpdateFromFlatCoordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, extent);\n    }\n\n    /**\n     * @abstract\n     * @return {Array<*> | null} Coordinates.\n     */\n  }, {\n    key: \"getCoordinates\",\n    value: function getCoordinates() {\n      return abstract();\n    }\n\n    /**\n     * Return the first coordinate of the geometry.\n     * @return {import(\"../coordinate.js\").Coordinate} First coordinate.\n     * @api\n     */\n  }, {\n    key: \"getFirstCoordinate\",\n    value: function getFirstCoordinate() {\n      return this.flatCoordinates.slice(0, this.stride);\n    }\n\n    /**\n     * @return {Array<number>} Flat coordinates.\n     */\n  }, {\n    key: \"getFlatCoordinates\",\n    value: function getFlatCoordinates() {\n      return this.flatCoordinates;\n    }\n\n    /**\n     * Return the last coordinate of the geometry.\n     * @return {import(\"../coordinate.js\").Coordinate} Last point.\n     * @api\n     */\n  }, {\n    key: \"getLastCoordinate\",\n    value: function getLastCoordinate() {\n      return this.flatCoordinates.slice(this.flatCoordinates.length - this.stride);\n    }\n\n    /**\n     * Return the {@link import(\"./Geometry.js\").GeometryLayout layout} of the geometry.\n     * @return {import(\"./Geometry.js\").GeometryLayout} Layout.\n     * @api\n     */\n  }, {\n    key: \"getLayout\",\n    value: function getLayout() {\n      return this.layout;\n    }\n\n    /**\n     * Create a simplified version of this geometry using the Douglas Peucker algorithm.\n     * @param {number} squaredTolerance Squared tolerance.\n     * @return {SimpleGeometry} Simplified geometry.\n     */\n  }, {\n    key: \"getSimplifiedGeometry\",\n    value: function getSimplifiedGeometry(squaredTolerance) {\n      if (this.simplifiedGeometryRevision !== this.getRevision()) {\n        this.simplifiedGeometryMaxMinSquaredTolerance = 0;\n        this.simplifiedGeometryRevision = this.getRevision();\n      }\n      // If squaredTolerance is negative or if we know that simplification will not\n      // have any effect then just return this.\n      if (squaredTolerance < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && squaredTolerance <= this.simplifiedGeometryMaxMinSquaredTolerance) {\n        return this;\n      }\n      var simplifiedGeometry = this.getSimplifiedGeometryInternal(squaredTolerance);\n      var simplifiedFlatCoordinates = simplifiedGeometry.getFlatCoordinates();\n      if (simplifiedFlatCoordinates.length < this.flatCoordinates.length) {\n        return simplifiedGeometry;\n      }\n      // Simplification did not actually remove any coordinates.  We now know\n      // that any calls to getSimplifiedGeometry with a squaredTolerance less\n      // than or equal to the current squaredTolerance will also not have any\n      // effect.  This allows us to short circuit simplification (saving CPU\n      // cycles) and prevents the cache of simplified geometries from filling\n      // up with useless identical copies of this geometry (saving memory).\n      this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;\n      return this;\n    }\n\n    /**\n     * @param {number} squaredTolerance Squared tolerance.\n     * @return {SimpleGeometry} Simplified geometry.\n     * @protected\n     */\n  }, {\n    key: \"getSimplifiedGeometryInternal\",\n    value: function getSimplifiedGeometryInternal(squaredTolerance) {\n      return this;\n    }\n\n    /**\n     * @return {number} Stride.\n     */\n  }, {\n    key: \"getStride\",\n    value: function getStride() {\n      return this.stride;\n    }\n\n    /**\n     * @param {import(\"./Geometry.js\").GeometryLayout} layout Layout.\n     * @param {Array<number>} flatCoordinates Flat coordinates.\n     */\n  }, {\n    key: \"setFlatCoordinates\",\n    value: function setFlatCoordinates(layout, flatCoordinates) {\n      this.stride = getStrideForLayout(layout);\n      this.layout = layout;\n      this.flatCoordinates = flatCoordinates;\n    }\n\n    /**\n     * @abstract\n     * @param {!Array<*>} coordinates Coordinates.\n     * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n     */\n  }, {\n    key: \"setCoordinates\",\n    value: function setCoordinates(coordinates, layout) {\n      abstract();\n    }\n\n    /**\n     * @param {import(\"./Geometry.js\").GeometryLayout|undefined} layout Layout.\n     * @param {Array<*>} coordinates Coordinates.\n     * @param {number} nesting Nesting.\n     * @protected\n     */\n  }, {\n    key: \"setLayout\",\n    value: function setLayout(layout, coordinates, nesting) {\n      /** @type {number} */\n      var stride;\n      if (layout) {\n        stride = getStrideForLayout(layout);\n      } else {\n        for (var i = 0; i < nesting; ++i) {\n          if (coordinates.length === 0) {\n            this.layout = 'XY';\n            this.stride = 2;\n            return;\n          }\n          coordinates = /** @type {Array} */coordinates[0];\n        }\n        stride = coordinates.length;\n        layout = getLayoutForStride(stride);\n      }\n      this.layout = layout;\n      this.stride = stride;\n    }\n\n    /**\n     * Apply a transform function to the coordinates of the geometry.\n     * The geometry is modified in place.\n     * If you do not want the geometry modified in place, first `clone()` it and\n     * then use this function on the clone.\n     * @param {import(\"../proj.js\").TransformFunction} transformFn Transform function.\n     * Called with a flat array of geometry coordinates.\n     * @api\n     */\n  }, {\n    key: \"applyTransform\",\n    value: function applyTransform(transformFn) {\n      if (this.flatCoordinates) {\n        transformFn(this.flatCoordinates, this.flatCoordinates, this.stride);\n        this.changed();\n      }\n    }\n\n    /**\n     * Rotate the geometry around a given coordinate. This modifies the geometry\n     * coordinates in place.\n     * @param {number} angle Rotation angle in counter-clockwise radians.\n     * @param {import(\"../coordinate.js\").Coordinate} anchor The rotation center.\n     * @api\n     */\n  }, {\n    key: \"rotate\",\n    value: function rotate(angle, anchor) {\n      var flatCoordinates = this.getFlatCoordinates();\n      if (flatCoordinates) {\n        var stride = this.getStride();\n        _rotate(flatCoordinates, 0, flatCoordinates.length, stride, angle, anchor, flatCoordinates);\n        this.changed();\n      }\n    }\n\n    /**\n     * Scale the geometry (with an optional origin).  This modifies the geometry\n     * coordinates in place.\n     * @param {number} sx The scaling factor in the x-direction.\n     * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).\n     * @param {import(\"../coordinate.js\").Coordinate} [anchor] The scale origin (defaults to the center\n     *     of the geometry extent).\n     * @api\n     */\n  }, {\n    key: \"scale\",\n    value: function scale(sx, sy, anchor) {\n      if (sy === undefined) {\n        sy = sx;\n      }\n      if (!anchor) {\n        anchor = getCenter(this.getExtent());\n      }\n      var flatCoordinates = this.getFlatCoordinates();\n      if (flatCoordinates) {\n        var stride = this.getStride();\n        _scale(flatCoordinates, 0, flatCoordinates.length, stride, sx, sy, anchor, flatCoordinates);\n        this.changed();\n      }\n    }\n\n    /**\n     * Translate the geometry.  This modifies the geometry coordinates in place.  If\n     * instead you want a new geometry, first `clone()` this geometry.\n     * @param {number} deltaX Delta X.\n     * @param {number} deltaY Delta Y.\n     * @api\n     */\n  }, {\n    key: \"translate\",\n    value: function translate(deltaX, deltaY) {\n      var flatCoordinates = this.getFlatCoordinates();\n      if (flatCoordinates) {\n        var stride = this.getStride();\n        _translate(flatCoordinates, 0, flatCoordinates.length, stride, deltaX, deltaY, flatCoordinates);\n        this.changed();\n      }\n    }\n  }]);\n  return SimpleGeometry;\n}(Geometry);\n/**\n * @param {number} stride Stride.\n * @return {import(\"./Geometry.js\").GeometryLayout} layout Layout.\n */\nfunction getLayoutForStride(stride) {\n  var layout;\n  if (stride == 2) {\n    layout = 'XY';\n  } else if (stride == 3) {\n    layout = 'XYZ';\n  } else if (stride == 4) {\n    layout = 'XYZM';\n  }\n  return (/** @type {import(\"./Geometry.js\").GeometryLayout} */layout\n  );\n}\n\n/**\n * @param {import(\"./Geometry.js\").GeometryLayout} layout Layout.\n * @return {number} Stride.\n */\nexport function getStrideForLayout(layout) {\n  var stride;\n  if (layout == 'XY') {\n    stride = 2;\n  } else if (layout == 'XYZ' || layout == 'XYM') {\n    stride = 3;\n  } else if (layout == 'XYZM') {\n    stride = 4;\n  }\n  return (/** @type {number} */stride\n  );\n}\n\n/**\n * @param {SimpleGeometry} simpleGeometry Simple geometry.\n * @param {import(\"../transform.js\").Transform} transform Transform.\n * @param {Array<number>} [dest] Destination.\n * @return {Array<number>} Transformed flat coordinates.\n */\nexport function transformGeom2D(simpleGeometry, transform, dest) {\n  var flatCoordinates = simpleGeometry.getFlatCoordinates();\n  if (!flatCoordinates) {\n    return null;\n  }\n  var stride = simpleGeometry.getStride();\n  return transform2D(flatCoordinates, 0, flatCoordinates.length, stride, transform, dest);\n}\nexport default SimpleGeometry;","map":{"version":3,"names":["Geometry","abstract","createOrUpdateFromFlatCoordinates","getCenter","rotate","scale","transform2D","translate","SimpleGeometry","_Geometry","_inherits","_super","_createSuper","_this","_classCallCheck","call","layout","stride","flatCoordinates","_createClass","key","value","computeExtent","extent","length","getCoordinates","getFirstCoordinate","slice","getFlatCoordinates","getLastCoordinate","getLayout","getSimplifiedGeometry","squaredTolerance","simplifiedGeometryRevision","getRevision","simplifiedGeometryMaxMinSquaredTolerance","simplifiedGeometry","getSimplifiedGeometryInternal","simplifiedFlatCoordinates","getStride","setFlatCoordinates","getStrideForLayout","setCoordinates","coordinates","setLayout","nesting","i","getLayoutForStride","applyTransform","transformFn","changed","angle","anchor","sx","sy","undefined","getExtent","deltaX","deltaY","transformGeom2D","simpleGeometry","transform","dest"],"sources":["/home/jay/Downloads/major/my-app/gis/web-gis/node_modules/ol/geom/SimpleGeometry.js"],"sourcesContent":["/**\n * @module ol/geom/SimpleGeometry\n */\nimport Geometry from './Geometry.js';\nimport {abstract} from '../util.js';\nimport {createOrUpdateFromFlatCoordinates, getCenter} from '../extent.js';\nimport {rotate, scale, transform2D, translate} from './flat/transform.js';\n\n/**\n * @classdesc\n * Abstract base class; only used for creating subclasses; do not instantiate\n * in apps, as cannot be rendered.\n *\n * @abstract\n * @api\n */\nclass SimpleGeometry extends Geometry {\n  constructor() {\n    super();\n\n    /**\n     * @protected\n     * @type {import(\"./Geometry.js\").GeometryLayout}\n     */\n    this.layout = 'XY';\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.stride = 2;\n\n    /**\n     * @protected\n     * @type {Array<number>}\n     */\n    this.flatCoordinates = null;\n  }\n\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @protected\n   * @return {import(\"../extent.js\").Extent} extent Extent.\n   */\n  computeExtent(extent) {\n    return createOrUpdateFromFlatCoordinates(\n      this.flatCoordinates,\n      0,\n      this.flatCoordinates.length,\n      this.stride,\n      extent\n    );\n  }\n\n  /**\n   * @abstract\n   * @return {Array<*> | null} Coordinates.\n   */\n  getCoordinates() {\n    return abstract();\n  }\n\n  /**\n   * Return the first coordinate of the geometry.\n   * @return {import(\"../coordinate.js\").Coordinate} First coordinate.\n   * @api\n   */\n  getFirstCoordinate() {\n    return this.flatCoordinates.slice(0, this.stride);\n  }\n\n  /**\n   * @return {Array<number>} Flat coordinates.\n   */\n  getFlatCoordinates() {\n    return this.flatCoordinates;\n  }\n\n  /**\n   * Return the last coordinate of the geometry.\n   * @return {import(\"../coordinate.js\").Coordinate} Last point.\n   * @api\n   */\n  getLastCoordinate() {\n    return this.flatCoordinates.slice(\n      this.flatCoordinates.length - this.stride\n    );\n  }\n\n  /**\n   * Return the {@link import(\"./Geometry.js\").GeometryLayout layout} of the geometry.\n   * @return {import(\"./Geometry.js\").GeometryLayout} Layout.\n   * @api\n   */\n  getLayout() {\n    return this.layout;\n  }\n\n  /**\n   * Create a simplified version of this geometry using the Douglas Peucker algorithm.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {SimpleGeometry} Simplified geometry.\n   */\n  getSimplifiedGeometry(squaredTolerance) {\n    if (this.simplifiedGeometryRevision !== this.getRevision()) {\n      this.simplifiedGeometryMaxMinSquaredTolerance = 0;\n      this.simplifiedGeometryRevision = this.getRevision();\n    }\n    // If squaredTolerance is negative or if we know that simplification will not\n    // have any effect then just return this.\n    if (\n      squaredTolerance < 0 ||\n      (this.simplifiedGeometryMaxMinSquaredTolerance !== 0 &&\n        squaredTolerance <= this.simplifiedGeometryMaxMinSquaredTolerance)\n    ) {\n      return this;\n    }\n\n    const simplifiedGeometry =\n      this.getSimplifiedGeometryInternal(squaredTolerance);\n    const simplifiedFlatCoordinates = simplifiedGeometry.getFlatCoordinates();\n    if (simplifiedFlatCoordinates.length < this.flatCoordinates.length) {\n      return simplifiedGeometry;\n    }\n    // Simplification did not actually remove any coordinates.  We now know\n    // that any calls to getSimplifiedGeometry with a squaredTolerance less\n    // than or equal to the current squaredTolerance will also not have any\n    // effect.  This allows us to short circuit simplification (saving CPU\n    // cycles) and prevents the cache of simplified geometries from filling\n    // up with useless identical copies of this geometry (saving memory).\n    this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;\n    return this;\n  }\n\n  /**\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {SimpleGeometry} Simplified geometry.\n   * @protected\n   */\n  getSimplifiedGeometryInternal(squaredTolerance) {\n    return this;\n  }\n\n  /**\n   * @return {number} Stride.\n   */\n  getStride() {\n    return this.stride;\n  }\n\n  /**\n   * @param {import(\"./Geometry.js\").GeometryLayout} layout Layout.\n   * @param {Array<number>} flatCoordinates Flat coordinates.\n   */\n  setFlatCoordinates(layout, flatCoordinates) {\n    this.stride = getStrideForLayout(layout);\n    this.layout = layout;\n    this.flatCoordinates = flatCoordinates;\n  }\n\n  /**\n   * @abstract\n   * @param {!Array<*>} coordinates Coordinates.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   */\n  setCoordinates(coordinates, layout) {\n    abstract();\n  }\n\n  /**\n   * @param {import(\"./Geometry.js\").GeometryLayout|undefined} layout Layout.\n   * @param {Array<*>} coordinates Coordinates.\n   * @param {number} nesting Nesting.\n   * @protected\n   */\n  setLayout(layout, coordinates, nesting) {\n    /** @type {number} */\n    let stride;\n    if (layout) {\n      stride = getStrideForLayout(layout);\n    } else {\n      for (let i = 0; i < nesting; ++i) {\n        if (coordinates.length === 0) {\n          this.layout = 'XY';\n          this.stride = 2;\n          return;\n        }\n        coordinates = /** @type {Array} */ (coordinates[0]);\n      }\n      stride = coordinates.length;\n      layout = getLayoutForStride(stride);\n    }\n    this.layout = layout;\n    this.stride = stride;\n  }\n\n  /**\n   * Apply a transform function to the coordinates of the geometry.\n   * The geometry is modified in place.\n   * If you do not want the geometry modified in place, first `clone()` it and\n   * then use this function on the clone.\n   * @param {import(\"../proj.js\").TransformFunction} transformFn Transform function.\n   * Called with a flat array of geometry coordinates.\n   * @api\n   */\n  applyTransform(transformFn) {\n    if (this.flatCoordinates) {\n      transformFn(this.flatCoordinates, this.flatCoordinates, this.stride);\n      this.changed();\n    }\n  }\n\n  /**\n   * Rotate the geometry around a given coordinate. This modifies the geometry\n   * coordinates in place.\n   * @param {number} angle Rotation angle in counter-clockwise radians.\n   * @param {import(\"../coordinate.js\").Coordinate} anchor The rotation center.\n   * @api\n   */\n  rotate(angle, anchor) {\n    const flatCoordinates = this.getFlatCoordinates();\n    if (flatCoordinates) {\n      const stride = this.getStride();\n      rotate(\n        flatCoordinates,\n        0,\n        flatCoordinates.length,\n        stride,\n        angle,\n        anchor,\n        flatCoordinates\n      );\n      this.changed();\n    }\n  }\n\n  /**\n   * Scale the geometry (with an optional origin).  This modifies the geometry\n   * coordinates in place.\n   * @param {number} sx The scaling factor in the x-direction.\n   * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).\n   * @param {import(\"../coordinate.js\").Coordinate} [anchor] The scale origin (defaults to the center\n   *     of the geometry extent).\n   * @api\n   */\n  scale(sx, sy, anchor) {\n    if (sy === undefined) {\n      sy = sx;\n    }\n    if (!anchor) {\n      anchor = getCenter(this.getExtent());\n    }\n    const flatCoordinates = this.getFlatCoordinates();\n    if (flatCoordinates) {\n      const stride = this.getStride();\n      scale(\n        flatCoordinates,\n        0,\n        flatCoordinates.length,\n        stride,\n        sx,\n        sy,\n        anchor,\n        flatCoordinates\n      );\n      this.changed();\n    }\n  }\n\n  /**\n   * Translate the geometry.  This modifies the geometry coordinates in place.  If\n   * instead you want a new geometry, first `clone()` this geometry.\n   * @param {number} deltaX Delta X.\n   * @param {number} deltaY Delta Y.\n   * @api\n   */\n  translate(deltaX, deltaY) {\n    const flatCoordinates = this.getFlatCoordinates();\n    if (flatCoordinates) {\n      const stride = this.getStride();\n      translate(\n        flatCoordinates,\n        0,\n        flatCoordinates.length,\n        stride,\n        deltaX,\n        deltaY,\n        flatCoordinates\n      );\n      this.changed();\n    }\n  }\n}\n\n/**\n * @param {number} stride Stride.\n * @return {import(\"./Geometry.js\").GeometryLayout} layout Layout.\n */\nfunction getLayoutForStride(stride) {\n  let layout;\n  if (stride == 2) {\n    layout = 'XY';\n  } else if (stride == 3) {\n    layout = 'XYZ';\n  } else if (stride == 4) {\n    layout = 'XYZM';\n  }\n  return /** @type {import(\"./Geometry.js\").GeometryLayout} */ (layout);\n}\n\n/**\n * @param {import(\"./Geometry.js\").GeometryLayout} layout Layout.\n * @return {number} Stride.\n */\nexport function getStrideForLayout(layout) {\n  let stride;\n  if (layout == 'XY') {\n    stride = 2;\n  } else if (layout == 'XYZ' || layout == 'XYM') {\n    stride = 3;\n  } else if (layout == 'XYZM') {\n    stride = 4;\n  }\n  return /** @type {number} */ (stride);\n}\n\n/**\n * @param {SimpleGeometry} simpleGeometry Simple geometry.\n * @param {import(\"../transform.js\").Transform} transform Transform.\n * @param {Array<number>} [dest] Destination.\n * @return {Array<number>} Transformed flat coordinates.\n */\nexport function transformGeom2D(simpleGeometry, transform, dest) {\n  const flatCoordinates = simpleGeometry.getFlatCoordinates();\n  if (!flatCoordinates) {\n    return null;\n  }\n  const stride = simpleGeometry.getStride();\n  return transform2D(\n    flatCoordinates,\n    0,\n    flatCoordinates.length,\n    stride,\n    transform,\n    dest\n  );\n}\n\nexport default SimpleGeometry;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}