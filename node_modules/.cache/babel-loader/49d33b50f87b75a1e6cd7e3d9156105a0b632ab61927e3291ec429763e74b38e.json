{"ast":null,"code":"import _classCallCheck from \"/home/jay/Downloads/major/my-app/gis/web-gis/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/jay/Downloads/major/my-app/gis/web-gis/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"/home/jay/Downloads/major/my-app/gis/web-gis/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"/home/jay/Downloads/major/my-app/gis/web-gis/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/home/jay/Downloads/major/my-app/gis/web-gis/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\n/**\n * @module ol/layer/Graticule\n */\nimport Collection from '../Collection.js';\nimport EventType from '../render/EventType.js';\nimport Feature from '../Feature.js';\nimport Fill from '../style/Fill.js';\nimport LineString from '../geom/LineString.js';\nimport Point from '../geom/Point.js';\nimport Stroke from '../style/Stroke.js';\nimport Style from '../style/Style.js';\nimport Text from '../style/Text.js';\nimport VectorLayer from './Vector.js';\nimport VectorSource from '../source/Vector.js';\nimport { applyTransform, approximatelyEquals, containsCoordinate, containsExtent, equals, getCenter, getIntersection, getWidth, intersects, isEmpty, wrapX as wrapExtentX } from '../extent.js';\nimport { clamp } from '../math.js';\nimport { degreesToStringHDMS } from '../coordinate.js';\nimport { equivalent as equivalentProjection, get as getProjection, getTransform } from '../proj.js';\nimport { getVectorContext } from '../render.js';\nimport { meridian, parallel } from '../geom/flat/geodesic.js';\n\n/**\n * @type {Stroke}\n * @private\n * @const\n */\nvar DEFAULT_STROKE_STYLE = new Stroke({\n  color: 'rgba(0,0,0,0.2)'\n});\n\n/**\n * @type {Array<number>}\n * @private\n */\nvar INTERVALS = [90, 45, 30, 20, 10, 5, 2, 1, 30 / 60, 20 / 60, 10 / 60, 5 / 60, 2 / 60, 1 / 60, 30 / 3600, 20 / 3600, 10 / 3600, 5 / 3600, 2 / 3600, 1 / 3600];\n\n/**\n * @typedef {Object} GraticuleLabelDataType\n * @property {Point} geom Geometry.\n * @property {string} text Text.\n */\n\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {number} [maxLines=100] The maximum number of meridians and\n * parallels from the center of the map. The default value of 100 means that at\n * most 200 meridians and 200 parallels will be displayed. The default value is\n * appropriate for conformal projections like Spherical Mercator. If you\n * increase the value, more lines will be drawn and the drawing performance will\n * decrease.\n * @property {Stroke} [strokeStyle] The\n * stroke style to use for drawing the graticule. If not provided, the following stroke will be used:\n * ```js\n * new Stroke({\n *   color: 'rgba(0, 0, 0, 0.2)' // a not fully opaque black\n * });\n * ```\n * @property {number} [targetSize=100] The target size of the graticule cells,\n * in pixels.\n * @property {boolean} [showLabels=false] Render a label with the respective\n * latitude/longitude for each graticule line.\n * @property {function(number):string} [lonLabelFormatter] Label formatter for\n * longitudes. This function is called with the longitude as argument, and\n * should return a formatted string representing the longitude. By default,\n * labels are formatted as degrees, minutes, seconds and hemisphere.\n * @property {function(number):string} [latLabelFormatter] Label formatter for\n * latitudes. This function is called with the latitude as argument, and\n * should return a formatted string representing the latitude. By default,\n * labels are formatted as degrees, minutes, seconds and hemisphere.\n * @property {number} [lonLabelPosition=0] Longitude label position in fractions\n * (0..1) of view extent. 0 means at the bottom of the viewport, 1 means at the\n * top.\n * @property {number} [latLabelPosition=1] Latitude label position in fractions\n * (0..1) of view extent. 0 means at the left of the viewport, 1 means at the\n * right.\n * @property {Text} [lonLabelStyle] Longitude label text\n * style. If not provided, the following style will be used:\n * ```js\n * new Text({\n *   font: '12px Calibri,sans-serif',\n *   textBaseline: 'bottom',\n *   fill: new Fill({\n *     color: 'rgba(0,0,0,1)'\n *   }),\n *   stroke: new Stroke({\n *     color: 'rgba(255,255,255,1)',\n *     width: 3\n *   })\n * });\n * ```\n * Note that the default's `textBaseline` configuration will not work well for\n * `lonLabelPosition` configurations that position labels close to the top of\n * the viewport.\n * @property {Text} [latLabelStyle] Latitude label text style.\n * If not provided, the following style will be used:\n * ```js\n * new Text({\n *   font: '12px Calibri,sans-serif',\n *   textAlign: 'end',\n *   fill: new Fill({\n *     color: 'rgba(0,0,0,1)'\n *   }),\n *   stroke: Stroke({\n *     color: 'rgba(255,255,255,1)',\n *     width: 3\n *   })\n * });\n * ```\n * Note that the default's `textAlign` configuration will not work well for\n * `latLabelPosition` configurations that position labels close to the left of\n * the viewport.\n * @property {Array<number>} [intervals=[90, 45, 30, 20, 10, 5, 2, 1, 30/60, 20/60, 10/60, 5/60, 2/60, 1/60, 30/3600, 20/3600, 10/3600, 5/3600, 2/3600, 1/3600]]\n * Intervals (in degrees) for the graticule. Example to limit graticules to 30 and 10 degrees intervals:\n * ```js\n * [30, 10]\n * ```\n * @property {boolean} [wrapX=true] Whether to repeat the graticule horizontally.\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\n */\n\n/**\n * @classdesc\n * Layer that renders a grid for a coordinate system (currently only EPSG:4326 is supported).\n * Note that the view projection must define both extent and worldExtent.\n *\n * @fires import(\"../render/Event.js\").RenderEvent\n * @extends {VectorLayer<import(\"../source/Vector.js\").default>}\n * @api\n */\nvar Graticule = /*#__PURE__*/function (_VectorLayer) {\n  _inherits(Graticule, _VectorLayer);\n  var _super = _createSuper(Graticule);\n  /**\n   * @param {Options} [options] Options.\n   */\n  function Graticule(options) {\n    var _this;\n    _classCallCheck(this, Graticule);\n    options = options ? options : {};\n    var baseOptions = Object.assign({\n      updateWhileAnimating: true,\n      updateWhileInteracting: true,\n      renderBuffer: 0\n    }, options);\n    delete baseOptions.maxLines;\n    delete baseOptions.strokeStyle;\n    delete baseOptions.targetSize;\n    delete baseOptions.showLabels;\n    delete baseOptions.lonLabelFormatter;\n    delete baseOptions.latLabelFormatter;\n    delete baseOptions.lonLabelPosition;\n    delete baseOptions.latLabelPosition;\n    delete baseOptions.lonLabelStyle;\n    delete baseOptions.latLabelStyle;\n    delete baseOptions.intervals;\n    _this = _super.call(this, baseOptions);\n\n    /**\n     * @type {import(\"../proj/Projection.js\").default}\n     */\n    _this.projection_ = null;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    _this.maxLat_ = Infinity;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    _this.maxLon_ = Infinity;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    _this.minLat_ = -Infinity;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    _this.minLon_ = -Infinity;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    _this.maxX_ = Infinity;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    _this.maxY_ = Infinity;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    _this.minX_ = -Infinity;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    _this.minY_ = -Infinity;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    _this.targetSize_ = options.targetSize !== undefined ? options.targetSize : 100;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    _this.maxLines_ = options.maxLines !== undefined ? options.maxLines : 100;\n\n    /**\n     * @type {Array<LineString>}\n     * @private\n     */\n    _this.meridians_ = [];\n\n    /**\n     * @type {Array<LineString>}\n     * @private\n     */\n    _this.parallels_ = [];\n\n    /**\n     * @type {Stroke}\n     * @private\n     */\n    _this.strokeStyle_ = options.strokeStyle !== undefined ? options.strokeStyle : DEFAULT_STROKE_STYLE;\n\n    /**\n     * @type {import(\"../proj.js\").TransformFunction|undefined}\n     * @private\n     */\n    _this.fromLonLatTransform_ = undefined;\n\n    /**\n     * @type {import(\"../proj.js\").TransformFunction|undefined}\n     * @private\n     */\n    _this.toLonLatTransform_ = undefined;\n\n    /**\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @private\n     */\n    _this.projectionCenterLonLat_ = null;\n\n    /**\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @private\n     */\n    _this.bottomLeft_ = null;\n\n    /**\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @private\n     */\n    _this.bottomRight_ = null;\n\n    /**\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @private\n     */\n    _this.topLeft_ = null;\n\n    /**\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @private\n     */\n    _this.topRight_ = null;\n\n    /**\n     * @type {Array<GraticuleLabelDataType>}\n     * @private\n     */\n    _this.meridiansLabels_ = null;\n\n    /**\n     * @type {Array<GraticuleLabelDataType>}\n     * @private\n     */\n    _this.parallelsLabels_ = null;\n    if (options.showLabels) {\n      /**\n       * @type {null|function(number):string}\n       * @private\n       */\n      _this.lonLabelFormatter_ = options.lonLabelFormatter == undefined ? degreesToStringHDMS.bind(_assertThisInitialized(_this), 'EW') : options.lonLabelFormatter;\n\n      /**\n       * @type {function(number):string}\n       * @private\n       */\n      _this.latLabelFormatter_ = options.latLabelFormatter == undefined ? degreesToStringHDMS.bind(_assertThisInitialized(_this), 'NS') : options.latLabelFormatter;\n\n      /**\n       * Longitude label position in fractions (0..1) of view extent. 0 means\n       * bottom, 1 means top.\n       * @type {number}\n       * @private\n       */\n      _this.lonLabelPosition_ = options.lonLabelPosition == undefined ? 0 : options.lonLabelPosition;\n\n      /**\n       * Latitude Label position in fractions (0..1) of view extent. 0 means left, 1\n       * means right.\n       * @type {number}\n       * @private\n       */\n      _this.latLabelPosition_ = options.latLabelPosition == undefined ? 1 : options.latLabelPosition;\n\n      /**\n       * @type {Style}\n       * @private\n       */\n      _this.lonLabelStyleBase_ = new Style({\n        text: options.lonLabelStyle !== undefined ? options.lonLabelStyle.clone() : new Text({\n          font: '12px Calibri,sans-serif',\n          textBaseline: 'bottom',\n          fill: new Fill({\n            color: 'rgba(0,0,0,1)'\n          }),\n          stroke: new Stroke({\n            color: 'rgba(255,255,255,1)',\n            width: 3\n          })\n        })\n      });\n\n      /**\n       * @private\n       * @param {import(\"../Feature\").default} feature Feature\n       * @return {Style} style\n       */\n      _this.lonLabelStyle_ = function (feature) {\n        var label = feature.get('graticule_label');\n        _this.lonLabelStyleBase_.getText().setText(label);\n        return _this.lonLabelStyleBase_;\n      };\n\n      /**\n       * @type {Style}\n       * @private\n       */\n      _this.latLabelStyleBase_ = new Style({\n        text: options.latLabelStyle !== undefined ? options.latLabelStyle.clone() : new Text({\n          font: '12px Calibri,sans-serif',\n          textAlign: 'right',\n          fill: new Fill({\n            color: 'rgba(0,0,0,1)'\n          }),\n          stroke: new Stroke({\n            color: 'rgba(255,255,255,1)',\n            width: 3\n          })\n        })\n      });\n\n      /**\n       * @private\n       * @param {import(\"../Feature\").default} feature Feature\n       * @return {Style} style\n       */\n      _this.latLabelStyle_ = function (feature) {\n        var label = feature.get('graticule_label');\n        _this.latLabelStyleBase_.getText().setText(label);\n        return _this.latLabelStyleBase_;\n      };\n      _this.meridiansLabels_ = [];\n      _this.parallelsLabels_ = [];\n      _this.addEventListener(EventType.POSTRENDER, _this.drawLabels_.bind(_assertThisInitialized(_this)));\n    }\n\n    /**\n     * @type {Array<number>}\n     * @private\n     */\n    _this.intervals_ = options.intervals !== undefined ? options.intervals : INTERVALS;\n\n    // use a source with a custom loader for lines & text\n    _this.setSource(new VectorSource({\n      loader: _this.loaderFunction.bind(_assertThisInitialized(_this)),\n      strategy: _this.strategyFunction.bind(_assertThisInitialized(_this)),\n      features: new Collection(),\n      overlaps: false,\n      useSpatialIndex: false,\n      wrapX: options.wrapX\n    }));\n\n    /**\n     * feature pool to use when updating graticule\n     * @type {Array<Feature>}\n     * @private\n     */\n    _this.featurePool_ = [];\n\n    /**\n     * @type {Style}\n     * @private\n     */\n    _this.lineStyle_ = new Style({\n      stroke: _this.strokeStyle_\n    });\n\n    /**\n     * @type {?import(\"../extent.js\").Extent}\n     * @private\n     */\n    _this.loadedExtent_ = null;\n\n    /**\n     * @type {?import(\"../extent.js\").Extent}\n     * @private\n     */\n    _this.renderedExtent_ = null;\n\n    /**\n     * @type {?number}\n     * @private\n     */\n    _this.renderedResolution_ = null;\n    _this.setRenderOrder(null);\n    return _this;\n  }\n\n  /**\n   * Strategy function for loading features based on the view's extent and\n   * resolution.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} resolution Resolution.\n   * @return {Array<import(\"../extent.js\").Extent>} Extents.\n   */\n  _createClass(Graticule, [{\n    key: \"strategyFunction\",\n    value: function strategyFunction(extent, resolution) {\n      // extents may be passed in different worlds, to avoid endless loop we use only one\n      var realWorldExtent = extent.slice();\n      if (this.projection_ && this.getSource().getWrapX()) {\n        wrapExtentX(realWorldExtent, this.projection_);\n      }\n      if (this.loadedExtent_) {\n        if (approximatelyEquals(this.loadedExtent_, realWorldExtent, resolution)) {\n          // make sure result is exactly equal to previous extent\n          realWorldExtent = this.loadedExtent_.slice();\n        } else {\n          // we should not keep track of loaded extents\n          this.getSource().removeLoadedExtent(this.loadedExtent_);\n        }\n      }\n      return [realWorldExtent];\n    }\n\n    /**\n     * Update geometries in the source based on current view\n     * @param {import(\"../extent\").Extent} extent Extent\n     * @param {number} resolution Resolution\n     * @param {import(\"../proj/Projection.js\").default} projection Projection\n     */\n  }, {\n    key: \"loaderFunction\",\n    value: function loaderFunction(extent, resolution, projection) {\n      this.loadedExtent_ = extent;\n      var source = this.getSource();\n\n      // only consider the intersection between our own extent & the requested one\n      var layerExtent = this.getExtent() || [-Infinity, -Infinity, Infinity, Infinity];\n      var renderExtent = getIntersection(layerExtent, extent);\n      if (this.renderedExtent_ && equals(this.renderedExtent_, renderExtent) && this.renderedResolution_ === resolution) {\n        return;\n      }\n      this.renderedExtent_ = renderExtent;\n      this.renderedResolution_ = resolution;\n\n      // bail out if nothing to render\n      if (isEmpty(renderExtent)) {\n        return;\n      }\n\n      // update projection info\n      var center = getCenter(renderExtent);\n      var squaredTolerance = resolution * resolution / 4;\n      var updateProjectionInfo = !this.projection_ || !equivalentProjection(this.projection_, projection);\n      if (updateProjectionInfo) {\n        this.updateProjectionInfo_(projection);\n      }\n      this.createGraticule_(renderExtent, center, resolution, squaredTolerance);\n\n      // first make sure we have enough features in the pool\n      var featureCount = this.meridians_.length + this.parallels_.length;\n      if (this.meridiansLabels_) {\n        featureCount += this.meridians_.length;\n      }\n      if (this.parallelsLabels_) {\n        featureCount += this.parallels_.length;\n      }\n      var feature;\n      while (featureCount > this.featurePool_.length) {\n        feature = new Feature();\n        this.featurePool_.push(feature);\n      }\n      var featuresColl = source.getFeaturesCollection();\n      featuresColl.clear();\n      var poolIndex = 0;\n\n      // add features for the lines & labels\n      var i, l;\n      for (i = 0, l = this.meridians_.length; i < l; ++i) {\n        feature = this.featurePool_[poolIndex++];\n        feature.setGeometry(this.meridians_[i]);\n        feature.setStyle(this.lineStyle_);\n        featuresColl.push(feature);\n      }\n      for (i = 0, l = this.parallels_.length; i < l; ++i) {\n        feature = this.featurePool_[poolIndex++];\n        feature.setGeometry(this.parallels_[i]);\n        feature.setStyle(this.lineStyle_);\n        featuresColl.push(feature);\n      }\n    }\n\n    /**\n     * @param {number} lon Longitude.\n     * @param {number} minLat Minimal latitude.\n     * @param {number} maxLat Maximal latitude.\n     * @param {number} squaredTolerance Squared tolerance.\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @param {number} index Index.\n     * @return {number} Index.\n     * @private\n     */\n  }, {\n    key: \"addMeridian_\",\n    value: function addMeridian_(lon, minLat, maxLat, squaredTolerance, extent, index) {\n      var lineString = this.getMeridian_(lon, minLat, maxLat, squaredTolerance, index);\n      if (intersects(lineString.getExtent(), extent)) {\n        if (this.meridiansLabels_) {\n          var text = this.lonLabelFormatter_(lon);\n          if (index in this.meridiansLabels_) {\n            this.meridiansLabels_[index].text = text;\n          } else {\n            this.meridiansLabels_[index] = {\n              geom: new Point([]),\n              text: text\n            };\n          }\n        }\n        this.meridians_[index++] = lineString;\n      }\n      return index;\n    }\n\n    /**\n     * @param {number} lat Latitude.\n     * @param {number} minLon Minimal longitude.\n     * @param {number} maxLon Maximal longitude.\n     * @param {number} squaredTolerance Squared tolerance.\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @param {number} index Index.\n     * @return {number} Index.\n     * @private\n     */\n  }, {\n    key: \"addParallel_\",\n    value: function addParallel_(lat, minLon, maxLon, squaredTolerance, extent, index) {\n      var lineString = this.getParallel_(lat, minLon, maxLon, squaredTolerance, index);\n      if (intersects(lineString.getExtent(), extent)) {\n        if (this.parallelsLabels_) {\n          var text = this.latLabelFormatter_(lat);\n          if (index in this.parallelsLabels_) {\n            this.parallelsLabels_[index].text = text;\n          } else {\n            this.parallelsLabels_[index] = {\n              geom: new Point([]),\n              text: text\n            };\n          }\n        }\n        this.parallels_[index++] = lineString;\n      }\n      return index;\n    }\n\n    /**\n     * @param {import(\"../render/Event.js\").default} event Render event.\n     * @private\n     */\n  }, {\n    key: \"drawLabels_\",\n    value: function drawLabels_(event) {\n      var rotation = event.frameState.viewState.rotation;\n      var resolution = event.frameState.viewState.resolution;\n      var size = event.frameState.size;\n      var extent = event.frameState.extent;\n      var rotationCenter = getCenter(extent);\n      var rotationExtent = extent;\n      if (rotation) {\n        var unrotatedWidth = size[0] * resolution;\n        var unrotatedHeight = size[1] * resolution;\n        rotationExtent = [rotationCenter[0] - unrotatedWidth / 2, rotationCenter[1] - unrotatedHeight / 2, rotationCenter[0] + unrotatedWidth / 2, rotationCenter[1] + unrotatedHeight / 2];\n      }\n      var startWorld = 0;\n      var endWorld = 0;\n      var labelsAtStart = this.latLabelPosition_ < 0.5;\n      var projectionExtent = this.projection_.getExtent();\n      var worldWidth = getWidth(projectionExtent);\n      if (this.getSource().getWrapX() && this.projection_.canWrapX() && !containsExtent(projectionExtent, extent)) {\n        startWorld = Math.floor((extent[0] - projectionExtent[0]) / worldWidth);\n        endWorld = Math.ceil((extent[2] - projectionExtent[2]) / worldWidth);\n        var inverted = Math.abs(rotation) > Math.PI / 2;\n        labelsAtStart = labelsAtStart !== inverted;\n      }\n      var vectorContext = getVectorContext(event);\n      for (var world = startWorld; world <= endWorld; ++world) {\n        var poolIndex = this.meridians_.length + this.parallels_.length;\n        var feature = void 0,\n          index = void 0,\n          l = void 0,\n          textPoint = void 0;\n        if (this.meridiansLabels_) {\n          for (index = 0, l = this.meridiansLabels_.length; index < l; ++index) {\n            var lineString = this.meridians_[index];\n            if (!rotation && world === 0) {\n              textPoint = this.getMeridianPoint_(lineString, extent, index);\n            } else {\n              var clone = lineString.clone();\n              clone.translate(world * worldWidth, 0);\n              clone.rotate(-rotation, rotationCenter);\n              textPoint = this.getMeridianPoint_(clone, rotationExtent, index);\n              textPoint.rotate(rotation, rotationCenter);\n            }\n            feature = this.featurePool_[poolIndex++];\n            feature.setGeometry(textPoint);\n            feature.set('graticule_label', this.meridiansLabels_[index].text);\n            vectorContext.drawFeature(feature, this.lonLabelStyle_(feature));\n          }\n        }\n        if (this.parallelsLabels_) {\n          if (world === startWorld && labelsAtStart || world === endWorld && !labelsAtStart) {\n            for (index = 0, l = this.parallels_.length; index < l; ++index) {\n              var _lineString = this.parallels_[index];\n              if (!rotation && world === 0) {\n                textPoint = this.getParallelPoint_(_lineString, extent, index);\n              } else {\n                var _clone = _lineString.clone();\n                _clone.translate(world * worldWidth, 0);\n                _clone.rotate(-rotation, rotationCenter);\n                textPoint = this.getParallelPoint_(_clone, rotationExtent, index);\n                textPoint.rotate(rotation, rotationCenter);\n              }\n              feature = this.featurePool_[poolIndex++];\n              feature.setGeometry(textPoint);\n              feature.set('graticule_label', this.parallelsLabels_[index].text);\n              vectorContext.drawFeature(feature, this.latLabelStyle_(feature));\n            }\n          }\n        }\n      }\n    }\n\n    /**\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @param {import(\"../coordinate.js\").Coordinate} center Center.\n     * @param {number} resolution Resolution.\n     * @param {number} squaredTolerance Squared tolerance.\n     * @private\n     */\n  }, {\n    key: \"createGraticule_\",\n    value: function createGraticule_(extent, center, resolution, squaredTolerance) {\n      var interval = this.getInterval_(resolution);\n      if (interval == -1) {\n        this.meridians_.length = 0;\n        this.parallels_.length = 0;\n        if (this.meridiansLabels_) {\n          this.meridiansLabels_.length = 0;\n        }\n        if (this.parallelsLabels_) {\n          this.parallelsLabels_.length = 0;\n        }\n        return;\n      }\n      var wrapX = false;\n      var projectionExtent = this.projection_.getExtent();\n      var worldWidth = getWidth(projectionExtent);\n      if (this.getSource().getWrapX() && this.projection_.canWrapX() && !containsExtent(projectionExtent, extent)) {\n        if (getWidth(extent) >= worldWidth) {\n          extent[0] = projectionExtent[0];\n          extent[2] = projectionExtent[2];\n        } else {\n          wrapX = true;\n        }\n      }\n\n      // Constrain the center to fit into the extent available to the graticule\n\n      var validCenterP = [clamp(center[0], this.minX_, this.maxX_), clamp(center[1], this.minY_, this.maxY_)];\n\n      // Transform the center to lon lat\n      // Some projections may have a void area at the poles\n      // so replace any NaN latitudes with the min or max value closest to a pole\n\n      var centerLonLat = this.toLonLatTransform_(validCenterP);\n      if (isNaN(centerLonLat[1])) {\n        centerLonLat[1] = Math.abs(this.maxLat_) >= Math.abs(this.minLat_) ? this.maxLat_ : this.minLat_;\n      }\n      var centerLon = clamp(centerLonLat[0], this.minLon_, this.maxLon_);\n      var centerLat = clamp(centerLonLat[1], this.minLat_, this.maxLat_);\n      var maxLines = this.maxLines_;\n      var cnt, idx, lat, lon;\n\n      // Limit the extent to fit into the extent available to the graticule\n\n      var validExtentP = extent;\n      if (!wrapX) {\n        validExtentP = [clamp(extent[0], this.minX_, this.maxX_), clamp(extent[1], this.minY_, this.maxY_), clamp(extent[2], this.minX_, this.maxX_), clamp(extent[3], this.minY_, this.maxY_)];\n      }\n\n      // Transform the extent to get the lon lat ranges for the edges of the extent\n\n      var validExtent = applyTransform(validExtentP, this.toLonLatTransform_, undefined, 8);\n      var maxLat = validExtent[3];\n      var maxLon = validExtent[2];\n      var minLat = validExtent[1];\n      var minLon = validExtent[0];\n      if (!wrapX) {\n        // Check if extremities of the world extent lie inside the extent\n        // (for example the pole in a polar projection)\n        // and extend the extent as appropriate\n\n        if (containsCoordinate(validExtentP, this.bottomLeft_)) {\n          minLon = this.minLon_;\n          minLat = this.minLat_;\n        }\n        if (containsCoordinate(validExtentP, this.bottomRight_)) {\n          maxLon = this.maxLon_;\n          minLat = this.minLat_;\n        }\n        if (containsCoordinate(validExtentP, this.topLeft_)) {\n          minLon = this.minLon_;\n          maxLat = this.maxLat_;\n        }\n        if (containsCoordinate(validExtentP, this.topRight_)) {\n          maxLon = this.maxLon_;\n          maxLat = this.maxLat_;\n        }\n\n        // The transformed center may also extend the lon lat ranges used for rendering\n\n        maxLat = clamp(maxLat, centerLat, this.maxLat_);\n        maxLon = clamp(maxLon, centerLon, this.maxLon_);\n        minLat = clamp(minLat, this.minLat_, centerLat);\n        minLon = clamp(minLon, this.minLon_, centerLon);\n      }\n\n      // Create meridians\n\n      centerLon = Math.floor(centerLon / interval) * interval;\n      lon = clamp(centerLon, this.minLon_, this.maxLon_);\n      idx = this.addMeridian_(lon, minLat, maxLat, squaredTolerance, extent, 0);\n      cnt = 0;\n      if (wrapX) {\n        while ((lon -= interval) >= minLon && cnt++ < maxLines) {\n          idx = this.addMeridian_(lon, minLat, maxLat, squaredTolerance, extent, idx);\n        }\n      } else {\n        while (lon != this.minLon_ && cnt++ < maxLines) {\n          lon = Math.max(lon - interval, this.minLon_);\n          idx = this.addMeridian_(lon, minLat, maxLat, squaredTolerance, extent, idx);\n        }\n      }\n      lon = clamp(centerLon, this.minLon_, this.maxLon_);\n      cnt = 0;\n      if (wrapX) {\n        while ((lon += interval) <= maxLon && cnt++ < maxLines) {\n          idx = this.addMeridian_(lon, minLat, maxLat, squaredTolerance, extent, idx);\n        }\n      } else {\n        while (lon != this.maxLon_ && cnt++ < maxLines) {\n          lon = Math.min(lon + interval, this.maxLon_);\n          idx = this.addMeridian_(lon, minLat, maxLat, squaredTolerance, extent, idx);\n        }\n      }\n      this.meridians_.length = idx;\n      if (this.meridiansLabels_) {\n        this.meridiansLabels_.length = idx;\n      }\n\n      // Create parallels\n\n      centerLat = Math.floor(centerLat / interval) * interval;\n      lat = clamp(centerLat, this.minLat_, this.maxLat_);\n      idx = this.addParallel_(lat, minLon, maxLon, squaredTolerance, extent, 0);\n      cnt = 0;\n      while (lat != this.minLat_ && cnt++ < maxLines) {\n        lat = Math.max(lat - interval, this.minLat_);\n        idx = this.addParallel_(lat, minLon, maxLon, squaredTolerance, extent, idx);\n      }\n      lat = clamp(centerLat, this.minLat_, this.maxLat_);\n      cnt = 0;\n      while (lat != this.maxLat_ && cnt++ < maxLines) {\n        lat = Math.min(lat + interval, this.maxLat_);\n        idx = this.addParallel_(lat, minLon, maxLon, squaredTolerance, extent, idx);\n      }\n      this.parallels_.length = idx;\n      if (this.parallelsLabels_) {\n        this.parallelsLabels_.length = idx;\n      }\n    }\n\n    /**\n     * @param {number} resolution Resolution.\n     * @return {number} The interval in degrees.\n     * @private\n     */\n  }, {\n    key: \"getInterval_\",\n    value: function getInterval_(resolution) {\n      var centerLon = this.projectionCenterLonLat_[0];\n      var centerLat = this.projectionCenterLonLat_[1];\n      var interval = -1;\n      var target = Math.pow(this.targetSize_ * resolution, 2);\n      /** @type {Array<number>} **/\n      var p1 = [];\n      /** @type {Array<number>} **/\n      var p2 = [];\n      for (var i = 0, ii = this.intervals_.length; i < ii; ++i) {\n        var delta = clamp(this.intervals_[i] / 2, 0, 90);\n        // Don't attempt to transform latitudes beyond the poles!\n        var clampedLat = clamp(centerLat, -90 + delta, 90 - delta);\n        p1[0] = centerLon - delta;\n        p1[1] = clampedLat - delta;\n        p2[0] = centerLon + delta;\n        p2[1] = clampedLat + delta;\n        this.fromLonLatTransform_(p1, p1);\n        this.fromLonLatTransform_(p2, p2);\n        var dist = Math.pow(p2[0] - p1[0], 2) + Math.pow(p2[1] - p1[1], 2);\n        if (dist <= target) {\n          break;\n        }\n        interval = this.intervals_[i];\n      }\n      return interval;\n    }\n\n    /**\n     * @param {number} lon Longitude.\n     * @param {number} minLat Minimal latitude.\n     * @param {number} maxLat Maximal latitude.\n     * @param {number} squaredTolerance Squared tolerance.\n     * @return {LineString} The meridian line string.\n     * @param {number} index Index.\n     * @private\n     */\n  }, {\n    key: \"getMeridian_\",\n    value: function getMeridian_(lon, minLat, maxLat, squaredTolerance, index) {\n      var flatCoordinates = meridian(lon, minLat, maxLat, this.projection_, squaredTolerance);\n      var lineString = this.meridians_[index];\n      if (!lineString) {\n        lineString = new LineString(flatCoordinates, 'XY');\n        this.meridians_[index] = lineString;\n      } else {\n        lineString.setFlatCoordinates('XY', flatCoordinates);\n        lineString.changed();\n      }\n      return lineString;\n    }\n\n    /**\n     * @param {LineString} lineString Meridian\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @param {number} index Index.\n     * @return {Point} Meridian point.\n     * @private\n     */\n  }, {\n    key: \"getMeridianPoint_\",\n    value: function getMeridianPoint_(lineString, extent, index) {\n      var flatCoordinates = lineString.getFlatCoordinates();\n      var bottom = 1;\n      var top = flatCoordinates.length - 1;\n      if (flatCoordinates[bottom] > flatCoordinates[top]) {\n        bottom = top;\n        top = 1;\n      }\n      var clampedBottom = Math.max(extent[1], flatCoordinates[bottom]);\n      var clampedTop = Math.min(extent[3], flatCoordinates[top]);\n      var lat = clamp(extent[1] + Math.abs(extent[1] - extent[3]) * this.lonLabelPosition_, clampedBottom, clampedTop);\n      var coordinate0 = flatCoordinates[bottom - 1] + (flatCoordinates[top - 1] - flatCoordinates[bottom - 1]) * (lat - flatCoordinates[bottom]) / (flatCoordinates[top] - flatCoordinates[bottom]);\n      var coordinate = [coordinate0, lat];\n      var point = this.meridiansLabels_[index].geom;\n      point.setCoordinates(coordinate);\n      return point;\n    }\n\n    /**\n     * Get the list of meridians.  Meridians are lines of equal longitude.\n     * @return {Array<LineString>} The meridians.\n     * @api\n     */\n  }, {\n    key: \"getMeridians\",\n    value: function getMeridians() {\n      return this.meridians_;\n    }\n\n    /**\n     * @param {number} lat Latitude.\n     * @param {number} minLon Minimal longitude.\n     * @param {number} maxLon Maximal longitude.\n     * @param {number} squaredTolerance Squared tolerance.\n     * @return {LineString} The parallel line string.\n     * @param {number} index Index.\n     * @private\n     */\n  }, {\n    key: \"getParallel_\",\n    value: function getParallel_(lat, minLon, maxLon, squaredTolerance, index) {\n      var flatCoordinates = parallel(lat, minLon, maxLon, this.projection_, squaredTolerance);\n      var lineString = this.parallels_[index];\n      if (!lineString) {\n        lineString = new LineString(flatCoordinates, 'XY');\n      } else {\n        lineString.setFlatCoordinates('XY', flatCoordinates);\n        lineString.changed();\n      }\n      return lineString;\n    }\n\n    /**\n     * @param {LineString} lineString Parallels.\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @param {number} index Index.\n     * @return {Point} Parallel point.\n     * @private\n     */\n  }, {\n    key: \"getParallelPoint_\",\n    value: function getParallelPoint_(lineString, extent, index) {\n      var flatCoordinates = lineString.getFlatCoordinates();\n      var left = 0;\n      var right = flatCoordinates.length - 2;\n      if (flatCoordinates[left] > flatCoordinates[right]) {\n        left = right;\n        right = 0;\n      }\n      var clampedLeft = Math.max(extent[0], flatCoordinates[left]);\n      var clampedRight = Math.min(extent[2], flatCoordinates[right]);\n      var lon = clamp(extent[0] + Math.abs(extent[0] - extent[2]) * this.latLabelPosition_, clampedLeft, clampedRight);\n      var coordinate1 = flatCoordinates[left + 1] + (flatCoordinates[right + 1] - flatCoordinates[left + 1]) * (lon - flatCoordinates[left]) / (flatCoordinates[right] - flatCoordinates[left]);\n      var coordinate = [lon, coordinate1];\n      var point = this.parallelsLabels_[index].geom;\n      point.setCoordinates(coordinate);\n      return point;\n    }\n\n    /**\n     * Get the list of parallels.  Parallels are lines of equal latitude.\n     * @return {Array<LineString>} The parallels.\n     * @api\n     */\n  }, {\n    key: \"getParallels\",\n    value: function getParallels() {\n      return this.parallels_;\n    }\n\n    /**\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     * @private\n     */\n  }, {\n    key: \"updateProjectionInfo_\",\n    value: function updateProjectionInfo_(projection) {\n      var epsg4326Projection = getProjection('EPSG:4326');\n      var worldExtent = projection.getWorldExtent();\n      this.maxLat_ = worldExtent[3];\n      this.maxLon_ = worldExtent[2];\n      this.minLat_ = worldExtent[1];\n      this.minLon_ = worldExtent[0];\n\n      // If the world extent crosses the dateline define a custom transform to\n      // return longitudes which wrap the dateline\n\n      var toLonLatTransform = getTransform(projection, epsg4326Projection);\n      if (this.minLon_ < this.maxLon_) {\n        this.toLonLatTransform_ = toLonLatTransform;\n      } else {\n        var split = this.minLon_ + this.maxLon_ / 2;\n        this.maxLon_ += 360;\n        this.toLonLatTransform_ = function (coordinates, output, dimension) {\n          dimension = dimension || 2;\n          var lonLatCoordinates = toLonLatTransform(coordinates, output, dimension);\n          for (var i = 0, l = lonLatCoordinates.length; i < l; i += dimension) {\n            if (lonLatCoordinates[i] < split) {\n              lonLatCoordinates[i] += 360;\n            }\n          }\n          return lonLatCoordinates;\n        };\n      }\n\n      // Transform the extent to get the limits of the view projection extent\n      // which should be available to the graticule\n\n      this.fromLonLatTransform_ = getTransform(epsg4326Projection, projection);\n      var worldExtentP = applyTransform([this.minLon_, this.minLat_, this.maxLon_, this.maxLat_], this.fromLonLatTransform_, undefined, 8);\n      this.minX_ = worldExtentP[0];\n      this.maxX_ = worldExtentP[2];\n      this.minY_ = worldExtentP[1];\n      this.maxY_ = worldExtentP[3];\n\n      // Determine the view projection coordinates of the extremities of the world extent\n      // as these may lie inside a view extent (for example the pole in a polar projection)\n\n      this.bottomLeft_ = this.fromLonLatTransform_([this.minLon_, this.minLat_]);\n      this.bottomRight_ = this.fromLonLatTransform_([this.maxLon_, this.minLat_]);\n      this.topLeft_ = this.fromLonLatTransform_([this.minLon_, this.maxLat_]);\n      this.topRight_ = this.fromLonLatTransform_([this.maxLon_, this.maxLat_]);\n\n      // Transform the projection center to lon lat\n      // Some projections may have a void area at the poles\n      // so replace any NaN latitudes with the min or max value closest to a pole\n\n      this.projectionCenterLonLat_ = this.toLonLatTransform_(getCenter(projection.getExtent()));\n      if (isNaN(this.projectionCenterLonLat_[1])) {\n        this.projectionCenterLonLat_[1] = Math.abs(this.maxLat_) >= Math.abs(this.minLat_) ? this.maxLat_ : this.minLat_;\n      }\n      this.projection_ = projection;\n    }\n  }]);\n  return Graticule;\n}(VectorLayer);\nexport default Graticule;","map":{"version":3,"names":["Collection","EventType","Feature","Fill","LineString","Point","Stroke","Style","Text","VectorLayer","VectorSource","applyTransform","approximatelyEquals","containsCoordinate","containsExtent","equals","getCenter","getIntersection","getWidth","intersects","isEmpty","wrapX","wrapExtentX","clamp","degreesToStringHDMS","equivalent","equivalentProjection","get","getProjection","getTransform","getVectorContext","meridian","parallel","DEFAULT_STROKE_STYLE","color","INTERVALS","Graticule","_VectorLayer","_inherits","_super","_createSuper","options","_this","_classCallCheck","baseOptions","Object","assign","updateWhileAnimating","updateWhileInteracting","renderBuffer","maxLines","strokeStyle","targetSize","showLabels","lonLabelFormatter","latLabelFormatter","lonLabelPosition","latLabelPosition","lonLabelStyle","latLabelStyle","intervals","call","projection_","maxLat_","Infinity","maxLon_","minLat_","minLon_","maxX_","maxY_","minX_","minY_","targetSize_","undefined","maxLines_","meridians_","parallels_","strokeStyle_","fromLonLatTransform_","toLonLatTransform_","projectionCenterLonLat_","bottomLeft_","bottomRight_","topLeft_","topRight_","meridiansLabels_","parallelsLabels_","lonLabelFormatter_","bind","_assertThisInitialized","latLabelFormatter_","lonLabelPosition_","latLabelPosition_","lonLabelStyleBase_","text","clone","font","textBaseline","fill","stroke","width","lonLabelStyle_","feature","label","getText","setText","latLabelStyleBase_","textAlign","latLabelStyle_","addEventListener","POSTRENDER","drawLabels_","intervals_","setSource","loader","loaderFunction","strategy","strategyFunction","features","overlaps","useSpatialIndex","featurePool_","lineStyle_","loadedExtent_","renderedExtent_","renderedResolution_","setRenderOrder","_createClass","key","value","extent","resolution","realWorldExtent","slice","getSource","getWrapX","removeLoadedExtent","projection","source","layerExtent","getExtent","renderExtent","center","squaredTolerance","updateProjectionInfo","updateProjectionInfo_","createGraticule_","featureCount","length","push","featuresColl","getFeaturesCollection","clear","poolIndex","i","l","setGeometry","setStyle","addMeridian_","lon","minLat","maxLat","index","lineString","getMeridian_","geom","addParallel_","lat","minLon","maxLon","getParallel_","event","rotation","frameState","viewState","size","rotationCenter","rotationExtent","unrotatedWidth","unrotatedHeight","startWorld","endWorld","labelsAtStart","projectionExtent","worldWidth","canWrapX","Math","floor","ceil","inverted","abs","PI","vectorContext","world","textPoint","getMeridianPoint_","translate","rotate","set","drawFeature","getParallelPoint_","interval","getInterval_","validCenterP","centerLonLat","isNaN","centerLon","centerLat","cnt","idx","validExtentP","validExtent","max","min","target","pow","p1","p2","ii","delta","clampedLat","dist","flatCoordinates","setFlatCoordinates","changed","getFlatCoordinates","bottom","top","clampedBottom","clampedTop","coordinate0","coordinate","point","setCoordinates","getMeridians","left","right","clampedLeft","clampedRight","coordinate1","getParallels","epsg4326Projection","worldExtent","getWorldExtent","toLonLatTransform","split","coordinates","output","dimension","lonLatCoordinates","worldExtentP"],"sources":["/home/jay/Downloads/major/my-app/gis/web-gis/node_modules/ol/layer/Graticule.js"],"sourcesContent":["/**\n * @module ol/layer/Graticule\n */\nimport Collection from '../Collection.js';\nimport EventType from '../render/EventType.js';\nimport Feature from '../Feature.js';\nimport Fill from '../style/Fill.js';\nimport LineString from '../geom/LineString.js';\nimport Point from '../geom/Point.js';\nimport Stroke from '../style/Stroke.js';\nimport Style from '../style/Style.js';\nimport Text from '../style/Text.js';\nimport VectorLayer from './Vector.js';\nimport VectorSource from '../source/Vector.js';\nimport {\n  applyTransform,\n  approximatelyEquals,\n  containsCoordinate,\n  containsExtent,\n  equals,\n  getCenter,\n  getIntersection,\n  getWidth,\n  intersects,\n  isEmpty,\n  wrapX as wrapExtentX,\n} from '../extent.js';\nimport {clamp} from '../math.js';\nimport {degreesToStringHDMS} from '../coordinate.js';\nimport {\n  equivalent as equivalentProjection,\n  get as getProjection,\n  getTransform,\n} from '../proj.js';\nimport {getVectorContext} from '../render.js';\nimport {meridian, parallel} from '../geom/flat/geodesic.js';\n\n/**\n * @type {Stroke}\n * @private\n * @const\n */\nconst DEFAULT_STROKE_STYLE = new Stroke({\n  color: 'rgba(0,0,0,0.2)',\n});\n\n/**\n * @type {Array<number>}\n * @private\n */\nconst INTERVALS = [\n  90,\n  45,\n  30,\n  20,\n  10,\n  5,\n  2,\n  1,\n  30 / 60,\n  20 / 60,\n  10 / 60,\n  5 / 60,\n  2 / 60,\n  1 / 60,\n  30 / 3600,\n  20 / 3600,\n  10 / 3600,\n  5 / 3600,\n  2 / 3600,\n  1 / 3600,\n];\n\n/**\n * @typedef {Object} GraticuleLabelDataType\n * @property {Point} geom Geometry.\n * @property {string} text Text.\n */\n\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {number} [maxLines=100] The maximum number of meridians and\n * parallels from the center of the map. The default value of 100 means that at\n * most 200 meridians and 200 parallels will be displayed. The default value is\n * appropriate for conformal projections like Spherical Mercator. If you\n * increase the value, more lines will be drawn and the drawing performance will\n * decrease.\n * @property {Stroke} [strokeStyle] The\n * stroke style to use for drawing the graticule. If not provided, the following stroke will be used:\n * ```js\n * new Stroke({\n *   color: 'rgba(0, 0, 0, 0.2)' // a not fully opaque black\n * });\n * ```\n * @property {number} [targetSize=100] The target size of the graticule cells,\n * in pixels.\n * @property {boolean} [showLabels=false] Render a label with the respective\n * latitude/longitude for each graticule line.\n * @property {function(number):string} [lonLabelFormatter] Label formatter for\n * longitudes. This function is called with the longitude as argument, and\n * should return a formatted string representing the longitude. By default,\n * labels are formatted as degrees, minutes, seconds and hemisphere.\n * @property {function(number):string} [latLabelFormatter] Label formatter for\n * latitudes. This function is called with the latitude as argument, and\n * should return a formatted string representing the latitude. By default,\n * labels are formatted as degrees, minutes, seconds and hemisphere.\n * @property {number} [lonLabelPosition=0] Longitude label position in fractions\n * (0..1) of view extent. 0 means at the bottom of the viewport, 1 means at the\n * top.\n * @property {number} [latLabelPosition=1] Latitude label position in fractions\n * (0..1) of view extent. 0 means at the left of the viewport, 1 means at the\n * right.\n * @property {Text} [lonLabelStyle] Longitude label text\n * style. If not provided, the following style will be used:\n * ```js\n * new Text({\n *   font: '12px Calibri,sans-serif',\n *   textBaseline: 'bottom',\n *   fill: new Fill({\n *     color: 'rgba(0,0,0,1)'\n *   }),\n *   stroke: new Stroke({\n *     color: 'rgba(255,255,255,1)',\n *     width: 3\n *   })\n * });\n * ```\n * Note that the default's `textBaseline` configuration will not work well for\n * `lonLabelPosition` configurations that position labels close to the top of\n * the viewport.\n * @property {Text} [latLabelStyle] Latitude label text style.\n * If not provided, the following style will be used:\n * ```js\n * new Text({\n *   font: '12px Calibri,sans-serif',\n *   textAlign: 'end',\n *   fill: new Fill({\n *     color: 'rgba(0,0,0,1)'\n *   }),\n *   stroke: Stroke({\n *     color: 'rgba(255,255,255,1)',\n *     width: 3\n *   })\n * });\n * ```\n * Note that the default's `textAlign` configuration will not work well for\n * `latLabelPosition` configurations that position labels close to the left of\n * the viewport.\n * @property {Array<number>} [intervals=[90, 45, 30, 20, 10, 5, 2, 1, 30/60, 20/60, 10/60, 5/60, 2/60, 1/60, 30/3600, 20/3600, 10/3600, 5/3600, 2/3600, 1/3600]]\n * Intervals (in degrees) for the graticule. Example to limit graticules to 30 and 10 degrees intervals:\n * ```js\n * [30, 10]\n * ```\n * @property {boolean} [wrapX=true] Whether to repeat the graticule horizontally.\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\n */\n\n/**\n * @classdesc\n * Layer that renders a grid for a coordinate system (currently only EPSG:4326 is supported).\n * Note that the view projection must define both extent and worldExtent.\n *\n * @fires import(\"../render/Event.js\").RenderEvent\n * @extends {VectorLayer<import(\"../source/Vector.js\").default>}\n * @api\n */\nclass Graticule extends VectorLayer {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    const baseOptions = Object.assign(\n      {\n        updateWhileAnimating: true,\n        updateWhileInteracting: true,\n        renderBuffer: 0,\n      },\n      options\n    );\n\n    delete baseOptions.maxLines;\n    delete baseOptions.strokeStyle;\n    delete baseOptions.targetSize;\n    delete baseOptions.showLabels;\n    delete baseOptions.lonLabelFormatter;\n    delete baseOptions.latLabelFormatter;\n    delete baseOptions.lonLabelPosition;\n    delete baseOptions.latLabelPosition;\n    delete baseOptions.lonLabelStyle;\n    delete baseOptions.latLabelStyle;\n    delete baseOptions.intervals;\n    super(baseOptions);\n\n    /**\n     * @type {import(\"../proj/Projection.js\").default}\n     */\n    this.projection_ = null;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.maxLat_ = Infinity;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.maxLon_ = Infinity;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.minLat_ = -Infinity;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.minLon_ = -Infinity;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.maxX_ = Infinity;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.maxY_ = Infinity;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.minX_ = -Infinity;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.minY_ = -Infinity;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.targetSize_ =\n      options.targetSize !== undefined ? options.targetSize : 100;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.maxLines_ = options.maxLines !== undefined ? options.maxLines : 100;\n\n    /**\n     * @type {Array<LineString>}\n     * @private\n     */\n    this.meridians_ = [];\n\n    /**\n     * @type {Array<LineString>}\n     * @private\n     */\n    this.parallels_ = [];\n\n    /**\n     * @type {Stroke}\n     * @private\n     */\n    this.strokeStyle_ =\n      options.strokeStyle !== undefined\n        ? options.strokeStyle\n        : DEFAULT_STROKE_STYLE;\n\n    /**\n     * @type {import(\"../proj.js\").TransformFunction|undefined}\n     * @private\n     */\n    this.fromLonLatTransform_ = undefined;\n\n    /**\n     * @type {import(\"../proj.js\").TransformFunction|undefined}\n     * @private\n     */\n    this.toLonLatTransform_ = undefined;\n\n    /**\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @private\n     */\n    this.projectionCenterLonLat_ = null;\n\n    /**\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @private\n     */\n    this.bottomLeft_ = null;\n\n    /**\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @private\n     */\n    this.bottomRight_ = null;\n\n    /**\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @private\n     */\n    this.topLeft_ = null;\n\n    /**\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @private\n     */\n    this.topRight_ = null;\n\n    /**\n     * @type {Array<GraticuleLabelDataType>}\n     * @private\n     */\n    this.meridiansLabels_ = null;\n\n    /**\n     * @type {Array<GraticuleLabelDataType>}\n     * @private\n     */\n    this.parallelsLabels_ = null;\n\n    if (options.showLabels) {\n      /**\n       * @type {null|function(number):string}\n       * @private\n       */\n      this.lonLabelFormatter_ =\n        options.lonLabelFormatter == undefined\n          ? degreesToStringHDMS.bind(this, 'EW')\n          : options.lonLabelFormatter;\n\n      /**\n       * @type {function(number):string}\n       * @private\n       */\n      this.latLabelFormatter_ =\n        options.latLabelFormatter == undefined\n          ? degreesToStringHDMS.bind(this, 'NS')\n          : options.latLabelFormatter;\n\n      /**\n       * Longitude label position in fractions (0..1) of view extent. 0 means\n       * bottom, 1 means top.\n       * @type {number}\n       * @private\n       */\n      this.lonLabelPosition_ =\n        options.lonLabelPosition == undefined ? 0 : options.lonLabelPosition;\n\n      /**\n       * Latitude Label position in fractions (0..1) of view extent. 0 means left, 1\n       * means right.\n       * @type {number}\n       * @private\n       */\n      this.latLabelPosition_ =\n        options.latLabelPosition == undefined ? 1 : options.latLabelPosition;\n\n      /**\n       * @type {Style}\n       * @private\n       */\n      this.lonLabelStyleBase_ = new Style({\n        text:\n          options.lonLabelStyle !== undefined\n            ? options.lonLabelStyle.clone()\n            : new Text({\n                font: '12px Calibri,sans-serif',\n                textBaseline: 'bottom',\n                fill: new Fill({\n                  color: 'rgba(0,0,0,1)',\n                }),\n                stroke: new Stroke({\n                  color: 'rgba(255,255,255,1)',\n                  width: 3,\n                }),\n              }),\n      });\n\n      /**\n       * @private\n       * @param {import(\"../Feature\").default} feature Feature\n       * @return {Style} style\n       */\n      this.lonLabelStyle_ = (feature) => {\n        const label = feature.get('graticule_label');\n        this.lonLabelStyleBase_.getText().setText(label);\n        return this.lonLabelStyleBase_;\n      };\n\n      /**\n       * @type {Style}\n       * @private\n       */\n      this.latLabelStyleBase_ = new Style({\n        text:\n          options.latLabelStyle !== undefined\n            ? options.latLabelStyle.clone()\n            : new Text({\n                font: '12px Calibri,sans-serif',\n                textAlign: 'right',\n                fill: new Fill({\n                  color: 'rgba(0,0,0,1)',\n                }),\n                stroke: new Stroke({\n                  color: 'rgba(255,255,255,1)',\n                  width: 3,\n                }),\n              }),\n      });\n\n      /**\n       * @private\n       * @param {import(\"../Feature\").default} feature Feature\n       * @return {Style} style\n       */\n      this.latLabelStyle_ = (feature) => {\n        const label = feature.get('graticule_label');\n        this.latLabelStyleBase_.getText().setText(label);\n        return this.latLabelStyleBase_;\n      };\n\n      this.meridiansLabels_ = [];\n      this.parallelsLabels_ = [];\n\n      this.addEventListener(EventType.POSTRENDER, this.drawLabels_.bind(this));\n    }\n\n    /**\n     * @type {Array<number>}\n     * @private\n     */\n    this.intervals_ =\n      options.intervals !== undefined ? options.intervals : INTERVALS;\n\n    // use a source with a custom loader for lines & text\n    this.setSource(\n      new VectorSource({\n        loader: this.loaderFunction.bind(this),\n        strategy: this.strategyFunction.bind(this),\n        features: new Collection(),\n        overlaps: false,\n        useSpatialIndex: false,\n        wrapX: options.wrapX,\n      })\n    );\n\n    /**\n     * feature pool to use when updating graticule\n     * @type {Array<Feature>}\n     * @private\n     */\n    this.featurePool_ = [];\n\n    /**\n     * @type {Style}\n     * @private\n     */\n    this.lineStyle_ = new Style({\n      stroke: this.strokeStyle_,\n    });\n\n    /**\n     * @type {?import(\"../extent.js\").Extent}\n     * @private\n     */\n    this.loadedExtent_ = null;\n\n    /**\n     * @type {?import(\"../extent.js\").Extent}\n     * @private\n     */\n    this.renderedExtent_ = null;\n\n    /**\n     * @type {?number}\n     * @private\n     */\n    this.renderedResolution_ = null;\n\n    this.setRenderOrder(null);\n  }\n\n  /**\n   * Strategy function for loading features based on the view's extent and\n   * resolution.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} resolution Resolution.\n   * @return {Array<import(\"../extent.js\").Extent>} Extents.\n   */\n  strategyFunction(extent, resolution) {\n    // extents may be passed in different worlds, to avoid endless loop we use only one\n    let realWorldExtent = extent.slice();\n    if (this.projection_ && this.getSource().getWrapX()) {\n      wrapExtentX(realWorldExtent, this.projection_);\n    }\n    if (this.loadedExtent_) {\n      if (\n        approximatelyEquals(this.loadedExtent_, realWorldExtent, resolution)\n      ) {\n        // make sure result is exactly equal to previous extent\n        realWorldExtent = this.loadedExtent_.slice();\n      } else {\n        // we should not keep track of loaded extents\n        this.getSource().removeLoadedExtent(this.loadedExtent_);\n      }\n    }\n    return [realWorldExtent];\n  }\n\n  /**\n   * Update geometries in the source based on current view\n   * @param {import(\"../extent\").Extent} extent Extent\n   * @param {number} resolution Resolution\n   * @param {import(\"../proj/Projection.js\").default} projection Projection\n   */\n  loaderFunction(extent, resolution, projection) {\n    this.loadedExtent_ = extent;\n    const source = this.getSource();\n\n    // only consider the intersection between our own extent & the requested one\n    const layerExtent = this.getExtent() || [\n      -Infinity,\n      -Infinity,\n      Infinity,\n      Infinity,\n    ];\n    const renderExtent = getIntersection(layerExtent, extent);\n\n    if (\n      this.renderedExtent_ &&\n      equals(this.renderedExtent_, renderExtent) &&\n      this.renderedResolution_ === resolution\n    ) {\n      return;\n    }\n    this.renderedExtent_ = renderExtent;\n    this.renderedResolution_ = resolution;\n\n    // bail out if nothing to render\n    if (isEmpty(renderExtent)) {\n      return;\n    }\n\n    // update projection info\n    const center = getCenter(renderExtent);\n    const squaredTolerance = (resolution * resolution) / 4;\n\n    const updateProjectionInfo =\n      !this.projection_ || !equivalentProjection(this.projection_, projection);\n\n    if (updateProjectionInfo) {\n      this.updateProjectionInfo_(projection);\n    }\n\n    this.createGraticule_(renderExtent, center, resolution, squaredTolerance);\n\n    // first make sure we have enough features in the pool\n    let featureCount = this.meridians_.length + this.parallels_.length;\n    if (this.meridiansLabels_) {\n      featureCount += this.meridians_.length;\n    }\n    if (this.parallelsLabels_) {\n      featureCount += this.parallels_.length;\n    }\n\n    let feature;\n    while (featureCount > this.featurePool_.length) {\n      feature = new Feature();\n      this.featurePool_.push(feature);\n    }\n\n    const featuresColl = source.getFeaturesCollection();\n    featuresColl.clear();\n    let poolIndex = 0;\n\n    // add features for the lines & labels\n    let i, l;\n    for (i = 0, l = this.meridians_.length; i < l; ++i) {\n      feature = this.featurePool_[poolIndex++];\n      feature.setGeometry(this.meridians_[i]);\n      feature.setStyle(this.lineStyle_);\n      featuresColl.push(feature);\n    }\n    for (i = 0, l = this.parallels_.length; i < l; ++i) {\n      feature = this.featurePool_[poolIndex++];\n      feature.setGeometry(this.parallels_[i]);\n      feature.setStyle(this.lineStyle_);\n      featuresColl.push(feature);\n    }\n  }\n\n  /**\n   * @param {number} lon Longitude.\n   * @param {number} minLat Minimal latitude.\n   * @param {number} maxLat Maximal latitude.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} index Index.\n   * @return {number} Index.\n   * @private\n   */\n  addMeridian_(lon, minLat, maxLat, squaredTolerance, extent, index) {\n    const lineString = this.getMeridian_(\n      lon,\n      minLat,\n      maxLat,\n      squaredTolerance,\n      index\n    );\n    if (intersects(lineString.getExtent(), extent)) {\n      if (this.meridiansLabels_) {\n        const text = this.lonLabelFormatter_(lon);\n        if (index in this.meridiansLabels_) {\n          this.meridiansLabels_[index].text = text;\n        } else {\n          this.meridiansLabels_[index] = {\n            geom: new Point([]),\n            text: text,\n          };\n        }\n      }\n      this.meridians_[index++] = lineString;\n    }\n    return index;\n  }\n\n  /**\n   * @param {number} lat Latitude.\n   * @param {number} minLon Minimal longitude.\n   * @param {number} maxLon Maximal longitude.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} index Index.\n   * @return {number} Index.\n   * @private\n   */\n  addParallel_(lat, minLon, maxLon, squaredTolerance, extent, index) {\n    const lineString = this.getParallel_(\n      lat,\n      minLon,\n      maxLon,\n      squaredTolerance,\n      index\n    );\n    if (intersects(lineString.getExtent(), extent)) {\n      if (this.parallelsLabels_) {\n        const text = this.latLabelFormatter_(lat);\n        if (index in this.parallelsLabels_) {\n          this.parallelsLabels_[index].text = text;\n        } else {\n          this.parallelsLabels_[index] = {\n            geom: new Point([]),\n            text: text,\n          };\n        }\n      }\n      this.parallels_[index++] = lineString;\n    }\n    return index;\n  }\n\n  /**\n   * @param {import(\"../render/Event.js\").default} event Render event.\n   * @private\n   */\n  drawLabels_(event) {\n    const rotation = event.frameState.viewState.rotation;\n    const resolution = event.frameState.viewState.resolution;\n    const size = event.frameState.size;\n    const extent = event.frameState.extent;\n    const rotationCenter = getCenter(extent);\n    let rotationExtent = extent;\n    if (rotation) {\n      const unrotatedWidth = size[0] * resolution;\n      const unrotatedHeight = size[1] * resolution;\n      rotationExtent = [\n        rotationCenter[0] - unrotatedWidth / 2,\n        rotationCenter[1] - unrotatedHeight / 2,\n        rotationCenter[0] + unrotatedWidth / 2,\n        rotationCenter[1] + unrotatedHeight / 2,\n      ];\n    }\n\n    let startWorld = 0;\n    let endWorld = 0;\n    let labelsAtStart = this.latLabelPosition_ < 0.5;\n    const projectionExtent = this.projection_.getExtent();\n    const worldWidth = getWidth(projectionExtent);\n    if (\n      this.getSource().getWrapX() &&\n      this.projection_.canWrapX() &&\n      !containsExtent(projectionExtent, extent)\n    ) {\n      startWorld = Math.floor((extent[0] - projectionExtent[0]) / worldWidth);\n      endWorld = Math.ceil((extent[2] - projectionExtent[2]) / worldWidth);\n      const inverted = Math.abs(rotation) > Math.PI / 2;\n      labelsAtStart = labelsAtStart !== inverted;\n    }\n    const vectorContext = getVectorContext(event);\n\n    for (let world = startWorld; world <= endWorld; ++world) {\n      let poolIndex = this.meridians_.length + this.parallels_.length;\n      let feature, index, l, textPoint;\n\n      if (this.meridiansLabels_) {\n        for (index = 0, l = this.meridiansLabels_.length; index < l; ++index) {\n          const lineString = this.meridians_[index];\n          if (!rotation && world === 0) {\n            textPoint = this.getMeridianPoint_(lineString, extent, index);\n          } else {\n            const clone = lineString.clone();\n            clone.translate(world * worldWidth, 0);\n            clone.rotate(-rotation, rotationCenter);\n            textPoint = this.getMeridianPoint_(clone, rotationExtent, index);\n            textPoint.rotate(rotation, rotationCenter);\n          }\n          feature = this.featurePool_[poolIndex++];\n          feature.setGeometry(textPoint);\n          feature.set('graticule_label', this.meridiansLabels_[index].text);\n          vectorContext.drawFeature(feature, this.lonLabelStyle_(feature));\n        }\n      }\n      if (this.parallelsLabels_) {\n        if (\n          (world === startWorld && labelsAtStart) ||\n          (world === endWorld && !labelsAtStart)\n        ) {\n          for (index = 0, l = this.parallels_.length; index < l; ++index) {\n            const lineString = this.parallels_[index];\n            if (!rotation && world === 0) {\n              textPoint = this.getParallelPoint_(lineString, extent, index);\n            } else {\n              const clone = lineString.clone();\n              clone.translate(world * worldWidth, 0);\n              clone.rotate(-rotation, rotationCenter);\n              textPoint = this.getParallelPoint_(clone, rotationExtent, index);\n              textPoint.rotate(rotation, rotationCenter);\n            }\n            feature = this.featurePool_[poolIndex++];\n            feature.setGeometry(textPoint);\n            feature.set('graticule_label', this.parallelsLabels_[index].text);\n            vectorContext.drawFeature(feature, this.latLabelStyle_(feature));\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {import(\"../coordinate.js\").Coordinate} center Center.\n   * @param {number} resolution Resolution.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @private\n   */\n  createGraticule_(extent, center, resolution, squaredTolerance) {\n    const interval = this.getInterval_(resolution);\n    if (interval == -1) {\n      this.meridians_.length = 0;\n      this.parallels_.length = 0;\n      if (this.meridiansLabels_) {\n        this.meridiansLabels_.length = 0;\n      }\n      if (this.parallelsLabels_) {\n        this.parallelsLabels_.length = 0;\n      }\n      return;\n    }\n\n    let wrapX = false;\n    const projectionExtent = this.projection_.getExtent();\n    const worldWidth = getWidth(projectionExtent);\n    if (\n      this.getSource().getWrapX() &&\n      this.projection_.canWrapX() &&\n      !containsExtent(projectionExtent, extent)\n    ) {\n      if (getWidth(extent) >= worldWidth) {\n        extent[0] = projectionExtent[0];\n        extent[2] = projectionExtent[2];\n      } else {\n        wrapX = true;\n      }\n    }\n\n    // Constrain the center to fit into the extent available to the graticule\n\n    const validCenterP = [\n      clamp(center[0], this.minX_, this.maxX_),\n      clamp(center[1], this.minY_, this.maxY_),\n    ];\n\n    // Transform the center to lon lat\n    // Some projections may have a void area at the poles\n    // so replace any NaN latitudes with the min or max value closest to a pole\n\n    const centerLonLat = this.toLonLatTransform_(validCenterP);\n    if (isNaN(centerLonLat[1])) {\n      centerLonLat[1] =\n        Math.abs(this.maxLat_) >= Math.abs(this.minLat_)\n          ? this.maxLat_\n          : this.minLat_;\n    }\n    let centerLon = clamp(centerLonLat[0], this.minLon_, this.maxLon_);\n    let centerLat = clamp(centerLonLat[1], this.minLat_, this.maxLat_);\n    const maxLines = this.maxLines_;\n    let cnt, idx, lat, lon;\n\n    // Limit the extent to fit into the extent available to the graticule\n\n    let validExtentP = extent;\n    if (!wrapX) {\n      validExtentP = [\n        clamp(extent[0], this.minX_, this.maxX_),\n        clamp(extent[1], this.minY_, this.maxY_),\n        clamp(extent[2], this.minX_, this.maxX_),\n        clamp(extent[3], this.minY_, this.maxY_),\n      ];\n    }\n\n    // Transform the extent to get the lon lat ranges for the edges of the extent\n\n    const validExtent = applyTransform(\n      validExtentP,\n      this.toLonLatTransform_,\n      undefined,\n      8\n    );\n\n    let maxLat = validExtent[3];\n    let maxLon = validExtent[2];\n    let minLat = validExtent[1];\n    let minLon = validExtent[0];\n\n    if (!wrapX) {\n      // Check if extremities of the world extent lie inside the extent\n      // (for example the pole in a polar projection)\n      // and extend the extent as appropriate\n\n      if (containsCoordinate(validExtentP, this.bottomLeft_)) {\n        minLon = this.minLon_;\n        minLat = this.minLat_;\n      }\n      if (containsCoordinate(validExtentP, this.bottomRight_)) {\n        maxLon = this.maxLon_;\n        minLat = this.minLat_;\n      }\n      if (containsCoordinate(validExtentP, this.topLeft_)) {\n        minLon = this.minLon_;\n        maxLat = this.maxLat_;\n      }\n      if (containsCoordinate(validExtentP, this.topRight_)) {\n        maxLon = this.maxLon_;\n        maxLat = this.maxLat_;\n      }\n\n      // The transformed center may also extend the lon lat ranges used for rendering\n\n      maxLat = clamp(maxLat, centerLat, this.maxLat_);\n      maxLon = clamp(maxLon, centerLon, this.maxLon_);\n      minLat = clamp(minLat, this.minLat_, centerLat);\n      minLon = clamp(minLon, this.minLon_, centerLon);\n    }\n\n    // Create meridians\n\n    centerLon = Math.floor(centerLon / interval) * interval;\n    lon = clamp(centerLon, this.minLon_, this.maxLon_);\n\n    idx = this.addMeridian_(lon, minLat, maxLat, squaredTolerance, extent, 0);\n\n    cnt = 0;\n    if (wrapX) {\n      while ((lon -= interval) >= minLon && cnt++ < maxLines) {\n        idx = this.addMeridian_(\n          lon,\n          minLat,\n          maxLat,\n          squaredTolerance,\n          extent,\n          idx\n        );\n      }\n    } else {\n      while (lon != this.minLon_ && cnt++ < maxLines) {\n        lon = Math.max(lon - interval, this.minLon_);\n        idx = this.addMeridian_(\n          lon,\n          minLat,\n          maxLat,\n          squaredTolerance,\n          extent,\n          idx\n        );\n      }\n    }\n\n    lon = clamp(centerLon, this.minLon_, this.maxLon_);\n\n    cnt = 0;\n    if (wrapX) {\n      while ((lon += interval) <= maxLon && cnt++ < maxLines) {\n        idx = this.addMeridian_(\n          lon,\n          minLat,\n          maxLat,\n          squaredTolerance,\n          extent,\n          idx\n        );\n      }\n    } else {\n      while (lon != this.maxLon_ && cnt++ < maxLines) {\n        lon = Math.min(lon + interval, this.maxLon_);\n        idx = this.addMeridian_(\n          lon,\n          minLat,\n          maxLat,\n          squaredTolerance,\n          extent,\n          idx\n        );\n      }\n    }\n\n    this.meridians_.length = idx;\n    if (this.meridiansLabels_) {\n      this.meridiansLabels_.length = idx;\n    }\n\n    // Create parallels\n\n    centerLat = Math.floor(centerLat / interval) * interval;\n    lat = clamp(centerLat, this.minLat_, this.maxLat_);\n\n    idx = this.addParallel_(lat, minLon, maxLon, squaredTolerance, extent, 0);\n\n    cnt = 0;\n    while (lat != this.minLat_ && cnt++ < maxLines) {\n      lat = Math.max(lat - interval, this.minLat_);\n      idx = this.addParallel_(\n        lat,\n        minLon,\n        maxLon,\n        squaredTolerance,\n        extent,\n        idx\n      );\n    }\n\n    lat = clamp(centerLat, this.minLat_, this.maxLat_);\n\n    cnt = 0;\n    while (lat != this.maxLat_ && cnt++ < maxLines) {\n      lat = Math.min(lat + interval, this.maxLat_);\n      idx = this.addParallel_(\n        lat,\n        minLon,\n        maxLon,\n        squaredTolerance,\n        extent,\n        idx\n      );\n    }\n\n    this.parallels_.length = idx;\n    if (this.parallelsLabels_) {\n      this.parallelsLabels_.length = idx;\n    }\n  }\n\n  /**\n   * @param {number} resolution Resolution.\n   * @return {number} The interval in degrees.\n   * @private\n   */\n  getInterval_(resolution) {\n    const centerLon = this.projectionCenterLonLat_[0];\n    const centerLat = this.projectionCenterLonLat_[1];\n    let interval = -1;\n    const target = Math.pow(this.targetSize_ * resolution, 2);\n    /** @type {Array<number>} **/\n    const p1 = [];\n    /** @type {Array<number>} **/\n    const p2 = [];\n    for (let i = 0, ii = this.intervals_.length; i < ii; ++i) {\n      const delta = clamp(this.intervals_[i] / 2, 0, 90);\n      // Don't attempt to transform latitudes beyond the poles!\n      const clampedLat = clamp(centerLat, -90 + delta, 90 - delta);\n      p1[0] = centerLon - delta;\n      p1[1] = clampedLat - delta;\n      p2[0] = centerLon + delta;\n      p2[1] = clampedLat + delta;\n      this.fromLonLatTransform_(p1, p1);\n      this.fromLonLatTransform_(p2, p2);\n      const dist = Math.pow(p2[0] - p1[0], 2) + Math.pow(p2[1] - p1[1], 2);\n      if (dist <= target) {\n        break;\n      }\n      interval = this.intervals_[i];\n    }\n    return interval;\n  }\n\n  /**\n   * @param {number} lon Longitude.\n   * @param {number} minLat Minimal latitude.\n   * @param {number} maxLat Maximal latitude.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {LineString} The meridian line string.\n   * @param {number} index Index.\n   * @private\n   */\n  getMeridian_(lon, minLat, maxLat, squaredTolerance, index) {\n    const flatCoordinates = meridian(\n      lon,\n      minLat,\n      maxLat,\n      this.projection_,\n      squaredTolerance\n    );\n    let lineString = this.meridians_[index];\n    if (!lineString) {\n      lineString = new LineString(flatCoordinates, 'XY');\n      this.meridians_[index] = lineString;\n    } else {\n      lineString.setFlatCoordinates('XY', flatCoordinates);\n      lineString.changed();\n    }\n    return lineString;\n  }\n\n  /**\n   * @param {LineString} lineString Meridian\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} index Index.\n   * @return {Point} Meridian point.\n   * @private\n   */\n  getMeridianPoint_(lineString, extent, index) {\n    const flatCoordinates = lineString.getFlatCoordinates();\n    let bottom = 1;\n    let top = flatCoordinates.length - 1;\n    if (flatCoordinates[bottom] > flatCoordinates[top]) {\n      bottom = top;\n      top = 1;\n    }\n    const clampedBottom = Math.max(extent[1], flatCoordinates[bottom]);\n    const clampedTop = Math.min(extent[3], flatCoordinates[top]);\n    const lat = clamp(\n      extent[1] + Math.abs(extent[1] - extent[3]) * this.lonLabelPosition_,\n      clampedBottom,\n      clampedTop\n    );\n    const coordinate0 =\n      flatCoordinates[bottom - 1] +\n      ((flatCoordinates[top - 1] - flatCoordinates[bottom - 1]) *\n        (lat - flatCoordinates[bottom])) /\n        (flatCoordinates[top] - flatCoordinates[bottom]);\n    const coordinate = [coordinate0, lat];\n    const point = this.meridiansLabels_[index].geom;\n    point.setCoordinates(coordinate);\n    return point;\n  }\n\n  /**\n   * Get the list of meridians.  Meridians are lines of equal longitude.\n   * @return {Array<LineString>} The meridians.\n   * @api\n   */\n  getMeridians() {\n    return this.meridians_;\n  }\n\n  /**\n   * @param {number} lat Latitude.\n   * @param {number} minLon Minimal longitude.\n   * @param {number} maxLon Maximal longitude.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {LineString} The parallel line string.\n   * @param {number} index Index.\n   * @private\n   */\n  getParallel_(lat, minLon, maxLon, squaredTolerance, index) {\n    const flatCoordinates = parallel(\n      lat,\n      minLon,\n      maxLon,\n      this.projection_,\n      squaredTolerance\n    );\n    let lineString = this.parallels_[index];\n    if (!lineString) {\n      lineString = new LineString(flatCoordinates, 'XY');\n    } else {\n      lineString.setFlatCoordinates('XY', flatCoordinates);\n      lineString.changed();\n    }\n    return lineString;\n  }\n\n  /**\n   * @param {LineString} lineString Parallels.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} index Index.\n   * @return {Point} Parallel point.\n   * @private\n   */\n  getParallelPoint_(lineString, extent, index) {\n    const flatCoordinates = lineString.getFlatCoordinates();\n    let left = 0;\n    let right = flatCoordinates.length - 2;\n    if (flatCoordinates[left] > flatCoordinates[right]) {\n      left = right;\n      right = 0;\n    }\n    const clampedLeft = Math.max(extent[0], flatCoordinates[left]);\n    const clampedRight = Math.min(extent[2], flatCoordinates[right]);\n    const lon = clamp(\n      extent[0] + Math.abs(extent[0] - extent[2]) * this.latLabelPosition_,\n      clampedLeft,\n      clampedRight\n    );\n    const coordinate1 =\n      flatCoordinates[left + 1] +\n      ((flatCoordinates[right + 1] - flatCoordinates[left + 1]) *\n        (lon - flatCoordinates[left])) /\n        (flatCoordinates[right] - flatCoordinates[left]);\n    const coordinate = [lon, coordinate1];\n    const point = this.parallelsLabels_[index].geom;\n    point.setCoordinates(coordinate);\n    return point;\n  }\n\n  /**\n   * Get the list of parallels.  Parallels are lines of equal latitude.\n   * @return {Array<LineString>} The parallels.\n   * @api\n   */\n  getParallels() {\n    return this.parallels_;\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @private\n   */\n  updateProjectionInfo_(projection) {\n    const epsg4326Projection = getProjection('EPSG:4326');\n\n    const worldExtent = projection.getWorldExtent();\n\n    this.maxLat_ = worldExtent[3];\n    this.maxLon_ = worldExtent[2];\n    this.minLat_ = worldExtent[1];\n    this.minLon_ = worldExtent[0];\n\n    // If the world extent crosses the dateline define a custom transform to\n    // return longitudes which wrap the dateline\n\n    const toLonLatTransform = getTransform(projection, epsg4326Projection);\n    if (this.minLon_ < this.maxLon_) {\n      this.toLonLatTransform_ = toLonLatTransform;\n    } else {\n      const split = this.minLon_ + this.maxLon_ / 2;\n      this.maxLon_ += 360;\n      this.toLonLatTransform_ = function (coordinates, output, dimension) {\n        dimension = dimension || 2;\n        const lonLatCoordinates = toLonLatTransform(\n          coordinates,\n          output,\n          dimension\n        );\n        for (let i = 0, l = lonLatCoordinates.length; i < l; i += dimension) {\n          if (lonLatCoordinates[i] < split) {\n            lonLatCoordinates[i] += 360;\n          }\n        }\n        return lonLatCoordinates;\n      };\n    }\n\n    // Transform the extent to get the limits of the view projection extent\n    // which should be available to the graticule\n\n    this.fromLonLatTransform_ = getTransform(epsg4326Projection, projection);\n    const worldExtentP = applyTransform(\n      [this.minLon_, this.minLat_, this.maxLon_, this.maxLat_],\n      this.fromLonLatTransform_,\n      undefined,\n      8\n    );\n\n    this.minX_ = worldExtentP[0];\n    this.maxX_ = worldExtentP[2];\n    this.minY_ = worldExtentP[1];\n    this.maxY_ = worldExtentP[3];\n\n    // Determine the view projection coordinates of the extremities of the world extent\n    // as these may lie inside a view extent (for example the pole in a polar projection)\n\n    this.bottomLeft_ = this.fromLonLatTransform_([this.minLon_, this.minLat_]);\n    this.bottomRight_ = this.fromLonLatTransform_([this.maxLon_, this.minLat_]);\n    this.topLeft_ = this.fromLonLatTransform_([this.minLon_, this.maxLat_]);\n    this.topRight_ = this.fromLonLatTransform_([this.maxLon_, this.maxLat_]);\n\n    // Transform the projection center to lon lat\n    // Some projections may have a void area at the poles\n    // so replace any NaN latitudes with the min or max value closest to a pole\n\n    this.projectionCenterLonLat_ = this.toLonLatTransform_(\n      getCenter(projection.getExtent())\n    );\n    if (isNaN(this.projectionCenterLonLat_[1])) {\n      this.projectionCenterLonLat_[1] =\n        Math.abs(this.maxLat_) >= Math.abs(this.minLat_)\n          ? this.maxLat_\n          : this.minLat_;\n    }\n\n    this.projection_ = projection;\n  }\n}\n\nexport default Graticule;\n"],"mappings":";;;;;AAAA;AACA;AACA;AACA,OAAOA,UAAU,MAAM,kBAAkB;AACzC,OAAOC,SAAS,MAAM,wBAAwB;AAC9C,OAAOC,OAAO,MAAM,eAAe;AACnC,OAAOC,IAAI,MAAM,kBAAkB;AACnC,OAAOC,UAAU,MAAM,uBAAuB;AAC9C,OAAOC,KAAK,MAAM,kBAAkB;AACpC,OAAOC,MAAM,MAAM,oBAAoB;AACvC,OAAOC,KAAK,MAAM,mBAAmB;AACrC,OAAOC,IAAI,MAAM,kBAAkB;AACnC,OAAOC,WAAW,MAAM,aAAa;AACrC,OAAOC,YAAY,MAAM,qBAAqB;AAC9C,SACEC,cAAc,EACdC,mBAAmB,EACnBC,kBAAkB,EAClBC,cAAc,EACdC,MAAM,EACNC,SAAS,EACTC,eAAe,EACfC,QAAQ,EACRC,UAAU,EACVC,OAAO,EACPC,KAAK,IAAIC,WAAW,QACf,cAAc;AACrB,SAAQC,KAAK,QAAO,YAAY;AAChC,SAAQC,mBAAmB,QAAO,kBAAkB;AACpD,SACEC,UAAU,IAAIC,oBAAoB,EAClCC,GAAG,IAAIC,aAAa,EACpBC,YAAY,QACP,YAAY;AACnB,SAAQC,gBAAgB,QAAO,cAAc;AAC7C,SAAQC,QAAQ,EAAEC,QAAQ,QAAO,0BAA0B;;AAE3D;AACA;AACA;AACA;AACA;AACA,IAAMC,oBAAoB,GAAG,IAAI3B,MAAM,CAAC;EACtC4B,KAAK,EAAE;AACT,CAAC,CAAC;;AAEF;AACA;AACA;AACA;AACA,IAAMC,SAAS,GAAG,CAChB,EAAE,EACF,EAAE,EACF,EAAE,EACF,EAAE,EACF,EAAE,EACF,CAAC,EACD,CAAC,EACD,CAAC,EACD,EAAE,GAAG,EAAE,EACP,EAAE,GAAG,EAAE,EACP,EAAE,GAAG,EAAE,EACP,CAAC,GAAG,EAAE,EACN,CAAC,GAAG,EAAE,EACN,CAAC,GAAG,EAAE,EACN,EAAE,GAAG,IAAI,EACT,EAAE,GAAG,IAAI,EACT,EAAE,GAAG,IAAI,EACT,CAAC,GAAG,IAAI,EACR,CAAC,GAAG,IAAI,EACR,CAAC,GAAG,IAAI,CACT;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA,IASMC,SAAS,0BAAAC,YAAA;EAAAC,SAAA,CAAAF,SAAA,EAAAC,YAAA;EAAA,IAAAE,MAAA,GAAAC,YAAA,CAAAJ,SAAA;EACb;AACF;AACA;EACE,SAAAA,UAAYK,OAAO,EAAE;IAAA,IAAAC,KAAA;IAAAC,eAAA,OAAAP,SAAA;IACnBK,OAAO,GAAGA,OAAO,GAAGA,OAAO,GAAG,CAAC,CAAC;IAEhC,IAAMG,WAAW,GAAGC,MAAM,CAACC,MAAM,CAC/B;MACEC,oBAAoB,EAAE,IAAI;MAC1BC,sBAAsB,EAAE,IAAI;MAC5BC,YAAY,EAAE;IAChB,CAAC,EACDR,OAAO,CACR;IAED,OAAOG,WAAW,CAACM,QAAQ;IAC3B,OAAON,WAAW,CAACO,WAAW;IAC9B,OAAOP,WAAW,CAACQ,UAAU;IAC7B,OAAOR,WAAW,CAACS,UAAU;IAC7B,OAAOT,WAAW,CAACU,iBAAiB;IACpC,OAAOV,WAAW,CAACW,iBAAiB;IACpC,OAAOX,WAAW,CAACY,gBAAgB;IACnC,OAAOZ,WAAW,CAACa,gBAAgB;IACnC,OAAOb,WAAW,CAACc,aAAa;IAChC,OAAOd,WAAW,CAACe,aAAa;IAChC,OAAOf,WAAW,CAACgB,SAAS;IAC5BlB,KAAA,GAAAH,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"},"metadata":{},"sourceType":"module","externalDependencies":[]}