{"ast":null,"code":"import _classCallCheck from \"/home/jay/Downloads/major/my-app/gis/web-gis/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/jay/Downloads/major/my-app/gis/web-gis/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n/**\n * @module ol/render/canvas/Executor\n */\nimport CanvasInstruction from './Instruction.js';\nimport { TEXT_ALIGN } from './TextBuilder.js';\nimport { apply as applyTransform, compose as composeTransform, create as createTransform, setFromArray as transformSetFromArray } from '../../transform.js';\nimport { createEmpty, createOrUpdate, intersects } from '../../extent.js';\nimport { defaultPadding, defaultTextAlign, defaultTextBaseline, drawImageOrLabel, getTextDimensions, measureAndCacheTextWidth } from '../canvas.js';\nimport { drawTextOnPath } from '../../geom/flat/textpath.js';\nimport { equals } from '../../array.js';\nimport { lineStringLength } from '../../geom/flat/length.js';\nimport { transform2D } from '../../geom/flat/transform.js';\n\n/**\n * @typedef {Object} BBox\n * @property {number} minX Minimal x.\n * @property {number} minY Minimal y.\n * @property {number} maxX Maximal x.\n * @property {number} maxY Maximal y\n * @property {*} value Value.\n */\n\n/**\n * @typedef {Object} ImageOrLabelDimensions\n * @property {number} drawImageX DrawImageX.\n * @property {number} drawImageY DrawImageY.\n * @property {number} drawImageW DrawImageW.\n * @property {number} drawImageH DrawImageH.\n * @property {number} originX OriginX.\n * @property {number} originY OriginY.\n * @property {Array<number>} scale Scale.\n * @property {BBox} declutterBox DeclutterBox.\n * @property {import(\"../../transform.js\").Transform} canvasTransform CanvasTransform.\n */\n\n/**\n * @typedef {{0: CanvasRenderingContext2D, 1: number, 2: import(\"../canvas.js\").Label|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement, 3: ImageOrLabelDimensions, 4: number, 5: Array<*>, 6: Array<*>}} ReplayImageOrLabelArgs\n */\n\n/**\n * @template T\n * @typedef {function(import(\"../../Feature.js\").FeatureLike, import(\"../../geom/SimpleGeometry.js\").default): T} FeatureCallback\n */\n\n/**\n * @type {import(\"../../extent.js\").Extent}\n */\nvar tmpExtent = createEmpty();\n\n/** @type {import(\"../../coordinate.js\").Coordinate} */\nvar p1 = [];\n/** @type {import(\"../../coordinate.js\").Coordinate} */\nvar p2 = [];\n/** @type {import(\"../../coordinate.js\").Coordinate} */\nvar p3 = [];\n/** @type {import(\"../../coordinate.js\").Coordinate} */\nvar p4 = [];\n\n/**\n * @param {ReplayImageOrLabelArgs} replayImageOrLabelArgs Arguments to replayImageOrLabel\n * @return {BBox} Declutter bbox.\n */\nfunction getDeclutterBox(replayImageOrLabelArgs) {\n  return replayImageOrLabelArgs[3].declutterBox;\n}\nvar rtlRegEx = new RegExp( /* eslint-disable prettier/prettier */\n'[' + String.fromCharCode(0x00591) + '-' + String.fromCharCode(0x008ff) + String.fromCharCode(0x0fb1d) + '-' + String.fromCharCode(0x0fdff) + String.fromCharCode(0x0fe70) + '-' + String.fromCharCode(0x0fefc) + String.fromCharCode(0x10800) + '-' + String.fromCharCode(0x10fff) + String.fromCharCode(0x1e800) + '-' + String.fromCharCode(0x1efff) + ']'\n/* eslint-enable prettier/prettier */);\n\n/**\n * @param {string} text Text.\n * @param {CanvasTextAlign} align Alignment.\n * @return {number} Text alignment.\n */\nfunction horizontalTextAlign(text, align) {\n  if ((align === 'start' || align === 'end') && !rtlRegEx.test(text)) {\n    align = align === 'start' ? 'left' : 'right';\n  }\n  return TEXT_ALIGN[align];\n}\n\n/**\n * @param {Array<string>} acc Accumulator.\n * @param {string} line Line of text.\n * @param {number} i Index\n * @return {Array<string>} Accumulator.\n */\nfunction createTextChunks(acc, line, i) {\n  if (i > 0) {\n    acc.push('\\n', '');\n  }\n  acc.push(line, '');\n  return acc;\n}\nvar Executor = /*#__PURE__*/function () {\n  /**\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {boolean} overlaps The replay can have overlapping geometries.\n   * @param {import(\"../canvas.js\").SerializableInstructions} instructions The serializable instructions\n   */\n  function Executor(resolution, pixelRatio, overlaps, instructions) {\n    _classCallCheck(this, Executor);\n    /**\n     * @protected\n     * @type {boolean}\n     */\n    this.overlaps = overlaps;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.pixelRatio = pixelRatio;\n\n    /**\n     * @protected\n     * @const\n     * @type {number}\n     */\n    this.resolution = resolution;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.alignFill_;\n\n    /**\n     * @protected\n     * @type {Array<*>}\n     */\n    this.instructions = instructions.instructions;\n\n    /**\n     * @protected\n     * @type {Array<number>}\n     */\n    this.coordinates = instructions.coordinates;\n\n    /**\n     * @private\n     * @type {!Object<number,import(\"../../coordinate.js\").Coordinate|Array<import(\"../../coordinate.js\").Coordinate>|Array<Array<import(\"../../coordinate.js\").Coordinate>>>}\n     */\n    this.coordinateCache_ = {};\n\n    /**\n     * @private\n     * @type {!import(\"../../transform.js\").Transform}\n     */\n    this.renderedTransform_ = createTransform();\n\n    /**\n     * @protected\n     * @type {Array<*>}\n     */\n    this.hitDetectionInstructions = instructions.hitDetectionInstructions;\n\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    this.pixelCoordinates_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.viewRotation_ = 0;\n\n    /**\n     * @type {!Object<string, import(\"../canvas.js\").FillState>}\n     */\n    this.fillStates = instructions.fillStates || {};\n\n    /**\n     * @type {!Object<string, import(\"../canvas.js\").StrokeState>}\n     */\n    this.strokeStates = instructions.strokeStates || {};\n\n    /**\n     * @type {!Object<string, import(\"../canvas.js\").TextState>}\n     */\n    this.textStates = instructions.textStates || {};\n\n    /**\n     * @private\n     * @type {Object<string, Object<string, number>>}\n     */\n    this.widths_ = {};\n\n    /**\n     * @private\n     * @type {Object<string, import(\"../canvas.js\").Label>}\n     */\n    this.labels_ = {};\n  }\n\n  /**\n   * @param {string|Array<string>} text Text.\n   * @param {string} textKey Text style key.\n   * @param {string} fillKey Fill style key.\n   * @param {string} strokeKey Stroke style key.\n   * @return {import(\"../canvas.js\").Label} Label.\n   */\n  _createClass(Executor, [{\n    key: \"createLabel\",\n    value: function createLabel(text, textKey, fillKey, strokeKey) {\n      var key = text + textKey + fillKey + strokeKey;\n      if (this.labels_[key]) {\n        return this.labels_[key];\n      }\n      var strokeState = strokeKey ? this.strokeStates[strokeKey] : null;\n      var fillState = fillKey ? this.fillStates[fillKey] : null;\n      var textState = this.textStates[textKey];\n      var pixelRatio = this.pixelRatio;\n      var scale = [textState.scale[0] * pixelRatio, textState.scale[1] * pixelRatio];\n      var textIsArray = Array.isArray(text);\n      var align = textState.justify ? TEXT_ALIGN[textState.justify] : horizontalTextAlign(Array.isArray(text) ? text[0] : text, textState.textAlign || defaultTextAlign);\n      var strokeWidth = strokeKey && strokeState.lineWidth ? strokeState.lineWidth : 0;\n      var chunks = textIsArray ? text : text.split('\\n').reduce(createTextChunks, []);\n      var _getTextDimensions = getTextDimensions(textState, chunks),\n        width = _getTextDimensions.width,\n        height = _getTextDimensions.height,\n        widths = _getTextDimensions.widths,\n        heights = _getTextDimensions.heights,\n        lineWidths = _getTextDimensions.lineWidths;\n      var renderWidth = width + strokeWidth;\n      var contextInstructions = [];\n      // make canvas 2 pixels wider to account for italic text width measurement errors\n      var w = (renderWidth + 2) * scale[0];\n      var h = (height + strokeWidth) * scale[1];\n      /** @type {import(\"../canvas.js\").Label} */\n      var label = {\n        width: w < 0 ? Math.floor(w) : Math.ceil(w),\n        height: h < 0 ? Math.floor(h) : Math.ceil(h),\n        contextInstructions: contextInstructions\n      };\n      if (scale[0] != 1 || scale[1] != 1) {\n        contextInstructions.push('scale', scale);\n      }\n      if (strokeKey) {\n        contextInstructions.push('strokeStyle', strokeState.strokeStyle);\n        contextInstructions.push('lineWidth', strokeWidth);\n        contextInstructions.push('lineCap', strokeState.lineCap);\n        contextInstructions.push('lineJoin', strokeState.lineJoin);\n        contextInstructions.push('miterLimit', strokeState.miterLimit);\n        contextInstructions.push('setLineDash', [strokeState.lineDash]);\n        contextInstructions.push('lineDashOffset', strokeState.lineDashOffset);\n      }\n      if (fillKey) {\n        contextInstructions.push('fillStyle', fillState.fillStyle);\n      }\n      contextInstructions.push('textBaseline', 'middle');\n      contextInstructions.push('textAlign', 'center');\n      var leftRight = 0.5 - align;\n      var x = align * renderWidth + leftRight * strokeWidth;\n      var strokeInstructions = [];\n      var fillInstructions = [];\n      var lineHeight = 0;\n      var lineOffset = 0;\n      var widthHeightIndex = 0;\n      var lineWidthIndex = 0;\n      var previousFont;\n      for (var i = 0, ii = chunks.length; i < ii; i += 2) {\n        var _text = chunks[i];\n        if (_text === '\\n') {\n          lineOffset += lineHeight;\n          lineHeight = 0;\n          x = align * renderWidth + leftRight * strokeWidth;\n          ++lineWidthIndex;\n          continue;\n        }\n        var font = chunks[i + 1] || textState.font;\n        if (font !== previousFont) {\n          if (strokeKey) {\n            strokeInstructions.push('font', font);\n          }\n          if (fillKey) {\n            fillInstructions.push('font', font);\n          }\n          previousFont = font;\n        }\n        lineHeight = Math.max(lineHeight, heights[widthHeightIndex]);\n        var fillStrokeArgs = [_text, x + leftRight * widths[widthHeightIndex] + align * (widths[widthHeightIndex] - lineWidths[lineWidthIndex]), 0.5 * (strokeWidth + lineHeight) + lineOffset];\n        x += widths[widthHeightIndex];\n        if (strokeKey) {\n          strokeInstructions.push('strokeText', fillStrokeArgs);\n        }\n        if (fillKey) {\n          fillInstructions.push('fillText', fillStrokeArgs);\n        }\n        ++widthHeightIndex;\n      }\n      Array.prototype.push.apply(contextInstructions, strokeInstructions);\n      Array.prototype.push.apply(contextInstructions, fillInstructions);\n      this.labels_[key] = label;\n      return label;\n    }\n\n    /**\n     * @param {CanvasRenderingContext2D} context Context.\n     * @param {import(\"../../coordinate.js\").Coordinate} p1 1st point of the background box.\n     * @param {import(\"../../coordinate.js\").Coordinate} p2 2nd point of the background box.\n     * @param {import(\"../../coordinate.js\").Coordinate} p3 3rd point of the background box.\n     * @param {import(\"../../coordinate.js\").Coordinate} p4 4th point of the background box.\n     * @param {Array<*>} fillInstruction Fill instruction.\n     * @param {Array<*>} strokeInstruction Stroke instruction.\n     */\n  }, {\n    key: \"replayTextBackground_\",\n    value: function replayTextBackground_(context, p1, p2, p3, p4, fillInstruction, strokeInstruction) {\n      context.beginPath();\n      context.moveTo.apply(context, p1);\n      context.lineTo.apply(context, p2);\n      context.lineTo.apply(context, p3);\n      context.lineTo.apply(context, p4);\n      context.lineTo.apply(context, p1);\n      if (fillInstruction) {\n        this.alignFill_ = /** @type {boolean} */fillInstruction[2];\n        this.fill_(context);\n      }\n      if (strokeInstruction) {\n        this.setStrokeStyle_(context, /** @type {Array<*>} */strokeInstruction);\n        context.stroke();\n      }\n    }\n\n    /**\n     * @private\n     * @param {number} sheetWidth Width of the sprite sheet.\n     * @param {number} sheetHeight Height of the sprite sheet.\n     * @param {number} centerX X.\n     * @param {number} centerY Y.\n     * @param {number} width Width.\n     * @param {number} height Height.\n     * @param {number} anchorX Anchor X.\n     * @param {number} anchorY Anchor Y.\n     * @param {number} originX Origin X.\n     * @param {number} originY Origin Y.\n     * @param {number} rotation Rotation.\n     * @param {import(\"../../size.js\").Size} scale Scale.\n     * @param {boolean} snapToPixel Snap to pixel.\n     * @param {Array<number>} padding Padding.\n     * @param {boolean} fillStroke Background fill or stroke.\n     * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n     * @return {ImageOrLabelDimensions} Dimensions for positioning and decluttering the image or label.\n     */\n  }, {\n    key: \"calculateImageOrLabelDimensions_\",\n    value: function calculateImageOrLabelDimensions_(sheetWidth, sheetHeight, centerX, centerY, width, height, anchorX, anchorY, originX, originY, rotation, scale, snapToPixel, padding, fillStroke, feature) {\n      anchorX *= scale[0];\n      anchorY *= scale[1];\n      var x = centerX - anchorX;\n      var y = centerY - anchorY;\n      var w = width + originX > sheetWidth ? sheetWidth - originX : width;\n      var h = height + originY > sheetHeight ? sheetHeight - originY : height;\n      var boxW = padding[3] + w * scale[0] + padding[1];\n      var boxH = padding[0] + h * scale[1] + padding[2];\n      var boxX = x - padding[3];\n      var boxY = y - padding[0];\n      if (fillStroke || rotation !== 0) {\n        p1[0] = boxX;\n        p4[0] = boxX;\n        p1[1] = boxY;\n        p2[1] = boxY;\n        p2[0] = boxX + boxW;\n        p3[0] = p2[0];\n        p3[1] = boxY + boxH;\n        p4[1] = p3[1];\n      }\n      var transform;\n      if (rotation !== 0) {\n        transform = composeTransform(createTransform(), centerX, centerY, 1, 1, rotation, -centerX, -centerY);\n        applyTransform(transform, p1);\n        applyTransform(transform, p2);\n        applyTransform(transform, p3);\n        applyTransform(transform, p4);\n        createOrUpdate(Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1]), tmpExtent);\n      } else {\n        createOrUpdate(Math.min(boxX, boxX + boxW), Math.min(boxY, boxY + boxH), Math.max(boxX, boxX + boxW), Math.max(boxY, boxY + boxH), tmpExtent);\n      }\n      if (snapToPixel) {\n        x = Math.round(x);\n        y = Math.round(y);\n      }\n      return {\n        drawImageX: x,\n        drawImageY: y,\n        drawImageW: w,\n        drawImageH: h,\n        originX: originX,\n        originY: originY,\n        declutterBox: {\n          minX: tmpExtent[0],\n          minY: tmpExtent[1],\n          maxX: tmpExtent[2],\n          maxY: tmpExtent[3],\n          value: feature\n        },\n        canvasTransform: transform,\n        scale: scale\n      };\n    }\n\n    /**\n     * @private\n     * @param {CanvasRenderingContext2D} context Context.\n     * @param {number} contextScale Scale of the context.\n     * @param {import(\"../canvas.js\").Label|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} imageOrLabel Image.\n     * @param {ImageOrLabelDimensions} dimensions Dimensions.\n     * @param {number} opacity Opacity.\n     * @param {Array<*>} fillInstruction Fill instruction.\n     * @param {Array<*>} strokeInstruction Stroke instruction.\n     * @return {boolean} The image or label was rendered.\n     */\n  }, {\n    key: \"replayImageOrLabel_\",\n    value: function replayImageOrLabel_(context, contextScale, imageOrLabel, dimensions, opacity, fillInstruction, strokeInstruction) {\n      var fillStroke = !!(fillInstruction || strokeInstruction);\n      var box = dimensions.declutterBox;\n      var canvas = context.canvas;\n      var strokePadding = strokeInstruction ? strokeInstruction[2] * dimensions.scale[0] / 2 : 0;\n      var intersects = box.minX - strokePadding <= canvas.width / contextScale && box.maxX + strokePadding >= 0 && box.minY - strokePadding <= canvas.height / contextScale && box.maxY + strokePadding >= 0;\n      if (intersects) {\n        if (fillStroke) {\n          this.replayTextBackground_(context, p1, p2, p3, p4, /** @type {Array<*>} */fillInstruction, /** @type {Array<*>} */strokeInstruction);\n        }\n        drawImageOrLabel(context, dimensions.canvasTransform, opacity, imageOrLabel, dimensions.originX, dimensions.originY, dimensions.drawImageW, dimensions.drawImageH, dimensions.drawImageX, dimensions.drawImageY, dimensions.scale);\n      }\n      return true;\n    }\n\n    /**\n     * @private\n     * @param {CanvasRenderingContext2D} context Context.\n     */\n  }, {\n    key: \"fill_\",\n    value: function fill_(context) {\n      if (this.alignFill_) {\n        var origin = applyTransform(this.renderedTransform_, [0, 0]);\n        var repeatSize = 512 * this.pixelRatio;\n        context.save();\n        context.translate(origin[0] % repeatSize, origin[1] % repeatSize);\n        context.rotate(this.viewRotation_);\n      }\n      context.fill();\n      if (this.alignFill_) {\n        context.restore();\n      }\n    }\n\n    /**\n     * @private\n     * @param {CanvasRenderingContext2D} context Context.\n     * @param {Array<*>} instruction Instruction.\n     */\n  }, {\n    key: \"setStrokeStyle_\",\n    value: function setStrokeStyle_(context, instruction) {\n      context['strokeStyle'] = /** @type {import(\"../../colorlike.js\").ColorLike} */instruction[1];\n      context.lineWidth = /** @type {number} */instruction[2];\n      context.lineCap = /** @type {CanvasLineCap} */instruction[3];\n      context.lineJoin = /** @type {CanvasLineJoin} */instruction[4];\n      context.miterLimit = /** @type {number} */instruction[5];\n      context.lineDashOffset = /** @type {number} */instruction[7];\n      context.setLineDash( /** @type {Array<number>} */instruction[6]);\n    }\n\n    /**\n     * @private\n     * @param {string|Array<string>} text The text to draw.\n     * @param {string} textKey The key of the text state.\n     * @param {string} strokeKey The key for the stroke state.\n     * @param {string} fillKey The key for the fill state.\n     * @return {{label: import(\"../canvas.js\").Label, anchorX: number, anchorY: number}} The text image and its anchor.\n     */\n  }, {\n    key: \"drawLabelWithPointPlacement_\",\n    value: function drawLabelWithPointPlacement_(text, textKey, strokeKey, fillKey) {\n      var textState = this.textStates[textKey];\n      var label = this.createLabel(text, textKey, fillKey, strokeKey);\n      var strokeState = this.strokeStates[strokeKey];\n      var pixelRatio = this.pixelRatio;\n      var align = horizontalTextAlign(Array.isArray(text) ? text[0] : text, textState.textAlign || defaultTextAlign);\n      var baseline = TEXT_ALIGN[textState.textBaseline || defaultTextBaseline];\n      var strokeWidth = strokeState && strokeState.lineWidth ? strokeState.lineWidth : 0;\n\n      // Remove the 2 pixels we added in createLabel() for the anchor\n      var width = label.width / pixelRatio - 2 * textState.scale[0];\n      var anchorX = align * width + 2 * (0.5 - align) * strokeWidth;\n      var anchorY = baseline * label.height / pixelRatio + 2 * (0.5 - baseline) * strokeWidth;\n      return {\n        label: label,\n        anchorX: anchorX,\n        anchorY: anchorY\n      };\n    }\n\n    /**\n     * @private\n     * @param {CanvasRenderingContext2D} context Context.\n     * @param {number} contextScale Scale of the context.\n     * @param {import(\"../../transform.js\").Transform} transform Transform.\n     * @param {Array<*>} instructions Instructions array.\n     * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.\n     * @param {FeatureCallback<T>} [featureCallback] Feature callback.\n     * @param {import(\"../../extent.js\").Extent} [hitExtent] Only check\n     *     features that intersect this extent.\n     * @param {import(\"rbush\").default} [declutterTree] Declutter tree.\n     * @return {T|undefined} Callback result.\n     * @template T\n     */\n  }, {\n    key: \"execute_\",\n    value: function execute_(context, contextScale, transform, instructions, snapToPixel, featureCallback, hitExtent, declutterTree) {\n      /** @type {Array<number>} */\n      var pixelCoordinates;\n      if (this.pixelCoordinates_ && equals(transform, this.renderedTransform_)) {\n        pixelCoordinates = this.pixelCoordinates_;\n      } else {\n        if (!this.pixelCoordinates_) {\n          this.pixelCoordinates_ = [];\n        }\n        pixelCoordinates = transform2D(this.coordinates, 0, this.coordinates.length, 2, transform, this.pixelCoordinates_);\n        transformSetFromArray(this.renderedTransform_, transform);\n      }\n      var i = 0; // instruction index\n      var ii = instructions.length; // end of instructions\n      var d = 0; // data index\n      var dd; // end of per-instruction data\n      var anchorX, anchorY, prevX, prevY, roundX, roundY, image, text, textKey, strokeKey, fillKey;\n      var pendingFill = 0;\n      var pendingStroke = 0;\n      var lastFillInstruction = null;\n      var lastStrokeInstruction = null;\n      var coordinateCache = this.coordinateCache_;\n      var viewRotation = this.viewRotation_;\n      var viewRotationFromTransform = Math.round(Math.atan2(-transform[1], transform[0]) * 1e12) / 1e12;\n      var state = /** @type {import(\"../../render.js\").State} */{\n        context: context,\n        pixelRatio: this.pixelRatio,\n        resolution: this.resolution,\n        rotation: viewRotation\n      };\n\n      // When the batch size gets too big, performance decreases. 200 is a good\n      // balance between batch size and number of fill/stroke instructions.\n      var batchSize = this.instructions != instructions || this.overlaps ? 0 : 200;\n      var /** @type {import(\"../../Feature.js\").FeatureLike} */feature;\n      var x, y, currentGeometry;\n      while (i < ii) {\n        var instruction = instructions[i];\n        var type = /** @type {import(\"./Instruction.js\").default} */\n        instruction[0];\n        switch (type) {\n          case CanvasInstruction.BEGIN_GEOMETRY:\n            feature = /** @type {import(\"../../Feature.js\").FeatureLike} */\n            instruction[1];\n            currentGeometry = instruction[3];\n            if (!feature.getGeometry()) {\n              i = /** @type {number} */instruction[2];\n            } else if (hitExtent !== undefined && !intersects(hitExtent, currentGeometry.getExtent())) {\n              i = /** @type {number} */instruction[2] + 1;\n            } else {\n              ++i;\n            }\n            break;\n          case CanvasInstruction.BEGIN_PATH:\n            if (pendingFill > batchSize) {\n              this.fill_(context);\n              pendingFill = 0;\n            }\n            if (pendingStroke > batchSize) {\n              context.stroke();\n              pendingStroke = 0;\n            }\n            if (!pendingFill && !pendingStroke) {\n              context.beginPath();\n              prevX = NaN;\n              prevY = NaN;\n            }\n            ++i;\n            break;\n          case CanvasInstruction.CIRCLE:\n            d = /** @type {number} */instruction[1];\n            var x1 = pixelCoordinates[d];\n            var y1 = pixelCoordinates[d + 1];\n            var x2 = pixelCoordinates[d + 2];\n            var y2 = pixelCoordinates[d + 3];\n            var dx = x2 - x1;\n            var dy = y2 - y1;\n            var r = Math.sqrt(dx * dx + dy * dy);\n            context.moveTo(x1 + r, y1);\n            context.arc(x1, y1, r, 0, 2 * Math.PI, true);\n            ++i;\n            break;\n          case CanvasInstruction.CLOSE_PATH:\n            context.closePath();\n            ++i;\n            break;\n          case CanvasInstruction.CUSTOM:\n            d = /** @type {number} */instruction[1];\n            dd = instruction[2];\n            var geometry = /** @type {import(\"../../geom/SimpleGeometry.js\").default} */\n            instruction[3];\n            var renderer = instruction[4];\n            var fn = instruction.length == 6 ? instruction[5] : undefined;\n            state.geometry = geometry;\n            state.feature = feature;\n            if (!(i in coordinateCache)) {\n              coordinateCache[i] = [];\n            }\n            var coords = coordinateCache[i];\n            if (fn) {\n              fn(pixelCoordinates, d, dd, 2, coords);\n            } else {\n              coords[0] = pixelCoordinates[d];\n              coords[1] = pixelCoordinates[d + 1];\n              coords.length = 2;\n            }\n            renderer(coords, state);\n            ++i;\n            break;\n          case CanvasInstruction.DRAW_IMAGE:\n            d = /** @type {number} */instruction[1];\n            dd = /** @type {number} */instruction[2];\n            image = /** @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} */\n            instruction[3];\n\n            // Remaining arguments in DRAW_IMAGE are in alphabetical order\n            anchorX = /** @type {number} */instruction[4];\n            anchorY = /** @type {number} */instruction[5];\n            var height = /** @type {number} */instruction[6];\n            var opacity = /** @type {number} */instruction[7];\n            var originX = /** @type {number} */instruction[8];\n            var originY = /** @type {number} */instruction[9];\n            var rotateWithView = /** @type {boolean} */instruction[10];\n            var rotation = /** @type {number} */instruction[11];\n            var scale = /** @type {import(\"../../size.js\").Size} */\n            instruction[12];\n            var width = /** @type {number} */instruction[13];\n            var declutterMode = /** @type {\"declutter\"|\"obstacle\"|\"none\"|undefined} */\n            instruction[14];\n            var declutterImageWithText = /** @type {import(\"../canvas.js\").DeclutterImageWithText} */\n            instruction[15];\n            if (!image && instruction.length >= 20) {\n              // create label images\n              text = /** @type {string} */instruction[19];\n              textKey = /** @type {string} */instruction[20];\n              strokeKey = /** @type {string} */instruction[21];\n              fillKey = /** @type {string} */instruction[22];\n              var labelWithAnchor = this.drawLabelWithPointPlacement_(text, textKey, strokeKey, fillKey);\n              image = labelWithAnchor.label;\n              instruction[3] = image;\n              var textOffsetX = /** @type {number} */instruction[23];\n              anchorX = (labelWithAnchor.anchorX - textOffsetX) * this.pixelRatio;\n              instruction[4] = anchorX;\n              var textOffsetY = /** @type {number} */instruction[24];\n              anchorY = (labelWithAnchor.anchorY - textOffsetY) * this.pixelRatio;\n              instruction[5] = anchorY;\n              height = image.height;\n              instruction[6] = height;\n              width = image.width;\n              instruction[13] = width;\n            }\n            var geometryWidths = void 0;\n            if (instruction.length > 25) {\n              geometryWidths = /** @type {number} */instruction[25];\n            }\n            var padding = void 0,\n              backgroundFill = void 0,\n              backgroundStroke = void 0;\n            if (instruction.length > 17) {\n              padding = /** @type {Array<number>} */instruction[16];\n              backgroundFill = /** @type {boolean} */instruction[17];\n              backgroundStroke = /** @type {boolean} */instruction[18];\n            } else {\n              padding = defaultPadding;\n              backgroundFill = false;\n              backgroundStroke = false;\n            }\n            if (rotateWithView && viewRotationFromTransform) {\n              // Canvas is expected to be rotated to reverse view rotation.\n              rotation += viewRotation;\n            } else if (!rotateWithView && !viewRotationFromTransform) {\n              // Canvas is not rotated, images need to be rotated back to be north-up.\n              rotation -= viewRotation;\n            }\n            var widthIndex = 0;\n            for (; d < dd; d += 2) {\n              if (geometryWidths && geometryWidths[widthIndex++] < width / this.pixelRatio) {\n                continue;\n              }\n              var dimensions = this.calculateImageOrLabelDimensions_(image.width, image.height, pixelCoordinates[d], pixelCoordinates[d + 1], width, height, anchorX, anchorY, originX, originY, rotation, scale, snapToPixel, padding, backgroundFill || backgroundStroke, feature);\n              /** @type {ReplayImageOrLabelArgs} */\n              var args = [context, contextScale, image, dimensions, opacity, backgroundFill ? /** @type {Array<*>} */lastFillInstruction : null, backgroundStroke ? /** @type {Array<*>} */lastStrokeInstruction : null];\n              if (declutterTree) {\n                if (declutterMode === 'none') {\n                  // not rendered in declutter group\n                  continue;\n                } else if (declutterMode === 'obstacle') {\n                  // will always be drawn, thus no collision detection, but insert as obstacle\n                  declutterTree.insert(dimensions.declutterBox);\n                  continue;\n                } else {\n                  var imageArgs = void 0;\n                  var imageDeclutterBox = void 0;\n                  if (declutterImageWithText) {\n                    var index = dd - d;\n                    if (!declutterImageWithText[index]) {\n                      // We now have the image for an image+text combination.\n                      declutterImageWithText[index] = args;\n                      // Don't render anything for now, wait for the text.\n                      continue;\n                    }\n                    imageArgs = declutterImageWithText[index];\n                    delete declutterImageWithText[index];\n                    imageDeclutterBox = getDeclutterBox(imageArgs);\n                    if (declutterTree.collides(imageDeclutterBox)) {\n                      continue;\n                    }\n                  }\n                  if (declutterTree.collides(dimensions.declutterBox)) {\n                    continue;\n                  }\n                  if (imageArgs) {\n                    // We now have image and text for an image+text combination.\n                    declutterTree.insert(imageDeclutterBox);\n                    // Render the image before we render the text.\n                    this.replayImageOrLabel_.apply(this, imageArgs);\n                  }\n                  declutterTree.insert(dimensions.declutterBox);\n                }\n              }\n              this.replayImageOrLabel_.apply(this, args);\n            }\n            ++i;\n            break;\n          case CanvasInstruction.DRAW_CHARS:\n            var begin = /** @type {number} */instruction[1];\n            var end = /** @type {number} */instruction[2];\n            var baseline = /** @type {number} */instruction[3];\n            var overflow = /** @type {number} */instruction[4];\n            fillKey = /** @type {string} */instruction[5];\n            var maxAngle = /** @type {number} */instruction[6];\n            var measurePixelRatio = /** @type {number} */instruction[7];\n            var offsetY = /** @type {number} */instruction[8];\n            strokeKey = /** @type {string} */instruction[9];\n            var strokeWidth = /** @type {number} */instruction[10];\n            text = /** @type {string} */instruction[11];\n            textKey = /** @type {string} */instruction[12];\n            var pixelRatioScale = [/** @type {number} */instruction[13], /** @type {number} */instruction[13]];\n            var textState = this.textStates[textKey];\n            var font = textState.font;\n            var textScale = [textState.scale[0] * measurePixelRatio, textState.scale[1] * measurePixelRatio];\n            var cachedWidths = void 0;\n            if (font in this.widths_) {\n              cachedWidths = this.widths_[font];\n            } else {\n              cachedWidths = {};\n              this.widths_[font] = cachedWidths;\n            }\n            var pathLength = lineStringLength(pixelCoordinates, begin, end, 2);\n            var textLength = Math.abs(textScale[0]) * measureAndCacheTextWidth(font, text, cachedWidths);\n            if (overflow || textLength <= pathLength) {\n              var textAlign = this.textStates[textKey].textAlign;\n              var startM = (pathLength - textLength) * TEXT_ALIGN[textAlign];\n              var parts = drawTextOnPath(pixelCoordinates, begin, end, 2, text, startM, maxAngle, Math.abs(textScale[0]), measureAndCacheTextWidth, font, cachedWidths, viewRotationFromTransform ? 0 : this.viewRotation_);\n              drawChars: if (parts) {\n                /** @type {Array<ReplayImageOrLabelArgs>} */\n                var replayImageOrLabelArgs = [];\n                var c = void 0,\n                  cc = void 0,\n                  chars = void 0,\n                  label = void 0,\n                  part = void 0;\n                if (strokeKey) {\n                  for (c = 0, cc = parts.length; c < cc; ++c) {\n                    part = parts[c]; // x, y, anchorX, rotation, chunk\n                    chars = /** @type {string} */part[4];\n                    label = this.createLabel(chars, textKey, '', strokeKey);\n                    anchorX = /** @type {number} */part[2] + (textScale[0] < 0 ? -strokeWidth : strokeWidth);\n                    anchorY = baseline * label.height + (0.5 - baseline) * 2 * strokeWidth * textScale[1] / textScale[0] - offsetY;\n                    var _dimensions = this.calculateImageOrLabelDimensions_(label.width, label.height, part[0], part[1], label.width, label.height, anchorX, anchorY, 0, 0, part[3], pixelRatioScale, false, defaultPadding, false, feature);\n                    if (declutterTree && declutterTree.collides(_dimensions.declutterBox)) {\n                      break drawChars;\n                    }\n                    replayImageOrLabelArgs.push([context, contextScale, label, _dimensions, 1, null, null]);\n                  }\n                }\n                if (fillKey) {\n                  for (c = 0, cc = parts.length; c < cc; ++c) {\n                    part = parts[c]; // x, y, anchorX, rotation, chunk\n                    chars = /** @type {string} */part[4];\n                    label = this.createLabel(chars, textKey, fillKey, '');\n                    anchorX = /** @type {number} */part[2];\n                    anchorY = baseline * label.height - offsetY;\n                    var _dimensions2 = this.calculateImageOrLabelDimensions_(label.width, label.height, part[0], part[1], label.width, label.height, anchorX, anchorY, 0, 0, part[3], pixelRatioScale, false, defaultPadding, false, feature);\n                    if (declutterTree && declutterTree.collides(_dimensions2.declutterBox)) {\n                      break drawChars;\n                    }\n                    replayImageOrLabelArgs.push([context, contextScale, label, _dimensions2, 1, null, null]);\n                  }\n                }\n                if (declutterTree) {\n                  declutterTree.load(replayImageOrLabelArgs.map(getDeclutterBox));\n                }\n                for (var _i = 0, _ii = replayImageOrLabelArgs.length; _i < _ii; ++_i) {\n                  this.replayImageOrLabel_.apply(this, replayImageOrLabelArgs[_i]);\n                }\n              }\n            }\n            ++i;\n            break;\n          case CanvasInstruction.END_GEOMETRY:\n            if (featureCallback !== undefined) {\n              feature = /** @type {import(\"../../Feature.js\").FeatureLike} */\n              instruction[1];\n              var result = featureCallback(feature, currentGeometry);\n              if (result) {\n                return result;\n              }\n            }\n            ++i;\n            break;\n          case CanvasInstruction.FILL:\n            if (batchSize) {\n              pendingFill++;\n            } else {\n              this.fill_(context);\n            }\n            ++i;\n            break;\n          case CanvasInstruction.MOVE_TO_LINE_TO:\n            d = /** @type {number} */instruction[1];\n            dd = /** @type {number} */instruction[2];\n            x = pixelCoordinates[d];\n            y = pixelCoordinates[d + 1];\n            roundX = x + 0.5 | 0;\n            roundY = y + 0.5 | 0;\n            if (roundX !== prevX || roundY !== prevY) {\n              context.moveTo(x, y);\n              prevX = roundX;\n              prevY = roundY;\n            }\n            for (d += 2; d < dd; d += 2) {\n              x = pixelCoordinates[d];\n              y = pixelCoordinates[d + 1];\n              roundX = x + 0.5 | 0;\n              roundY = y + 0.5 | 0;\n              if (d == dd - 2 || roundX !== prevX || roundY !== prevY) {\n                context.lineTo(x, y);\n                prevX = roundX;\n                prevY = roundY;\n              }\n            }\n            ++i;\n            break;\n          case CanvasInstruction.SET_FILL_STYLE:\n            lastFillInstruction = instruction;\n            this.alignFill_ = instruction[2];\n            if (pendingFill) {\n              this.fill_(context);\n              pendingFill = 0;\n              if (pendingStroke) {\n                context.stroke();\n                pendingStroke = 0;\n              }\n            }\n            context.fillStyle = /** @type {import(\"../../colorlike.js\").ColorLike} */\n            instruction[1];\n            ++i;\n            break;\n          case CanvasInstruction.SET_STROKE_STYLE:\n            lastStrokeInstruction = instruction;\n            if (pendingStroke) {\n              context.stroke();\n              pendingStroke = 0;\n            }\n            this.setStrokeStyle_(context, /** @type {Array<*>} */instruction);\n            ++i;\n            break;\n          case CanvasInstruction.STROKE:\n            if (batchSize) {\n              pendingStroke++;\n            } else {\n              context.stroke();\n            }\n            ++i;\n            break;\n          default:\n            // consume the instruction anyway, to avoid an infinite loop\n            ++i;\n            break;\n        }\n      }\n      if (pendingFill) {\n        this.fill_(context);\n      }\n      if (pendingStroke) {\n        context.stroke();\n      }\n      return undefined;\n    }\n\n    /**\n     * @param {CanvasRenderingContext2D} context Context.\n     * @param {number} contextScale Scale of the context.\n     * @param {import(\"../../transform.js\").Transform} transform Transform.\n     * @param {number} viewRotation View rotation.\n     * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.\n     * @param {import(\"rbush\").default} [declutterTree] Declutter tree.\n     */\n  }, {\n    key: \"execute\",\n    value: function execute(context, contextScale, transform, viewRotation, snapToPixel, declutterTree) {\n      this.viewRotation_ = viewRotation;\n      this.execute_(context, contextScale, transform, this.instructions, snapToPixel, undefined, undefined, declutterTree);\n    }\n\n    /**\n     * @param {CanvasRenderingContext2D} context Context.\n     * @param {import(\"../../transform.js\").Transform} transform Transform.\n     * @param {number} viewRotation View rotation.\n     * @param {FeatureCallback<T>} [featureCallback] Feature callback.\n     * @param {import(\"../../extent.js\").Extent} [hitExtent] Only check\n     *     features that intersect this extent.\n     * @return {T|undefined} Callback result.\n     * @template T\n     */\n  }, {\n    key: \"executeHitDetection\",\n    value: function executeHitDetection(context, transform, viewRotation, featureCallback, hitExtent) {\n      this.viewRotation_ = viewRotation;\n      return this.execute_(context, 1, transform, this.hitDetectionInstructions, true, featureCallback, hitExtent);\n    }\n  }]);\n  return Executor;\n}();\nexport default Executor;","map":{"version":3,"names":["CanvasInstruction","TEXT_ALIGN","apply","applyTransform","compose","composeTransform","create","createTransform","setFromArray","transformSetFromArray","createEmpty","createOrUpdate","intersects","defaultPadding","defaultTextAlign","defaultTextBaseline","drawImageOrLabel","getTextDimensions","measureAndCacheTextWidth","drawTextOnPath","equals","lineStringLength","transform2D","tmpExtent","p1","p2","p3","p4","getDeclutterBox","replayImageOrLabelArgs","declutterBox","rtlRegEx","RegExp","String","fromCharCode","horizontalTextAlign","text","align","test","createTextChunks","acc","line","i","push","Executor","resolution","pixelRatio","overlaps","instructions","_classCallCheck","alignFill_","coordinates","coordinateCache_","renderedTransform_","hitDetectionInstructions","pixelCoordinates_","viewRotation_","fillStates","strokeStates","textStates","widths_","labels_","_createClass","key","value","createLabel","textKey","fillKey","strokeKey","strokeState","fillState","textState","scale","textIsArray","Array","isArray","justify","textAlign","strokeWidth","lineWidth","chunks","split","reduce","_getTextDimensions","width","height","widths","heights","lineWidths","renderWidth","contextInstructions","w","h","label","Math","floor","ceil","strokeStyle","lineCap","lineJoin","miterLimit","lineDash","lineDashOffset","fillStyle","leftRight","x","strokeInstructions","fillInstructions","lineHeight","lineOffset","widthHeightIndex","lineWidthIndex","previousFont","ii","length","font","max","fillStrokeArgs","prototype","replayTextBackground_","context","fillInstruction","strokeInstruction","beginPath","moveTo","lineTo","fill_","setStrokeStyle_","stroke","calculateImageOrLabelDimensions_","sheetWidth","sheetHeight","centerX","centerY","anchorX","anchorY","originX","originY","rotation","snapToPixel","padding","fillStroke","feature","y","boxW","boxH","boxX","boxY","transform","min","round","drawImageX","drawImageY","drawImageW","drawImageH","minX","minY","maxX","maxY","canvasTransform","replayImageOrLabel_","contextScale","imageOrLabel","dimensions","opacity","box","canvas","strokePadding","origin","repeatSize","save","translate","rotate","fill","restore","instruction","setLineDash","drawLabelWithPointPlacement_","baseline","textBaseline","execute_","featureCallback","hitExtent","declutterTree","pixelCoordinates","d","dd","prevX","prevY","roundX","roundY","image","pendingFill","pendingStroke","lastFillInstruction","lastStrokeInstruction","coordinateCache","viewRotation","viewRotationFromTransform","atan2","state","batchSize","currentGeometry","type","BEGIN_GEOMETRY","getGeometry","undefined","getExtent","BEGIN_PATH","NaN","CIRCLE","x1","y1","x2","y2","dx","dy","r","sqrt","arc","PI","CLOSE_PATH","closePath","CUSTOM","geometry","renderer","fn","coords","DRAW_IMAGE","rotateWithView","declutterMode","declutterImageWithText","labelWithAnchor","textOffsetX","textOffsetY","geometryWidths","backgroundFill","backgroundStroke","widthIndex","args","insert","imageArgs","imageDeclutterBox","index","collides","DRAW_CHARS","begin","end","overflow","maxAngle","measurePixelRatio","offsetY","pixelRatioScale","textScale","cachedWidths","pathLength","textLength","abs","startM","parts","drawChars","c","cc","chars","part","load","map","END_GEOMETRY","result","FILL","MOVE_TO_LINE_TO","SET_FILL_STYLE","SET_STROKE_STYLE","STROKE","execute","executeHitDetection"],"sources":["/home/jay/Downloads/major/my-app/gis/web-gis/node_modules/ol/render/canvas/Executor.js"],"sourcesContent":["/**\n * @module ol/render/canvas/Executor\n */\nimport CanvasInstruction from './Instruction.js';\nimport {TEXT_ALIGN} from './TextBuilder.js';\nimport {\n  apply as applyTransform,\n  compose as composeTransform,\n  create as createTransform,\n  setFromArray as transformSetFromArray,\n} from '../../transform.js';\nimport {createEmpty, createOrUpdate, intersects} from '../../extent.js';\nimport {\n  defaultPadding,\n  defaultTextAlign,\n  defaultTextBaseline,\n  drawImageOrLabel,\n  getTextDimensions,\n  measureAndCacheTextWidth,\n} from '../canvas.js';\nimport {drawTextOnPath} from '../../geom/flat/textpath.js';\nimport {equals} from '../../array.js';\nimport {lineStringLength} from '../../geom/flat/length.js';\nimport {transform2D} from '../../geom/flat/transform.js';\n\n/**\n * @typedef {Object} BBox\n * @property {number} minX Minimal x.\n * @property {number} minY Minimal y.\n * @property {number} maxX Maximal x.\n * @property {number} maxY Maximal y\n * @property {*} value Value.\n */\n\n/**\n * @typedef {Object} ImageOrLabelDimensions\n * @property {number} drawImageX DrawImageX.\n * @property {number} drawImageY DrawImageY.\n * @property {number} drawImageW DrawImageW.\n * @property {number} drawImageH DrawImageH.\n * @property {number} originX OriginX.\n * @property {number} originY OriginY.\n * @property {Array<number>} scale Scale.\n * @property {BBox} declutterBox DeclutterBox.\n * @property {import(\"../../transform.js\").Transform} canvasTransform CanvasTransform.\n */\n\n/**\n * @typedef {{0: CanvasRenderingContext2D, 1: number, 2: import(\"../canvas.js\").Label|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement, 3: ImageOrLabelDimensions, 4: number, 5: Array<*>, 6: Array<*>}} ReplayImageOrLabelArgs\n */\n\n/**\n * @template T\n * @typedef {function(import(\"../../Feature.js\").FeatureLike, import(\"../../geom/SimpleGeometry.js\").default): T} FeatureCallback\n */\n\n/**\n * @type {import(\"../../extent.js\").Extent}\n */\nconst tmpExtent = createEmpty();\n\n/** @type {import(\"../../coordinate.js\").Coordinate} */\nconst p1 = [];\n/** @type {import(\"../../coordinate.js\").Coordinate} */\nconst p2 = [];\n/** @type {import(\"../../coordinate.js\").Coordinate} */\nconst p3 = [];\n/** @type {import(\"../../coordinate.js\").Coordinate} */\nconst p4 = [];\n\n/**\n * @param {ReplayImageOrLabelArgs} replayImageOrLabelArgs Arguments to replayImageOrLabel\n * @return {BBox} Declutter bbox.\n */\nfunction getDeclutterBox(replayImageOrLabelArgs) {\n  return replayImageOrLabelArgs[3].declutterBox;\n}\n\nconst rtlRegEx = new RegExp(\n  /* eslint-disable prettier/prettier */\n  '[' +\n    String.fromCharCode(0x00591) + '-' + String.fromCharCode(0x008ff) +\n    String.fromCharCode(0x0fb1d) + '-' + String.fromCharCode(0x0fdff) +\n    String.fromCharCode(0x0fe70) + '-' + String.fromCharCode(0x0fefc) +\n    String.fromCharCode(0x10800) + '-' + String.fromCharCode(0x10fff) +\n    String.fromCharCode(0x1e800) + '-' + String.fromCharCode(0x1efff) +\n  ']'\n  /* eslint-enable prettier/prettier */\n);\n\n/**\n * @param {string} text Text.\n * @param {CanvasTextAlign} align Alignment.\n * @return {number} Text alignment.\n */\nfunction horizontalTextAlign(text, align) {\n  if ((align === 'start' || align === 'end') && !rtlRegEx.test(text)) {\n    align = align === 'start' ? 'left' : 'right';\n  }\n  return TEXT_ALIGN[align];\n}\n\n/**\n * @param {Array<string>} acc Accumulator.\n * @param {string} line Line of text.\n * @param {number} i Index\n * @return {Array<string>} Accumulator.\n */\nfunction createTextChunks(acc, line, i) {\n  if (i > 0) {\n    acc.push('\\n', '');\n  }\n  acc.push(line, '');\n  return acc;\n}\n\nclass Executor {\n  /**\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {boolean} overlaps The replay can have overlapping geometries.\n   * @param {import(\"../canvas.js\").SerializableInstructions} instructions The serializable instructions\n   */\n  constructor(resolution, pixelRatio, overlaps, instructions) {\n    /**\n     * @protected\n     * @type {boolean}\n     */\n    this.overlaps = overlaps;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.pixelRatio = pixelRatio;\n\n    /**\n     * @protected\n     * @const\n     * @type {number}\n     */\n    this.resolution = resolution;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.alignFill_;\n\n    /**\n     * @protected\n     * @type {Array<*>}\n     */\n    this.instructions = instructions.instructions;\n\n    /**\n     * @protected\n     * @type {Array<number>}\n     */\n    this.coordinates = instructions.coordinates;\n\n    /**\n     * @private\n     * @type {!Object<number,import(\"../../coordinate.js\").Coordinate|Array<import(\"../../coordinate.js\").Coordinate>|Array<Array<import(\"../../coordinate.js\").Coordinate>>>}\n     */\n    this.coordinateCache_ = {};\n\n    /**\n     * @private\n     * @type {!import(\"../../transform.js\").Transform}\n     */\n    this.renderedTransform_ = createTransform();\n\n    /**\n     * @protected\n     * @type {Array<*>}\n     */\n    this.hitDetectionInstructions = instructions.hitDetectionInstructions;\n\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    this.pixelCoordinates_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.viewRotation_ = 0;\n\n    /**\n     * @type {!Object<string, import(\"../canvas.js\").FillState>}\n     */\n    this.fillStates = instructions.fillStates || {};\n\n    /**\n     * @type {!Object<string, import(\"../canvas.js\").StrokeState>}\n     */\n    this.strokeStates = instructions.strokeStates || {};\n\n    /**\n     * @type {!Object<string, import(\"../canvas.js\").TextState>}\n     */\n    this.textStates = instructions.textStates || {};\n\n    /**\n     * @private\n     * @type {Object<string, Object<string, number>>}\n     */\n    this.widths_ = {};\n\n    /**\n     * @private\n     * @type {Object<string, import(\"../canvas.js\").Label>}\n     */\n    this.labels_ = {};\n  }\n\n  /**\n   * @param {string|Array<string>} text Text.\n   * @param {string} textKey Text style key.\n   * @param {string} fillKey Fill style key.\n   * @param {string} strokeKey Stroke style key.\n   * @return {import(\"../canvas.js\").Label} Label.\n   */\n  createLabel(text, textKey, fillKey, strokeKey) {\n    const key = text + textKey + fillKey + strokeKey;\n    if (this.labels_[key]) {\n      return this.labels_[key];\n    }\n    const strokeState = strokeKey ? this.strokeStates[strokeKey] : null;\n    const fillState = fillKey ? this.fillStates[fillKey] : null;\n    const textState = this.textStates[textKey];\n    const pixelRatio = this.pixelRatio;\n    const scale = [\n      textState.scale[0] * pixelRatio,\n      textState.scale[1] * pixelRatio,\n    ];\n    const textIsArray = Array.isArray(text);\n    const align = textState.justify\n      ? TEXT_ALIGN[textState.justify]\n      : horizontalTextAlign(\n          Array.isArray(text) ? text[0] : text,\n          textState.textAlign || defaultTextAlign\n        );\n    const strokeWidth =\n      strokeKey && strokeState.lineWidth ? strokeState.lineWidth : 0;\n\n    const chunks = textIsArray\n      ? text\n      : text.split('\\n').reduce(createTextChunks, []);\n\n    const {width, height, widths, heights, lineWidths} = getTextDimensions(\n      textState,\n      chunks\n    );\n    const renderWidth = width + strokeWidth;\n    const contextInstructions = [];\n    // make canvas 2 pixels wider to account for italic text width measurement errors\n    const w = (renderWidth + 2) * scale[0];\n    const h = (height + strokeWidth) * scale[1];\n    /** @type {import(\"../canvas.js\").Label} */\n    const label = {\n      width: w < 0 ? Math.floor(w) : Math.ceil(w),\n      height: h < 0 ? Math.floor(h) : Math.ceil(h),\n      contextInstructions: contextInstructions,\n    };\n    if (scale[0] != 1 || scale[1] != 1) {\n      contextInstructions.push('scale', scale);\n    }\n    if (strokeKey) {\n      contextInstructions.push('strokeStyle', strokeState.strokeStyle);\n      contextInstructions.push('lineWidth', strokeWidth);\n      contextInstructions.push('lineCap', strokeState.lineCap);\n      contextInstructions.push('lineJoin', strokeState.lineJoin);\n      contextInstructions.push('miterLimit', strokeState.miterLimit);\n      contextInstructions.push('setLineDash', [strokeState.lineDash]);\n      contextInstructions.push('lineDashOffset', strokeState.lineDashOffset);\n    }\n    if (fillKey) {\n      contextInstructions.push('fillStyle', fillState.fillStyle);\n    }\n    contextInstructions.push('textBaseline', 'middle');\n    contextInstructions.push('textAlign', 'center');\n    const leftRight = 0.5 - align;\n    let x = align * renderWidth + leftRight * strokeWidth;\n    const strokeInstructions = [];\n    const fillInstructions = [];\n    let lineHeight = 0;\n    let lineOffset = 0;\n    let widthHeightIndex = 0;\n    let lineWidthIndex = 0;\n    let previousFont;\n    for (let i = 0, ii = chunks.length; i < ii; i += 2) {\n      const text = chunks[i];\n      if (text === '\\n') {\n        lineOffset += lineHeight;\n        lineHeight = 0;\n        x = align * renderWidth + leftRight * strokeWidth;\n        ++lineWidthIndex;\n        continue;\n      }\n      const font = chunks[i + 1] || textState.font;\n      if (font !== previousFont) {\n        if (strokeKey) {\n          strokeInstructions.push('font', font);\n        }\n        if (fillKey) {\n          fillInstructions.push('font', font);\n        }\n        previousFont = font;\n      }\n      lineHeight = Math.max(lineHeight, heights[widthHeightIndex]);\n      const fillStrokeArgs = [\n        text,\n        x +\n          leftRight * widths[widthHeightIndex] +\n          align * (widths[widthHeightIndex] - lineWidths[lineWidthIndex]),\n        0.5 * (strokeWidth + lineHeight) + lineOffset,\n      ];\n      x += widths[widthHeightIndex];\n      if (strokeKey) {\n        strokeInstructions.push('strokeText', fillStrokeArgs);\n      }\n      if (fillKey) {\n        fillInstructions.push('fillText', fillStrokeArgs);\n      }\n      ++widthHeightIndex;\n    }\n    Array.prototype.push.apply(contextInstructions, strokeInstructions);\n    Array.prototype.push.apply(contextInstructions, fillInstructions);\n    this.labels_[key] = label;\n    return label;\n  }\n\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../coordinate.js\").Coordinate} p1 1st point of the background box.\n   * @param {import(\"../../coordinate.js\").Coordinate} p2 2nd point of the background box.\n   * @param {import(\"../../coordinate.js\").Coordinate} p3 3rd point of the background box.\n   * @param {import(\"../../coordinate.js\").Coordinate} p4 4th point of the background box.\n   * @param {Array<*>} fillInstruction Fill instruction.\n   * @param {Array<*>} strokeInstruction Stroke instruction.\n   */\n  replayTextBackground_(\n    context,\n    p1,\n    p2,\n    p3,\n    p4,\n    fillInstruction,\n    strokeInstruction\n  ) {\n    context.beginPath();\n    context.moveTo.apply(context, p1);\n    context.lineTo.apply(context, p2);\n    context.lineTo.apply(context, p3);\n    context.lineTo.apply(context, p4);\n    context.lineTo.apply(context, p1);\n    if (fillInstruction) {\n      this.alignFill_ = /** @type {boolean} */ (fillInstruction[2]);\n      this.fill_(context);\n    }\n    if (strokeInstruction) {\n      this.setStrokeStyle_(\n        context,\n        /** @type {Array<*>} */ (strokeInstruction)\n      );\n      context.stroke();\n    }\n  }\n\n  /**\n   * @private\n   * @param {number} sheetWidth Width of the sprite sheet.\n   * @param {number} sheetHeight Height of the sprite sheet.\n   * @param {number} centerX X.\n   * @param {number} centerY Y.\n   * @param {number} width Width.\n   * @param {number} height Height.\n   * @param {number} anchorX Anchor X.\n   * @param {number} anchorY Anchor Y.\n   * @param {number} originX Origin X.\n   * @param {number} originY Origin Y.\n   * @param {number} rotation Rotation.\n   * @param {import(\"../../size.js\").Size} scale Scale.\n   * @param {boolean} snapToPixel Snap to pixel.\n   * @param {Array<number>} padding Padding.\n   * @param {boolean} fillStroke Background fill or stroke.\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   * @return {ImageOrLabelDimensions} Dimensions for positioning and decluttering the image or label.\n   */\n  calculateImageOrLabelDimensions_(\n    sheetWidth,\n    sheetHeight,\n    centerX,\n    centerY,\n    width,\n    height,\n    anchorX,\n    anchorY,\n    originX,\n    originY,\n    rotation,\n    scale,\n    snapToPixel,\n    padding,\n    fillStroke,\n    feature\n  ) {\n    anchorX *= scale[0];\n    anchorY *= scale[1];\n    let x = centerX - anchorX;\n    let y = centerY - anchorY;\n\n    const w = width + originX > sheetWidth ? sheetWidth - originX : width;\n    const h = height + originY > sheetHeight ? sheetHeight - originY : height;\n    const boxW = padding[3] + w * scale[0] + padding[1];\n    const boxH = padding[0] + h * scale[1] + padding[2];\n    const boxX = x - padding[3];\n    const boxY = y - padding[0];\n\n    if (fillStroke || rotation !== 0) {\n      p1[0] = boxX;\n      p4[0] = boxX;\n      p1[1] = boxY;\n      p2[1] = boxY;\n      p2[0] = boxX + boxW;\n      p3[0] = p2[0];\n      p3[1] = boxY + boxH;\n      p4[1] = p3[1];\n    }\n\n    let transform;\n    if (rotation !== 0) {\n      transform = composeTransform(\n        createTransform(),\n        centerX,\n        centerY,\n        1,\n        1,\n        rotation,\n        -centerX,\n        -centerY\n      );\n\n      applyTransform(transform, p1);\n      applyTransform(transform, p2);\n      applyTransform(transform, p3);\n      applyTransform(transform, p4);\n      createOrUpdate(\n        Math.min(p1[0], p2[0], p3[0], p4[0]),\n        Math.min(p1[1], p2[1], p3[1], p4[1]),\n        Math.max(p1[0], p2[0], p3[0], p4[0]),\n        Math.max(p1[1], p2[1], p3[1], p4[1]),\n        tmpExtent\n      );\n    } else {\n      createOrUpdate(\n        Math.min(boxX, boxX + boxW),\n        Math.min(boxY, boxY + boxH),\n        Math.max(boxX, boxX + boxW),\n        Math.max(boxY, boxY + boxH),\n        tmpExtent\n      );\n    }\n    if (snapToPixel) {\n      x = Math.round(x);\n      y = Math.round(y);\n    }\n    return {\n      drawImageX: x,\n      drawImageY: y,\n      drawImageW: w,\n      drawImageH: h,\n      originX: originX,\n      originY: originY,\n      declutterBox: {\n        minX: tmpExtent[0],\n        minY: tmpExtent[1],\n        maxX: tmpExtent[2],\n        maxY: tmpExtent[3],\n        value: feature,\n      },\n      canvasTransform: transform,\n      scale: scale,\n    };\n  }\n\n  /**\n   * @private\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {number} contextScale Scale of the context.\n   * @param {import(\"../canvas.js\").Label|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} imageOrLabel Image.\n   * @param {ImageOrLabelDimensions} dimensions Dimensions.\n   * @param {number} opacity Opacity.\n   * @param {Array<*>} fillInstruction Fill instruction.\n   * @param {Array<*>} strokeInstruction Stroke instruction.\n   * @return {boolean} The image or label was rendered.\n   */\n  replayImageOrLabel_(\n    context,\n    contextScale,\n    imageOrLabel,\n    dimensions,\n    opacity,\n    fillInstruction,\n    strokeInstruction\n  ) {\n    const fillStroke = !!(fillInstruction || strokeInstruction);\n\n    const box = dimensions.declutterBox;\n    const canvas = context.canvas;\n    const strokePadding = strokeInstruction\n      ? (strokeInstruction[2] * dimensions.scale[0]) / 2\n      : 0;\n    const intersects =\n      box.minX - strokePadding <= canvas.width / contextScale &&\n      box.maxX + strokePadding >= 0 &&\n      box.minY - strokePadding <= canvas.height / contextScale &&\n      box.maxY + strokePadding >= 0;\n\n    if (intersects) {\n      if (fillStroke) {\n        this.replayTextBackground_(\n          context,\n          p1,\n          p2,\n          p3,\n          p4,\n          /** @type {Array<*>} */ (fillInstruction),\n          /** @type {Array<*>} */ (strokeInstruction)\n        );\n      }\n      drawImageOrLabel(\n        context,\n        dimensions.canvasTransform,\n        opacity,\n        imageOrLabel,\n        dimensions.originX,\n        dimensions.originY,\n        dimensions.drawImageW,\n        dimensions.drawImageH,\n        dimensions.drawImageX,\n        dimensions.drawImageY,\n        dimensions.scale\n      );\n    }\n    return true;\n  }\n\n  /**\n   * @private\n   * @param {CanvasRenderingContext2D} context Context.\n   */\n  fill_(context) {\n    if (this.alignFill_) {\n      const origin = applyTransform(this.renderedTransform_, [0, 0]);\n      const repeatSize = 512 * this.pixelRatio;\n      context.save();\n      context.translate(origin[0] % repeatSize, origin[1] % repeatSize);\n      context.rotate(this.viewRotation_);\n    }\n    context.fill();\n    if (this.alignFill_) {\n      context.restore();\n    }\n  }\n\n  /**\n   * @private\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {Array<*>} instruction Instruction.\n   */\n  setStrokeStyle_(context, instruction) {\n    context['strokeStyle'] =\n      /** @type {import(\"../../colorlike.js\").ColorLike} */ (instruction[1]);\n    context.lineWidth = /** @type {number} */ (instruction[2]);\n    context.lineCap = /** @type {CanvasLineCap} */ (instruction[3]);\n    context.lineJoin = /** @type {CanvasLineJoin} */ (instruction[4]);\n    context.miterLimit = /** @type {number} */ (instruction[5]);\n    context.lineDashOffset = /** @type {number} */ (instruction[7]);\n    context.setLineDash(/** @type {Array<number>} */ (instruction[6]));\n  }\n\n  /**\n   * @private\n   * @param {string|Array<string>} text The text to draw.\n   * @param {string} textKey The key of the text state.\n   * @param {string} strokeKey The key for the stroke state.\n   * @param {string} fillKey The key for the fill state.\n   * @return {{label: import(\"../canvas.js\").Label, anchorX: number, anchorY: number}} The text image and its anchor.\n   */\n  drawLabelWithPointPlacement_(text, textKey, strokeKey, fillKey) {\n    const textState = this.textStates[textKey];\n\n    const label = this.createLabel(text, textKey, fillKey, strokeKey);\n\n    const strokeState = this.strokeStates[strokeKey];\n    const pixelRatio = this.pixelRatio;\n    const align = horizontalTextAlign(\n      Array.isArray(text) ? text[0] : text,\n      textState.textAlign || defaultTextAlign\n    );\n    const baseline = TEXT_ALIGN[textState.textBaseline || defaultTextBaseline];\n    const strokeWidth =\n      strokeState && strokeState.lineWidth ? strokeState.lineWidth : 0;\n\n    // Remove the 2 pixels we added in createLabel() for the anchor\n    const width = label.width / pixelRatio - 2 * textState.scale[0];\n    const anchorX = align * width + 2 * (0.5 - align) * strokeWidth;\n    const anchorY =\n      (baseline * label.height) / pixelRatio +\n      2 * (0.5 - baseline) * strokeWidth;\n\n    return {\n      label: label,\n      anchorX: anchorX,\n      anchorY: anchorY,\n    };\n  }\n\n  /**\n   * @private\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {number} contextScale Scale of the context.\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\n   * @param {Array<*>} instructions Instructions array.\n   * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.\n   * @param {FeatureCallback<T>} [featureCallback] Feature callback.\n   * @param {import(\"../../extent.js\").Extent} [hitExtent] Only check\n   *     features that intersect this extent.\n   * @param {import(\"rbush\").default} [declutterTree] Declutter tree.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n  execute_(\n    context,\n    contextScale,\n    transform,\n    instructions,\n    snapToPixel,\n    featureCallback,\n    hitExtent,\n    declutterTree\n  ) {\n    /** @type {Array<number>} */\n    let pixelCoordinates;\n    if (this.pixelCoordinates_ && equals(transform, this.renderedTransform_)) {\n      pixelCoordinates = this.pixelCoordinates_;\n    } else {\n      if (!this.pixelCoordinates_) {\n        this.pixelCoordinates_ = [];\n      }\n      pixelCoordinates = transform2D(\n        this.coordinates,\n        0,\n        this.coordinates.length,\n        2,\n        transform,\n        this.pixelCoordinates_\n      );\n      transformSetFromArray(this.renderedTransform_, transform);\n    }\n    let i = 0; // instruction index\n    const ii = instructions.length; // end of instructions\n    let d = 0; // data index\n    let dd; // end of per-instruction data\n    let anchorX,\n      anchorY,\n      prevX,\n      prevY,\n      roundX,\n      roundY,\n      image,\n      text,\n      textKey,\n      strokeKey,\n      fillKey;\n    let pendingFill = 0;\n    let pendingStroke = 0;\n    let lastFillInstruction = null;\n    let lastStrokeInstruction = null;\n    const coordinateCache = this.coordinateCache_;\n    const viewRotation = this.viewRotation_;\n    const viewRotationFromTransform =\n      Math.round(Math.atan2(-transform[1], transform[0]) * 1e12) / 1e12;\n\n    const state = /** @type {import(\"../../render.js\").State} */ ({\n      context: context,\n      pixelRatio: this.pixelRatio,\n      resolution: this.resolution,\n      rotation: viewRotation,\n    });\n\n    // When the batch size gets too big, performance decreases. 200 is a good\n    // balance between batch size and number of fill/stroke instructions.\n    const batchSize =\n      this.instructions != instructions || this.overlaps ? 0 : 200;\n    let /** @type {import(\"../../Feature.js\").FeatureLike} */ feature;\n    let x, y, currentGeometry;\n    while (i < ii) {\n      const instruction = instructions[i];\n      const type = /** @type {import(\"./Instruction.js\").default} */ (\n        instruction[0]\n      );\n      switch (type) {\n        case CanvasInstruction.BEGIN_GEOMETRY:\n          feature = /** @type {import(\"../../Feature.js\").FeatureLike} */ (\n            instruction[1]\n          );\n          currentGeometry = instruction[3];\n          if (!feature.getGeometry()) {\n            i = /** @type {number} */ (instruction[2]);\n          } else if (\n            hitExtent !== undefined &&\n            !intersects(hitExtent, currentGeometry.getExtent())\n          ) {\n            i = /** @type {number} */ (instruction[2]) + 1;\n          } else {\n            ++i;\n          }\n          break;\n        case CanvasInstruction.BEGIN_PATH:\n          if (pendingFill > batchSize) {\n            this.fill_(context);\n            pendingFill = 0;\n          }\n          if (pendingStroke > batchSize) {\n            context.stroke();\n            pendingStroke = 0;\n          }\n          if (!pendingFill && !pendingStroke) {\n            context.beginPath();\n            prevX = NaN;\n            prevY = NaN;\n          }\n          ++i;\n          break;\n        case CanvasInstruction.CIRCLE:\n          d = /** @type {number} */ (instruction[1]);\n          const x1 = pixelCoordinates[d];\n          const y1 = pixelCoordinates[d + 1];\n          const x2 = pixelCoordinates[d + 2];\n          const y2 = pixelCoordinates[d + 3];\n          const dx = x2 - x1;\n          const dy = y2 - y1;\n          const r = Math.sqrt(dx * dx + dy * dy);\n          context.moveTo(x1 + r, y1);\n          context.arc(x1, y1, r, 0, 2 * Math.PI, true);\n          ++i;\n          break;\n        case CanvasInstruction.CLOSE_PATH:\n          context.closePath();\n          ++i;\n          break;\n        case CanvasInstruction.CUSTOM:\n          d = /** @type {number} */ (instruction[1]);\n          dd = instruction[2];\n          const geometry =\n            /** @type {import(\"../../geom/SimpleGeometry.js\").default} */ (\n              instruction[3]\n            );\n          const renderer = instruction[4];\n          const fn = instruction.length == 6 ? instruction[5] : undefined;\n          state.geometry = geometry;\n          state.feature = feature;\n          if (!(i in coordinateCache)) {\n            coordinateCache[i] = [];\n          }\n          const coords = coordinateCache[i];\n          if (fn) {\n            fn(pixelCoordinates, d, dd, 2, coords);\n          } else {\n            coords[0] = pixelCoordinates[d];\n            coords[1] = pixelCoordinates[d + 1];\n            coords.length = 2;\n          }\n          renderer(coords, state);\n          ++i;\n          break;\n        case CanvasInstruction.DRAW_IMAGE:\n          d = /** @type {number} */ (instruction[1]);\n          dd = /** @type {number} */ (instruction[2]);\n          image =\n            /** @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} */ (\n              instruction[3]\n            );\n\n          // Remaining arguments in DRAW_IMAGE are in alphabetical order\n          anchorX = /** @type {number} */ (instruction[4]);\n          anchorY = /** @type {number} */ (instruction[5]);\n          let height = /** @type {number} */ (instruction[6]);\n          const opacity = /** @type {number} */ (instruction[7]);\n          const originX = /** @type {number} */ (instruction[8]);\n          const originY = /** @type {number} */ (instruction[9]);\n          const rotateWithView = /** @type {boolean} */ (instruction[10]);\n          let rotation = /** @type {number} */ (instruction[11]);\n          const scale = /** @type {import(\"../../size.js\").Size} */ (\n            instruction[12]\n          );\n          let width = /** @type {number} */ (instruction[13]);\n          const declutterMode =\n            /** @type {\"declutter\"|\"obstacle\"|\"none\"|undefined} */ (\n              instruction[14]\n            );\n          const declutterImageWithText =\n            /** @type {import(\"../canvas.js\").DeclutterImageWithText} */ (\n              instruction[15]\n            );\n\n          if (!image && instruction.length >= 20) {\n            // create label images\n            text = /** @type {string} */ (instruction[19]);\n            textKey = /** @type {string} */ (instruction[20]);\n            strokeKey = /** @type {string} */ (instruction[21]);\n            fillKey = /** @type {string} */ (instruction[22]);\n            const labelWithAnchor = this.drawLabelWithPointPlacement_(\n              text,\n              textKey,\n              strokeKey,\n              fillKey\n            );\n            image = labelWithAnchor.label;\n            instruction[3] = image;\n            const textOffsetX = /** @type {number} */ (instruction[23]);\n            anchorX = (labelWithAnchor.anchorX - textOffsetX) * this.pixelRatio;\n            instruction[4] = anchorX;\n            const textOffsetY = /** @type {number} */ (instruction[24]);\n            anchorY = (labelWithAnchor.anchorY - textOffsetY) * this.pixelRatio;\n            instruction[5] = anchorY;\n            height = image.height;\n            instruction[6] = height;\n            width = image.width;\n            instruction[13] = width;\n          }\n\n          let geometryWidths;\n          if (instruction.length > 25) {\n            geometryWidths = /** @type {number} */ (instruction[25]);\n          }\n\n          let padding, backgroundFill, backgroundStroke;\n          if (instruction.length > 17) {\n            padding = /** @type {Array<number>} */ (instruction[16]);\n            backgroundFill = /** @type {boolean} */ (instruction[17]);\n            backgroundStroke = /** @type {boolean} */ (instruction[18]);\n          } else {\n            padding = defaultPadding;\n            backgroundFill = false;\n            backgroundStroke = false;\n          }\n\n          if (rotateWithView && viewRotationFromTransform) {\n            // Canvas is expected to be rotated to reverse view rotation.\n            rotation += viewRotation;\n          } else if (!rotateWithView && !viewRotationFromTransform) {\n            // Canvas is not rotated, images need to be rotated back to be north-up.\n            rotation -= viewRotation;\n          }\n          let widthIndex = 0;\n          for (; d < dd; d += 2) {\n            if (\n              geometryWidths &&\n              geometryWidths[widthIndex++] < width / this.pixelRatio\n            ) {\n              continue;\n            }\n            const dimensions = this.calculateImageOrLabelDimensions_(\n              image.width,\n              image.height,\n              pixelCoordinates[d],\n              pixelCoordinates[d + 1],\n              width,\n              height,\n              anchorX,\n              anchorY,\n              originX,\n              originY,\n              rotation,\n              scale,\n              snapToPixel,\n              padding,\n              backgroundFill || backgroundStroke,\n              feature\n            );\n            /** @type {ReplayImageOrLabelArgs} */\n            const args = [\n              context,\n              contextScale,\n              image,\n              dimensions,\n              opacity,\n              backgroundFill\n                ? /** @type {Array<*>} */ (lastFillInstruction)\n                : null,\n              backgroundStroke\n                ? /** @type {Array<*>} */ (lastStrokeInstruction)\n                : null,\n            ];\n            if (declutterTree) {\n              if (declutterMode === 'none') {\n                // not rendered in declutter group\n                continue;\n              } else if (declutterMode === 'obstacle') {\n                // will always be drawn, thus no collision detection, but insert as obstacle\n                declutterTree.insert(dimensions.declutterBox);\n                continue;\n              } else {\n                let imageArgs;\n                let imageDeclutterBox;\n                if (declutterImageWithText) {\n                  const index = dd - d;\n                  if (!declutterImageWithText[index]) {\n                    // We now have the image for an image+text combination.\n                    declutterImageWithText[index] = args;\n                    // Don't render anything for now, wait for the text.\n                    continue;\n                  }\n                  imageArgs = declutterImageWithText[index];\n                  delete declutterImageWithText[index];\n                  imageDeclutterBox = getDeclutterBox(imageArgs);\n                  if (declutterTree.collides(imageDeclutterBox)) {\n                    continue;\n                  }\n                }\n                if (declutterTree.collides(dimensions.declutterBox)) {\n                  continue;\n                }\n                if (imageArgs) {\n                  // We now have image and text for an image+text combination.\n                  declutterTree.insert(imageDeclutterBox);\n                  // Render the image before we render the text.\n                  this.replayImageOrLabel_.apply(this, imageArgs);\n                }\n                declutterTree.insert(dimensions.declutterBox);\n              }\n            }\n            this.replayImageOrLabel_.apply(this, args);\n          }\n          ++i;\n          break;\n        case CanvasInstruction.DRAW_CHARS:\n          const begin = /** @type {number} */ (instruction[1]);\n          const end = /** @type {number} */ (instruction[2]);\n          const baseline = /** @type {number} */ (instruction[3]);\n          const overflow = /** @type {number} */ (instruction[4]);\n          fillKey = /** @type {string} */ (instruction[5]);\n          const maxAngle = /** @type {number} */ (instruction[6]);\n          const measurePixelRatio = /** @type {number} */ (instruction[7]);\n          const offsetY = /** @type {number} */ (instruction[8]);\n          strokeKey = /** @type {string} */ (instruction[9]);\n          const strokeWidth = /** @type {number} */ (instruction[10]);\n          text = /** @type {string} */ (instruction[11]);\n          textKey = /** @type {string} */ (instruction[12]);\n          const pixelRatioScale = [\n            /** @type {number} */ (instruction[13]),\n            /** @type {number} */ (instruction[13]),\n          ];\n\n          const textState = this.textStates[textKey];\n          const font = textState.font;\n          const textScale = [\n            textState.scale[0] * measurePixelRatio,\n            textState.scale[1] * measurePixelRatio,\n          ];\n\n          let cachedWidths;\n          if (font in this.widths_) {\n            cachedWidths = this.widths_[font];\n          } else {\n            cachedWidths = {};\n            this.widths_[font] = cachedWidths;\n          }\n\n          const pathLength = lineStringLength(pixelCoordinates, begin, end, 2);\n          const textLength =\n            Math.abs(textScale[0]) *\n            measureAndCacheTextWidth(font, text, cachedWidths);\n          if (overflow || textLength <= pathLength) {\n            const textAlign = this.textStates[textKey].textAlign;\n            const startM = (pathLength - textLength) * TEXT_ALIGN[textAlign];\n            const parts = drawTextOnPath(\n              pixelCoordinates,\n              begin,\n              end,\n              2,\n              text,\n              startM,\n              maxAngle,\n              Math.abs(textScale[0]),\n              measureAndCacheTextWidth,\n              font,\n              cachedWidths,\n              viewRotationFromTransform ? 0 : this.viewRotation_\n            );\n            drawChars: if (parts) {\n              /** @type {Array<ReplayImageOrLabelArgs>} */\n              const replayImageOrLabelArgs = [];\n              let c, cc, chars, label, part;\n              if (strokeKey) {\n                for (c = 0, cc = parts.length; c < cc; ++c) {\n                  part = parts[c]; // x, y, anchorX, rotation, chunk\n                  chars = /** @type {string} */ (part[4]);\n                  label = this.createLabel(chars, textKey, '', strokeKey);\n                  anchorX =\n                    /** @type {number} */ (part[2]) +\n                    (textScale[0] < 0 ? -strokeWidth : strokeWidth);\n                  anchorY =\n                    baseline * label.height +\n                    ((0.5 - baseline) * 2 * strokeWidth * textScale[1]) /\n                      textScale[0] -\n                    offsetY;\n                  const dimensions = this.calculateImageOrLabelDimensions_(\n                    label.width,\n                    label.height,\n                    part[0],\n                    part[1],\n                    label.width,\n                    label.height,\n                    anchorX,\n                    anchorY,\n                    0,\n                    0,\n                    part[3],\n                    pixelRatioScale,\n                    false,\n                    defaultPadding,\n                    false,\n                    feature\n                  );\n                  if (\n                    declutterTree &&\n                    declutterTree.collides(dimensions.declutterBox)\n                  ) {\n                    break drawChars;\n                  }\n                  replayImageOrLabelArgs.push([\n                    context,\n                    contextScale,\n                    label,\n                    dimensions,\n                    1,\n                    null,\n                    null,\n                  ]);\n                }\n              }\n              if (fillKey) {\n                for (c = 0, cc = parts.length; c < cc; ++c) {\n                  part = parts[c]; // x, y, anchorX, rotation, chunk\n                  chars = /** @type {string} */ (part[4]);\n                  label = this.createLabel(chars, textKey, fillKey, '');\n                  anchorX = /** @type {number} */ (part[2]);\n                  anchorY = baseline * label.height - offsetY;\n                  const dimensions = this.calculateImageOrLabelDimensions_(\n                    label.width,\n                    label.height,\n                    part[0],\n                    part[1],\n                    label.width,\n                    label.height,\n                    anchorX,\n                    anchorY,\n                    0,\n                    0,\n                    part[3],\n                    pixelRatioScale,\n                    false,\n                    defaultPadding,\n                    false,\n                    feature\n                  );\n                  if (\n                    declutterTree &&\n                    declutterTree.collides(dimensions.declutterBox)\n                  ) {\n                    break drawChars;\n                  }\n                  replayImageOrLabelArgs.push([\n                    context,\n                    contextScale,\n                    label,\n                    dimensions,\n                    1,\n                    null,\n                    null,\n                  ]);\n                }\n              }\n              if (declutterTree) {\n                declutterTree.load(replayImageOrLabelArgs.map(getDeclutterBox));\n              }\n              for (let i = 0, ii = replayImageOrLabelArgs.length; i < ii; ++i) {\n                this.replayImageOrLabel_.apply(this, replayImageOrLabelArgs[i]);\n              }\n            }\n          }\n          ++i;\n          break;\n        case CanvasInstruction.END_GEOMETRY:\n          if (featureCallback !== undefined) {\n            feature = /** @type {import(\"../../Feature.js\").FeatureLike} */ (\n              instruction[1]\n            );\n            const result = featureCallback(feature, currentGeometry);\n            if (result) {\n              return result;\n            }\n          }\n          ++i;\n          break;\n        case CanvasInstruction.FILL:\n          if (batchSize) {\n            pendingFill++;\n          } else {\n            this.fill_(context);\n          }\n          ++i;\n          break;\n        case CanvasInstruction.MOVE_TO_LINE_TO:\n          d = /** @type {number} */ (instruction[1]);\n          dd = /** @type {number} */ (instruction[2]);\n          x = pixelCoordinates[d];\n          y = pixelCoordinates[d + 1];\n          roundX = (x + 0.5) | 0;\n          roundY = (y + 0.5) | 0;\n          if (roundX !== prevX || roundY !== prevY) {\n            context.moveTo(x, y);\n            prevX = roundX;\n            prevY = roundY;\n          }\n          for (d += 2; d < dd; d += 2) {\n            x = pixelCoordinates[d];\n            y = pixelCoordinates[d + 1];\n            roundX = (x + 0.5) | 0;\n            roundY = (y + 0.5) | 0;\n            if (d == dd - 2 || roundX !== prevX || roundY !== prevY) {\n              context.lineTo(x, y);\n              prevX = roundX;\n              prevY = roundY;\n            }\n          }\n          ++i;\n          break;\n        case CanvasInstruction.SET_FILL_STYLE:\n          lastFillInstruction = instruction;\n          this.alignFill_ = instruction[2];\n\n          if (pendingFill) {\n            this.fill_(context);\n            pendingFill = 0;\n            if (pendingStroke) {\n              context.stroke();\n              pendingStroke = 0;\n            }\n          }\n\n          context.fillStyle =\n            /** @type {import(\"../../colorlike.js\").ColorLike} */ (\n              instruction[1]\n            );\n          ++i;\n          break;\n        case CanvasInstruction.SET_STROKE_STYLE:\n          lastStrokeInstruction = instruction;\n          if (pendingStroke) {\n            context.stroke();\n            pendingStroke = 0;\n          }\n          this.setStrokeStyle_(context, /** @type {Array<*>} */ (instruction));\n          ++i;\n          break;\n        case CanvasInstruction.STROKE:\n          if (batchSize) {\n            pendingStroke++;\n          } else {\n            context.stroke();\n          }\n          ++i;\n          break;\n        default: // consume the instruction anyway, to avoid an infinite loop\n          ++i;\n          break;\n      }\n    }\n    if (pendingFill) {\n      this.fill_(context);\n    }\n    if (pendingStroke) {\n      context.stroke();\n    }\n    return undefined;\n  }\n\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {number} contextScale Scale of the context.\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\n   * @param {number} viewRotation View rotation.\n   * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.\n   * @param {import(\"rbush\").default} [declutterTree] Declutter tree.\n   */\n  execute(\n    context,\n    contextScale,\n    transform,\n    viewRotation,\n    snapToPixel,\n    declutterTree\n  ) {\n    this.viewRotation_ = viewRotation;\n    this.execute_(\n      context,\n      contextScale,\n      transform,\n      this.instructions,\n      snapToPixel,\n      undefined,\n      undefined,\n      declutterTree\n    );\n  }\n\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\n   * @param {number} viewRotation View rotation.\n   * @param {FeatureCallback<T>} [featureCallback] Feature callback.\n   * @param {import(\"../../extent.js\").Extent} [hitExtent] Only check\n   *     features that intersect this extent.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n  executeHitDetection(\n    context,\n    transform,\n    viewRotation,\n    featureCallback,\n    hitExtent\n  ) {\n    this.viewRotation_ = viewRotation;\n    return this.execute_(\n      context,\n      1,\n      transform,\n      this.hitDetectionInstructions,\n      true,\n      featureCallback,\n      hitExtent\n    );\n  }\n}\n\nexport default Executor;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}