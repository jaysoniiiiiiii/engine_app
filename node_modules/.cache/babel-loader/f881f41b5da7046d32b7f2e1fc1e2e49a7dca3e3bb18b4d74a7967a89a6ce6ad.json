{"ast":null,"code":"import _classCallCheck from \"/home/jay/Downloads/major/my-app/gis/web-gis/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/jay/Downloads/major/my-app/gis/web-gis/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"/home/jay/Downloads/major/my-app/gis/web-gis/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _get from \"/home/jay/Downloads/major/my-app/gis/web-gis/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/home/jay/Downloads/major/my-app/gis/web-gis/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/home/jay/Downloads/major/my-app/gis/web-gis/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/home/jay/Downloads/major/my-app/gis/web-gis/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\n/**\n * @module ol/renderer/Layer\n */\nimport EventType from '../events/EventType.js';\nimport ImageState from '../ImageState.js';\nimport Observable from '../Observable.js';\nimport { abstract } from '../util.js';\n\n/**\n * @template {import(\"../layer/Layer.js\").default} LayerType\n */\nvar LayerRenderer = /*#__PURE__*/function (_Observable) {\n  _inherits(LayerRenderer, _Observable);\n  var _super = _createSuper(LayerRenderer);\n  /**\n   * @param {LayerType} layer Layer.\n   */\n  function LayerRenderer(layer) {\n    var _this;\n    _classCallCheck(this, LayerRenderer);\n    _this = _super.call(this);\n\n    /**\n     * The renderer is initialized and ready to render.\n     * @type {boolean}\n     */\n    _this.ready = true;\n\n    /** @private */\n    _this.boundHandleImageChange_ = _this.handleImageChange_.bind(_assertThisInitialized(_this));\n\n    /**\n     * @protected\n     * @type {LayerType}\n     */\n    _this.layer_ = layer;\n\n    /**\n     * @type {import(\"../render/canvas/ExecutorGroup\").default}\n     */\n    _this.declutterExecutorGroup = null;\n    return _this;\n  }\n\n  /**\n   * Asynchronous layer level hit detection.\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\n   * @return {Promise<Array<import(\"../Feature\").FeatureLike>>} Promise that resolves with\n   * an array of features.\n   */\n  _createClass(LayerRenderer, [{\n    key: \"getFeatures\",\n    value: function getFeatures(pixel) {\n      return abstract();\n    }\n\n    /**\n     * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\n     * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.\n     */\n  }, {\n    key: \"getData\",\n    value: function getData(pixel) {\n      return null;\n    }\n\n    /**\n     * Determine whether render should be called.\n     * @abstract\n     * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n     * @return {boolean} Layer is ready to be rendered.\n     */\n  }, {\n    key: \"prepareFrame\",\n    value: function prepareFrame(frameState) {\n      return abstract();\n    }\n\n    /**\n     * Render the layer.\n     * @abstract\n     * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n     * @param {HTMLElement} target Target that may be used to render content to.\n     * @return {HTMLElement} The rendered element.\n     */\n  }, {\n    key: \"renderFrame\",\n    value: function renderFrame(frameState, target) {\n      return abstract();\n    }\n\n    /**\n     * @param {Object<number, Object<string, import(\"../Tile.js\").default>>} tiles Lookup of loaded tiles by zoom level.\n     * @param {number} zoom Zoom level.\n     * @param {import(\"../Tile.js\").default} tile Tile.\n     * @return {boolean|void} If `false`, the tile will not be considered loaded.\n     */\n  }, {\n    key: \"loadedTileCallback\",\n    value: function loadedTileCallback(tiles, zoom, tile) {\n      if (!tiles[zoom]) {\n        tiles[zoom] = {};\n      }\n      tiles[zoom][tile.tileCoord.toString()] = tile;\n      return undefined;\n    }\n\n    /**\n     * Create a function that adds loaded tiles to the tile lookup.\n     * @param {import(\"../source/Tile.js\").default} source Tile source.\n     * @param {import(\"../proj/Projection.js\").default} projection Projection of the tiles.\n     * @param {Object<number, Object<string, import(\"../Tile.js\").default>>} tiles Lookup of loaded tiles by zoom level.\n     * @return {function(number, import(\"../TileRange.js\").default):boolean} A function that can be\n     *     called with a zoom level and a tile range to add loaded tiles to the lookup.\n     * @protected\n     */\n  }, {\n    key: \"createLoadedTileFinder\",\n    value: function createLoadedTileFinder(source, projection, tiles) {\n      var _this2 = this;\n      return (\n        /**\n         * @param {number} zoom Zoom level.\n         * @param {import(\"../TileRange.js\").default} tileRange Tile range.\n         * @return {boolean} The tile range is fully loaded.\n         */\n        function (zoom, tileRange) {\n          var callback = _this2.loadedTileCallback.bind(_this2, tiles, zoom);\n          return source.forEachLoadedTile(projection, zoom, tileRange, callback);\n        }\n      );\n    }\n    /**\n     * @abstract\n     * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n     * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n     * @param {number} hitTolerance Hit tolerance in pixels.\n     * @param {import(\"./vector.js\").FeatureCallback<T>} callback Feature callback.\n     * @param {Array<import(\"./Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\n     * @return {T|undefined} Callback result.\n     * @template T\n     */\n  }, {\n    key: \"forEachFeatureAtCoordinate\",\n    value: function forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, matches) {\n      return undefined;\n    }\n\n    /**\n     * @return {LayerType} Layer.\n     */\n  }, {\n    key: \"getLayer\",\n    value: function getLayer() {\n      return this.layer_;\n    }\n\n    /**\n     * Perform action necessary to get the layer rendered after new fonts have loaded\n     * @abstract\n     */\n  }, {\n    key: \"handleFontsChanged\",\n    value: function handleFontsChanged() {}\n\n    /**\n     * Handle changes in image state.\n     * @param {import(\"../events/Event.js\").default} event Image change event.\n     * @private\n     */\n  }, {\n    key: \"handleImageChange_\",\n    value: function handleImageChange_(event) {\n      var image = /** @type {import(\"../Image.js\").default} */event.target;\n      if (image.getState() === ImageState.LOADED) {\n        this.renderIfReadyAndVisible();\n      }\n    }\n\n    /**\n     * Load the image if not already loaded, and register the image change\n     * listener if needed.\n     * @param {import(\"../ImageBase.js\").default} image Image.\n     * @return {boolean} `true` if the image is already loaded, `false` otherwise.\n     * @protected\n     */\n  }, {\n    key: \"loadImage\",\n    value: function loadImage(image) {\n      var imageState = image.getState();\n      if (imageState != ImageState.LOADED && imageState != ImageState.ERROR) {\n        image.addEventListener(EventType.CHANGE, this.boundHandleImageChange_);\n      }\n      if (imageState == ImageState.IDLE) {\n        image.load();\n        imageState = image.getState();\n      }\n      return imageState == ImageState.LOADED;\n    }\n\n    /**\n     * @protected\n     */\n  }, {\n    key: \"renderIfReadyAndVisible\",\n    value: function renderIfReadyAndVisible() {\n      var layer = this.getLayer();\n      if (layer && layer.getVisible() && layer.getSourceState() === 'ready') {\n        layer.changed();\n      }\n    }\n\n    /**\n     * Clean up.\n     */\n  }, {\n    key: \"disposeInternal\",\n    value: function disposeInternal() {\n      delete this.layer_;\n      _get(_getPrototypeOf(LayerRenderer.prototype), \"disposeInternal\", this).call(this);\n    }\n  }]);\n  return LayerRenderer;\n}(Observable);\nexport default LayerRenderer;","map":{"version":3,"names":["EventType","ImageState","Observable","abstract","LayerRenderer","_Observable","_inherits","_super","_createSuper","layer","_this","_classCallCheck","call","ready","boundHandleImageChange_","handleImageChange_","bind","_assertThisInitialized","layer_","declutterExecutorGroup","_createClass","key","value","getFeatures","pixel","getData","prepareFrame","frameState","renderFrame","target","loadedTileCallback","tiles","zoom","tile","tileCoord","toString","undefined","createLoadedTileFinder","source","projection","_this2","tileRange","callback","forEachLoadedTile","forEachFeatureAtCoordinate","coordinate","hitTolerance","matches","getLayer","handleFontsChanged","event","image","getState","LOADED","renderIfReadyAndVisible","loadImage","imageState","ERROR","addEventListener","CHANGE","IDLE","load","getVisible","getSourceState","changed","disposeInternal","_get","_getPrototypeOf","prototype"],"sources":["/home/jay/Downloads/major/my-app/gis/web-gis/node_modules/ol/renderer/Layer.js"],"sourcesContent":["/**\n * @module ol/renderer/Layer\n */\nimport EventType from '../events/EventType.js';\nimport ImageState from '../ImageState.js';\nimport Observable from '../Observable.js';\nimport {abstract} from '../util.js';\n\n/**\n * @template {import(\"../layer/Layer.js\").default} LayerType\n */\nclass LayerRenderer extends Observable {\n  /**\n   * @param {LayerType} layer Layer.\n   */\n  constructor(layer) {\n    super();\n\n    /**\n     * The renderer is initialized and ready to render.\n     * @type {boolean}\n     */\n    this.ready = true;\n\n    /** @private */\n    this.boundHandleImageChange_ = this.handleImageChange_.bind(this);\n\n    /**\n     * @protected\n     * @type {LayerType}\n     */\n    this.layer_ = layer;\n\n    /**\n     * @type {import(\"../render/canvas/ExecutorGroup\").default}\n     */\n    this.declutterExecutorGroup = null;\n  }\n\n  /**\n   * Asynchronous layer level hit detection.\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\n   * @return {Promise<Array<import(\"../Feature\").FeatureLike>>} Promise that resolves with\n   * an array of features.\n   */\n  getFeatures(pixel) {\n    return abstract();\n  }\n\n  /**\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.\n   */\n  getData(pixel) {\n    return null;\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @abstract\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrame(frameState) {\n    return abstract();\n  }\n\n  /**\n   * Render the layer.\n   * @abstract\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target that may be used to render content to.\n   * @return {HTMLElement} The rendered element.\n   */\n  renderFrame(frameState, target) {\n    return abstract();\n  }\n\n  /**\n   * @param {Object<number, Object<string, import(\"../Tile.js\").default>>} tiles Lookup of loaded tiles by zoom level.\n   * @param {number} zoom Zoom level.\n   * @param {import(\"../Tile.js\").default} tile Tile.\n   * @return {boolean|void} If `false`, the tile will not be considered loaded.\n   */\n  loadedTileCallback(tiles, zoom, tile) {\n    if (!tiles[zoom]) {\n      tiles[zoom] = {};\n    }\n    tiles[zoom][tile.tileCoord.toString()] = tile;\n    return undefined;\n  }\n\n  /**\n   * Create a function that adds loaded tiles to the tile lookup.\n   * @param {import(\"../source/Tile.js\").default} source Tile source.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection of the tiles.\n   * @param {Object<number, Object<string, import(\"../Tile.js\").default>>} tiles Lookup of loaded tiles by zoom level.\n   * @return {function(number, import(\"../TileRange.js\").default):boolean} A function that can be\n   *     called with a zoom level and a tile range to add loaded tiles to the lookup.\n   * @protected\n   */\n  createLoadedTileFinder(source, projection, tiles) {\n    return (\n      /**\n       * @param {number} zoom Zoom level.\n       * @param {import(\"../TileRange.js\").default} tileRange Tile range.\n       * @return {boolean} The tile range is fully loaded.\n       */\n      (zoom, tileRange) => {\n        const callback = this.loadedTileCallback.bind(this, tiles, zoom);\n        return source.forEachLoadedTile(projection, zoom, tileRange, callback);\n      }\n    );\n  }\n  /**\n   * @abstract\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {import(\"./vector.js\").FeatureCallback<T>} callback Feature callback.\n   * @param {Array<import(\"./Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n  forEachFeatureAtCoordinate(\n    coordinate,\n    frameState,\n    hitTolerance,\n    callback,\n    matches\n  ) {\n    return undefined;\n  }\n\n  /**\n   * @return {LayerType} Layer.\n   */\n  getLayer() {\n    return this.layer_;\n  }\n\n  /**\n   * Perform action necessary to get the layer rendered after new fonts have loaded\n   * @abstract\n   */\n  handleFontsChanged() {}\n\n  /**\n   * Handle changes in image state.\n   * @param {import(\"../events/Event.js\").default} event Image change event.\n   * @private\n   */\n  handleImageChange_(event) {\n    const image = /** @type {import(\"../Image.js\").default} */ (event.target);\n    if (image.getState() === ImageState.LOADED) {\n      this.renderIfReadyAndVisible();\n    }\n  }\n\n  /**\n   * Load the image if not already loaded, and register the image change\n   * listener if needed.\n   * @param {import(\"../ImageBase.js\").default} image Image.\n   * @return {boolean} `true` if the image is already loaded, `false` otherwise.\n   * @protected\n   */\n  loadImage(image) {\n    let imageState = image.getState();\n    if (imageState != ImageState.LOADED && imageState != ImageState.ERROR) {\n      image.addEventListener(EventType.CHANGE, this.boundHandleImageChange_);\n    }\n    if (imageState == ImageState.IDLE) {\n      image.load();\n      imageState = image.getState();\n    }\n    return imageState == ImageState.LOADED;\n  }\n\n  /**\n   * @protected\n   */\n  renderIfReadyAndVisible() {\n    const layer = this.getLayer();\n    if (layer && layer.getVisible() && layer.getSourceState() === 'ready') {\n      layer.changed();\n    }\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    delete this.layer_;\n    super.disposeInternal();\n  }\n}\n\nexport default LayerRenderer;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}